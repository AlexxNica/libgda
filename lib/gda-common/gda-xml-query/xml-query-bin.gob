%at{
/* XmlQuery: the xml query object
 * Copyright (C) 2000 Gerhard Dieringer
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 */
%}
%h{

#include "xml-query-item.h"


%}


%{

#include "xml-query-item-private.h"


%}



class Xml:Query:Bin from Xml:Query:Item {
    private XmlQueryItem  *child   = NULL   destroywith gtk_object_unref;

    public Xml:Query:Item *
    new(gchar *tag, gchar *sqlfmt, gchar *sqlop)
    {
	XmlQueryItem *bin;

        bin = (XmlQueryItem *)GET_NEW;
        xml_query_item_set_tag(bin,tag);
        xml_query_item_set_sqlfmt(bin,sqlfmt);
        xml_query_item_set_sqlop(bin,sqlop);

	return bin;
    }


    public Xml:Query:Item *
    new_with_data(gchar *tag, gchar *sqlfmt, gchar *sqlop,
		  Xml:Query:Item *child)
    {
	XmlQueryItem *bin;

	bin = xml_query_bin_new(tag,sqlfmt,sqlop);
        xml_query_item_add(bin,child);

	return bin;
    }


    override (Xml:Query:Item) void
    add(Xml:Query:Item *parent, Xml:Query:Item *child (check type))
    {
        Self *self = SELF(parent);

        if (self->_priv->child != NULL)
	    gtk_object_unref(GTK_OBJECT(self->_priv->child));
        self->_priv->child = child;
 
        xml_query_item_set_parent(child,parent);
    }


    public XmlQueryItem *
    get_child(self)
    {
        return self->_priv->child;
    }


    public void
    set_child(self, Xml:Query:Item *item (check null type))
    {
        if (self->_priv->child != NULL)
            gtk_object_unref(GTK_OBJECT(self->_priv->child));
        self->_priv->child = item;
    }


    override (Xml:Query:Item) xmlNode *
    to_dom(Xml:Query:Item *parent, xmlNode *parNode)
    {
        Self *self = SELF(parent);
        xmlNode *node;

        node = PARENT_HANDLER(parent,parNode);
        TO_DOM(self->_priv->child,node);

        return node;
    }

    override (Xml:Query:Item) gchar *
    to_sql(Xml:Query:Item *parent)
    {
        Self *self = SELF(parent);
        gchar *output, *child, *fmt;
        

        fmt = xml_query_item_get_sqlfmt(parent);
        child = TO_SQL(self->_priv->child);
        if (fmt != NULL) {
            output = g_strdup_printf(fmt,child);
            g_free(child);
        }
	else
	    output = child;

        return output;
    }


    public XmlQueryItem *
    new_union(void)
    {
        return xml_query_bin_new("union","union %s",NULL);
    }


    public XmlQueryItem *
    new_unionall(void)
    {
        return xml_query_bin_new("unionall","unionall %s",NULL);
    }


    public XmlQueryItem *
    new_intersect(void)
    {
        return xml_query_bin_new("intersect","intersect %s",NULL);
    }


    public XmlQueryItem *
    new_minus(void)
    {
        return xml_query_bin_new("minus","minus %s",NULL);
    }


    public XmlQueryItem *
    new_where(void)
    {
        return xml_query_bin_new("where","where %s",NULL);
    }


    public XmlQueryItem *
    new_where_with_data(XmlQueryItem *data)
    {
        XmlQueryItem *where;

        where = xml_query_bin_new("where","where %s",NULL);
        xml_query_item_add(where,data);

        return where;
    }


    public XmlQueryItem *
    new_having(void)
    {
        return xml_query_bin_new("having","having %s",NULL);
    }


    public XmlQueryItem *
    new_having_with_data(XmlQueryItem *data)
    {
        XmlQueryItem *having;

        having = xml_query_bin_new("having","having %s",NULL);
        xml_query_item_add(having,data);

        return having;
    }


    public XmlQueryItem *
    new_on(void)
    {
        return xml_query_bin_new("on","on %s",NULL);
    }


    public XmlQueryItem *
    new_not(void)
    {
        return xml_query_bin_new("not","(not %s)",NULL);
    }


    public XmlQueryItem *
    new_not_with_data(XmlQueryItem *data)
    {
        XmlQueryItem *not;

        not = xml_query_bin_new("not","(not %s)",NULL);
        xml_query_item_add(not,data);

        return not;
    }


    public XmlQueryItem *
    new_exists(void)
    {
        return xml_query_bin_new("exists","(exists %s)",NULL);
    }


    public XmlQueryItem *
    new_null(void)
    {
        return xml_query_bin_new("null","(%s is null)",NULL);
    }


    public XmlQueryItem *
    new_null_with_data(XmlQueryItem *data)
    {
        XmlQueryItem *null;

        null = xml_query_bin_new("null","(%s is null)",NULL);
        xml_query_item_add(null,data);
        return null;
    }


    override (Xml:Query:Item) Xml:Query:Item *
    find_id(Xml:Query:Item *parent, gchar *id)
    {
        XmlQueryItem *item;
        Self           *self = SELF(parent);

        item = PARENT_HANDLER(parent,id);
        if (item != NULL)
            return item;
        return xml_query_item_find_id(xml_query_bin_get_child(self),id);
    }



}

