<chapter id="getting_started">
  <title>Code examples</title>
  <sect1 id="initializing">
    <title>Initialising</title>
    <para>
      First of all you have to initialise the gda library, i.e. to call the
      <link linkend="gda-init"><emphasis>gda_init ()</emphasis></link> function, for example:
    </para>
    <programlisting>
gda_init ("TestGDA", "0.1", argc, argv);
    </programlisting>
    <para>
      After initialising you can work as usual or make &LIBGDA; call a custom defined function
      calling <link linkend="gda-main-run">gda_main_run()</link> (note that
      if you use this way you will need to call <link linkend="gda-main-quit">gda_main_quit()</link> 
      in order to finish the program).
    </para>
    <para>For example a basic program would look like:
      <programlisting>
void
do_stuff () 
{
	GdaClient *client;
	GdaConnection *connection;
      
        /* open a connection */
	client = gda_client_new ();      
	g_print ("CONNECTING\n");
	connection = gda_client_open_connection (client, "calvaris", NULL, NULL,
						 GDA_CONNECTION_OPTIONS_READ_ONLY);
	g_print ("CONNECTED\n");
      
        /* use the connection */
	execute_some_queries (connection);
      
        /* close the connection */
        g_object_unref (G_OBJECT (connection));
	g_object_unref (G_OBJECT (client));
}
      
      
int
main (int argc, char **argv)
{
	g_print ("STARTING\n");

	gda_init ("TestGDA", "0.1", argc, argv);
      	do_stuff();

	g_print("ENDING\n");      
}
      </programlisting>
    </para>
  </sect1>

  
  <sect1 id="connections">
    <title>Connecting</title>
    <para>
      &LIBGDA; allows data sources (DSN) to be defined and refered to by a unique name which contains all the 
      required information to actually open a connection (except the name and password if they are required). Of
      course it's still possible to open a connection without having defined a DSN, in which case a <emphasis>connection
      string</emphasis> is used to specify all the parameters resuired to open a connection. For more information
      about connection strings, see the <link linkend="gda-client-open-connection-from-string">gda_client_open_connection_from_string ()</link>'s documentation.
    </para>
    <para>
      Connections are created by a <link linkend="GdaClient">GdaClient</link> object which can also manage connection pools.
      So the first step is to create a GdaClient object using 
      <link linkend="gda-client-new">gda_client_new ()</link>, and then use
      <link linkend="gda-client-open-connection">gda_client_open_connection ()</link> (or 
      <link linkend="gda-client-open-connection-from-string">gda_client_open_connection_from_string ()</link>
      for connections not defined as DSN)
      to create connection objects (<link linkend="GdaConnection">GdaConnection</link> objects). Each connection object
      can then be used to actually execute queries, for example:
      <programlisting>
void
do_stuff () {
	GdaClient *client;
	GdaConnection *connection;
      
        /* open a connection */
	client = gda_client_new ();      
	g_print ("CONNECTING\n");
	connection = gda_client_open_connection (client, "calvaris", NULL, NULL,
						 GDA_CONNECTION_OPTIONS_READ_ONLY);
	g_print ("CONNECTED\n");
      
        /* use the connection */
	execute_some_queries (connection);
      
        /* close the connection */
        g_object_unref (G_OBJECT (connection));
	g_object_unref (G_OBJECT (client));
}
      </programlisting>
    </para>
    <para>
      Closing the connection can be ordered using <link linkend="gda-connection-close">gda_connection_close ()</link>,
      or is automatically done when the connection object is destroyed (as is the case in the example abive when 
      g_object_unref() is called with the connection as argument).
    </para>
  </sect1>


  <sect1>
    <title>Executing queries</title>
    <para>
      &LIBGDA; offers several ways of executing queries which are outlined here:
      <itemizedlist>
	<listitem><para>Using a <link linkend="GdaCommand">GdaCommand</link> structure which is the simplest
	    way, and allows one to specify an SQL statement.</para></listitem>
	<listitem><para>Using a <link linkend="GdaQuery">GdaQuery</link> object which needs a bit more code
	    but also offers additional features</para></listitem>
      </itemizedlist>
    </para>
    <sect2 id="using-GdaCommand">
      <para>
	A <link linkend="GdaCommand">GdaCommand</link> can only contain a <emphasis>static</emphasis> SQL statement
	without any variables in it, and it is very easy to use.
      </para>
      <title>Using a GdaCommand</title>
      <sect3 id="building-commands">
	<title>GdaCommand: building a command</title>
	<para>
	  A <link linkend="GdaCommand">GdaCommand</link> structure can be created using <link linkend="gda-command-new">
	    gda_command_new ()</link>. To execute a SQL statement, specify  
	  <link linkend="GdaCommandType">GDA_COMMAND_TYPE_SQL</link> as the command type. It is also possible to specify
	  execution options using the <link linkend="GdaCommandOptions">GdaCommandOptions</link> options. 
	</para>
	<para>
	  It is also possible to bundle together several SQL statement within a single GdaCommand structure (the SQL
	  statements are separated by a ";").
	</para>
	<para>
          For example executing a SELECT statement could be done as in the following code (note that in this code the
	  programmer <emphasis>knows</emphasis> that the "sql" argument
	  is a SELECT statement):
          <programlisting>
GdaDataModel *
execute_sql (GdaConnection *connection, const gchar *sql)
{
          GdaCommand *command;
          GdaDataModel *result;
          
          command = gda_command_new (sql, GDA_COMMAND_TYPE_SQL, GDA_COMMAND_OPTION_STOP_ON_ERRORS);
          result  = gda_connection_execute_select_command (connection, command, NULL, NULL);
          gda_command_free (command);
          
          return result;
}
          </programlisting>
	</para>
      </sect3>

      <sect3 id="normal-queries">
	<title>GdaCommand: SELECT queries</title>
	<para>
	  If the programmer <emphasis>knows</emphasis> that the command is a SELECT query (and that there is
	  only one statement) then it's best to use the 
	  <link linkend="gda-connection-execute-select-command">gda_connection_execute_select_command ()</link> method
	  which will return a single <link linkend="GdaDataModel">GdaDataModel</link> object containing the resultset
	  of the command's execution, or NULL if an error occurred. 
	  See the <link linkend="GdaDataModel">GdaDataModel</link>'s documentation for
	  more information about how to use the resultset, or look at the 
	  <link linkend="data-model">managing data models</link> section.
	</para>
	<para>
	  For example the following function cound be used to execute a non SELECT query from an SQL statement:
	  <programlisting>
static GdaDataModel *
run_sql_select (GdaConnection *cnc, const gchar *sql)
{
        GdaCommand *command;
        GError *error = NULL;
        GdaDataModel *res;

        command = gda_command_new (sql, GDA_COMMAND_TYPE_SQL, 0);
        res = gda_connection_execute_select_command (cnc, command, NULL, &amp;error);
        gda_command_free (command);
        if (!res)
                g_error ("Could not execute query: %s\n",error &amp;&amp; error->message ? error->message : "no detail");
        return res;
}
	  </programlisting>
	</para>
      </sect3>

      <sect3 id="making-queries">
	<title>GdaCommand: non SELECT queries</title>
	<para>
	  If the programmer <emphasis>knows</emphasis> that the command is not a SELECT query, such as INSERT,
	  UPDATE or DELETE commands (and that there is
	  only one statement) then it's best to use the 
	  <link linkend="gda-connection-execute-non-select-command">gda_connection_execute_non_select_command ()</link> method
	  which will return the number of affected rows, or a negative value if an error occurred.
	</para>
	<para>
	  Note that it's also possible to use DDL statements (such as "CREATE TABLE...", etc) statement, but in this case
	  for more portability, it is recommended to use &LIBGDA;'s specific API, 
	  see <link linkend="DDLIntro">this section</link> for more information.
	</para>
	<para>
	  For example the following function cound be used to execute a non SELECT query from an SQL statement:
	  <programlisting>
void
run_sql_non_select (GdaConnection *cnc, const gchar *sql)
{
        GdaCommand *command;
        GError *error = NULL;
        gint nrows;

        command = gda_command_new (sql, GDA_COMMAND_TYPE_SQL, 0);
        nrows = gda_connection_execute_non_select_command (cnc, command, NULL, &amp;error);
        gda_command_free (command);
        if (nrows == -1)
                g_error ("NON SELECT error: %s\n", error &amp;&amp; error->message ? error->message : "no detail");
}
	  </programlisting>
	</para>
      </sect3>

      <sect3 id="multiple-queries">
	<title>GdaCommand: general usage, multiple statements</title>
	<para>
	  In the event the number of SQL statements in the command is unknown, or the kind of SQL statement is unknown,
	  then the general way is to use the 
	  <link linkend="gda-connection-execute-command">gda_connection_execute_command ()</link> which returns a list
	  of objects, one per SQL statement. It is of course also possible to use this method in place of the
	  other methods examined in the previous sections.
	</para>
      </sect3>
    </sect2>

    <sect2 id="using-GdaQuery">
      <title>Using a GdaQuery</title>
      <para>
	A <link linkend="GdaQuery">GdaQuery</link> object can contain variables, and a value needs to be assigned to
	each before the query can be run; the same query object can then be run as a prepared statement, only binding
	variables each time.
      </para>
      <para>
	a GdaQuery object can <emphasis>understood</emphasis> by &LIBGDA; (it can find the fields, the expressions, the tables
	involved, etc), and the API to maniplate its internals is quite long (it is of a good usage when building queries
	from known elements without using SQL). However &LIBGDA; offers a simple method to create a GdaQuery from a SQL
	statement using <link linkend="gda-query-new-from-sql">gda_query_new_from_sql ()</link>.
      </para>
      <para>
	Using a GdaQuery to execute commands has the following advantages:
	<itemizedlist>
	  <listitem><para>the SQL statement can be internally treaded as a prepared statement (depending on the database
	  provider) which speeds query execution</para></listitem>
	  <listitem><para>variables (place holders) can be used, their syntax being independant of the database actually used,
	  see the <link linkend="SQL_queries">GDA SQL query syntax</link> for more information</para></listitem>
	  <listitem><para>if used with a <link linkend="GdaDict">GdaDict</link> dictionary, it is possible to tell
	  if the query only references existing objects (with some limitations, though)</para></listitem>
	  <listitem><para>it is possible to know the kind of query a GdaQuery is (SELECT, INSERT, etc)</para></listitem>
	  <listitem><para>a GdaQuery can only contain one SQL statement</para></listitem>
	</itemizedlist>
      </para>
      <para>
	Executing a GdaQuery query is a matter of calling <link linkend="gda-query-execute">gda_query_execute ()</link>.
	Note however that the actual connection object used to execute the query is the 
	<link linkend="gda-dict-set-connection">connection assigned</link> to the
	dictionary referenced by the GdaQuery object (the 1st argument of the gda_query_new_from_sql() call).
      </para>
      <para>
	The following example shows how to use a GdaQuery to list the details of some data while making a variable
	(named "the_id") vary from 0 to 9 (for simplicity, error checking has been removed):
	<programlisting>
GdaQuery *query;
GdaParameterList *params;
GdaParameter *p;
GValue *value;
gint i;

cnc = ...;

[...]

gda_dict_set_connection (default_dict, cnc);
query = gda_query_new_from_sql (NULL, 
                                "SELECT * FROM customers WHERE id=##the_id::gint", NULL);
params = gda_query_get_parameter_list (query);
p = gda_parameter_list_find_param (params, "the_id");
value = gda_value_new (G_TYPE_INT);
for (i = 0; i &lt; 10; i++) {
	GdaDataModel *res;
	g_value_set_int (value, i);
	gda_parameter_set_value (p, value);
	res = gda_query_execute (query, params, FALSE, NULL);
	gda_data_model_dump (res, stdout);
	g_object_unref (res);
}
g_object_unref (params);
g_object_unref (query);
	</programlisting>
	Note that in the example above, the GdaQuery object is created using the default dictionary (the NULL value is
	passed as gda_query_new_from_sql() first argument), which is the reason why we assign the "cnc" connection to
	"default_dict" before.
      </para>
    </sect2>
  </sect1>
  
  <sect1 id="data-model">
    <title>Managing data models</title>
    <para>
      Each time a SELECT query is executed, it returns a <link linkend="GdaDataModel">GdaDataModel</link>
      object, which contains methods to access the returned data. Note that <link linkend="GdaDataModel">GdaDataModel</link>
      is in fact an interface and is implemented in very various ways depending on the database provider executing the
      query; however any GdaDataModel object is used the same way. Note that GdaDataModel objects are also generally used to 
      represent an array of data where all the data in a column is of the same type.
    </para>
    <para>
      Some data models can be modified, some can't and knowing the features of a specific data model instance
      can be done using the <link linkend="gda-data-model-get-access-flags">gda_data_model_get_access_flags ()</link>
      and <link linkend="gda-data-model-get-attributes-at">gda_data_model_get_attributes_at ()</link> methods.
      Data models returned when SELECT queries are executed usually are not modifiable.
    </para>
    <para>
      The value stored in each cell of a data model (at a <emphasis>(column, row)</emphasis> position) is a 
      read-only <link linkend="GValue">GValue</link> pointer. 
      Accessing the data in a GdaDataModel can be done using two methods:
      <itemizedlist>
	<listitem><para>in a random access way using 
	    <link linkend="gda-data-model-get-value-at">gda_data_model_get_value_at ()</link> if the data model
	    supports random access</para></listitem>
	<listitem><para>using a data model iterator as a cursor: a 
	    <link linkend="GdaDataModelIter">GdaDataModelIter</link> object which is always supported by any data model.
	</para></listitem>
      </itemizedlist>
    </para>
    <sect2 id="data-model-table-access">
      <title>Example using random access</title>
      <para>
        The following example displays the contents of a GdaDataModel using random access:
        <programlisting>
void
show_data_model (GdaDataModel *dm)
{
          gint row_id;
          gint column_id;
          const GValue *value;
          
          for (column_id = 0; column_id &lt; gda_data_model_get_n_columns (dm);
               column_id++)
          g_print("%s\t", gda_data_model_get_column_title (dm, column_id));
          g_print("\n");
          
          for (row_id = 0; row_id &lt; gda_data_model_get_n_rows (dm); row_id++) {
                    for (column_id = 0; column_id &lt; gda_data_model_get_n_columns (dm);
                         column_id++) {
                              char *str;

                              value = gda_data_model_get_value_at (dm, column_id, row_id);
                              str = gda_value_stringify (value);
                              g_print ("%s\t", str);
                              g_free (str);
                    }
                    g_print("\n");
          }
}
        </programlisting>
      </para>
    </sect2>

    <sect2 id="data-model-row-access">
      <title>Example using an iterator</title>
      <para>
        <programlisting>
void
show_data_model (GdaDataModel *dm)
{
          gint column_id;
          GdaParameter *param;
          const GValue *value;
          GdaDataModelIter *iter;
          
          for (column_id = 0; column_id &lt; gda_data_model_get_n_columns (dm);
               column_id++)
          g_print("%s\t", gda_data_model_get_column_title (dm, column_id));
          g_print("\n");
          
          iter = gda_data_model_create_iter (dm);
          gda_data_model_iter_move_next (iter);
          while (gda_data_model_iter_is_valid (iter)) {
                    GSList *list;
                    for (list = GDA_PARAMETER_LIST (iter)-&gt;parameters; list; list = list-&gt;next) {
                              char *str;

                              value = gda_parameter_get_value (GDA_PARAMETER (list-&gt;data));
                              str = gda_value_stringify (value);
                              g_print ("%s\t", str);
                              g_free (str);
                    }
                    g_print("\n");
          }
          g_object_unref (iter);
}
        </programlisting>
      </para>
    </sect2>

    <sect2 id="data-model-free">
      <title>Freeing data models</title>
      <para>
        When you finish using data models you must free it, using <link linkend="g-object-unref">g_object_unref ()</link>.
      </para>
    </sect2>
  </sect1>

  <sect1 id="transactions">
    <title>Managing transactions</title>
    <para>
      On any connection (as a GdaConnection object), if the database provider used by the connection supports it, 
      transactions may be started, committed or rolledback, or savepoints added, removed or rolledback. 
      These operations can be performed using Libgda's API (such as 
      <link linkend="gda-connection-begin-transaction">gda_connection_begin_transaction</link>()), 
      or directly using some SQL on the connection (usually a "BEGIN;" command). 
    </para>
    <para>
      The <emphasis>transaction status</emphasis> of any connection can be obtained using 
      <link linkend="gda-connection-get-transaction-status">gda_connection_get_transaction_status ()</link>, which
      returns a <link linkend="GdaTransactionStatus">GdaTransactionStatus's</link> object which can be interrogated. That
      object also makes it easy to keep up with the evolutions of the transaction status of the connection.
    </para>
  </sect1>

  <sect1 id="managing-errors">
    <title>Managing connection's events and errors</title>
    <para>
      Each <link linkend="GdaConnection">GdaConnection</link> object maintains a list of events which occurred on the
      connection. Each event is stored as a <link linkend="GdaConnectionEvent">GdaConnectionEvent</link> object, and the
      possible event <emphasis>kinds</emphasis> are:
      <itemizedlist>
	<listitem><para>GDA_CONNECTION_EVENT_NOTICE: for notices which are general purpose information</para></listitem>
	<listitem><para>GDA_CONNECTION_EVENT_WARNING: for warnings</para></listitem>
	<listitem><para>GDA_CONNECTION_EVENT_ERROR: for errors</para></listitem>
	<listitem><para>GDA_CONNECTION_EVENT_COMMAND: for SQL stataments which have been executed</para></listitem>
      </itemizedlist>
    </para>
    <para>
      The list of events for a GdaConnection can be obtained using 
      <link linkend="gda-connection-get-events">gda_connection_get_events()</link>, the list of events can be manually cleared
      anytime using <link linkend="gda-connection-clear-events-list">gda_connection_clear_events_list ()</link>, and
      is automatically cleared before any command or query is executed.
    </para>
  </sect1>
  <sect1 id="main_example">
    <title>Full example</title>
    <para>
      The following example is a complete program which creates a <filename>example_db.db</filename>
      SQLite database in the current
      directory, creates a "products" table,add a few rows to it, and then displays its contents. The example uses
      an SQLite database as it does not require any server setup and can thus be run as-is. 
      That example can be found in the <filename>samples/SimpleExample/example.c</filename>.
    </para>
    <para>
      To compile it, run:
      <programlisting>
cc -o example example.c `pkg-config --cflags --libs libgda-3.0`
      </programlisting>
    </para>
    <para>
      The code is:
      <programlisting>
&fullexample;
      </programlisting>
    </para>
  </sect1>

  <sect1 id="ddl_example">
    <title>DDL example</title>
    <para>
      Ths following example illustrates (in a very simple way) how to use the 
      <link linkend="GdaServerOperation">GdaServerOperation</link> object to perform a CREATE TABLE query.
      For more information about how &LIBGDA; handles DDL queries, see <link linkend="DDLIntro">the DDL introduction</link>.
      The following code simply executes the equivalent of "CREATE TABLE products (id int PRIMARY KEY, product_name string NOT NULL);" 
      in a generic way, where the "id" field is the primary key and should be auto incremented (the SQL is generally 
      specific to each DBMS for that last part).
    </para>
    <para>
      For SQLite, the actual executed SQL statement is:
      <programlisting>
	CREATE TABLE products (id integer PRIMARY KEY AUTOINCREMENT, product_name varchar(50) NOT NULL);
      </programlisting>
      whereas for MySQL, the code would be:
      <programlisting>
	CREATE TABLE products (id integer AUTO_INCREMENT PRIMARY KEY, product_name varchar(50) NOT NULL) ENGINE=InnoDB;
      </programlisting>
    </para>
    <para>
      The code is:
      <programlisting><![CDATA[
void
create_table (GdaConnection *cnc)
{
	GError *error = NULL;
	GdaServerProvider *provider;
	GdaServerOperation *op;
	gint i;

	/* create a new GdaServerOperation object */
	provider = gda_connection_get_provider_obj (cnc);
	op = gda_server_provider_create_operation (provider, cnc, GDA_SERVER_OPERATION_CREATE_TABLE, NULL, &error);
	if (!op) {
		g_print ("CREATE TABLE operation is not supported by the provider: %s\n",
			 error && error->message ? error->message : "No detail");
		exit (1);
	}

	/* Set parameter's values */
	/* table name */
	if (!gda_server_operation_set_value_at (op, "products", &error, "/TABLE_DEF_P/TABLE_NAME")) goto on_set_error;
        if (!gda_server_operation_set_value_at (op, "InnoDB", &error, "/TABLE_OPTIONS_P/TABLE_ENGINE")) goto on_set_error;

	/* "id' field */
	i = 0;
	if (!gda_server_operation_set_value_at (op, "id", &error, "/FIELDS_A/@COLUMN_NAME/%d", i)) goto on_set_error;
	if (!gda_server_operation_set_value_at (op, "integer", &error, "/FIELDS_A/@COLUMN_TYPE/%d", i)) goto on_set_error;
	if (!gda_server_operation_set_value_at (op, "TRUE", &error, "/FIELDS_A/@COLUMN_AUTOINC/%d", i)) goto on_set_error;
	if (!gda_server_operation_set_value_at (op, "TRUE", &error, "/FIELDS_A/@COLUMN_PKEY/%d", i)) goto on_set_error;
	
	/* 'product_name' field */
	i++;
	if (!gda_server_operation_set_value_at (op, "product_name", &error, "/FIELDS_A/@COLUMN_NAME/%d", i)) goto on_set_error;
	if (!gda_server_operation_set_value_at (op, "varchar", &error, "/FIELDS_A/@COLUMN_TYPE/%d", i)) goto on_set_error;
	if (!gda_server_operation_set_value_at (op, "50", &error, "/FIELDS_A/@COLUMN_SIZE/%d", i)) goto on_set_error;
	if (!gda_server_operation_set_value_at (op, "TRUE", &error, "/FIELDS_A/@COLUMN_NNUL/%d", i)) goto on_set_error;


	/* Actually execute the operation */
	if (! gda_server_provider_perform_operation (provider, cnc, op, &error)) {
		g_print ("Error executing the operation: %s\n",
			 error && error->message ? error->message : "No detail");
		exit (1);
	}
	g_object_unref (op);
	return;

 on_set_error:
	g_print ("Error setting value in GdaSererOperation: %s\n",
		 error && error->message ? error->message : "No detail");
	exit (1);
}]]>
      </programlisting>
    </para>
  </sect1>

  <sect1 id="other_examples">
    <title>Other examples</title>
    <para>
      There are other sources of examples in &LIBGDA;'s source code:
      <itemizedlist>
	<listitem><para>in the <filename>samples/</filename> directory with complete examples</para></listitem>
	<listitem><para>in the <filename>tools/</filename> directory where &LIBGDA;'s tools exist and are
	    also a good starting point</para></listitem>
      </itemizedlist>
    </para>
  </sect1>
</chapter>
