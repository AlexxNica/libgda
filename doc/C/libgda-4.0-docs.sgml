<?xml version="1.0"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
     "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd" [
<!ENTITY nbsp            " ">
<!ENTITY LIBGDA          "<application>Libgda</application>">
<!ENTITY GNOMEDB         "<application>GNOME-DB</application>">
<!ENTITY igalia          '<emphasis><ulink url="http://www.igalia.com">Igalia, S.L.</ulink></emphasis>'>
<!ENTITY xobas           '<emphasis><ulink url="http://www.xobas.com">Xobas Software</ulink></emphasis>'>
<!ENTITY API             "<acronym>API</acronym>">
<!ENTITY DBMS            "<acronym>DBMS</acronym>">
<!ENTITY DSN             "<acronym>DSN</acronym>">
<!ENTITY ODBC            "<acronym>ODBC</acronym>">
<!ENTITY GDA             "<acronym>GDA</acronym>">
<!ENTITY LDAP            "<acronym>LDAP</acronym>">
<!ENTITY CORBA           "<acronym>CORBA</acronym>">
<!ENTITY IDL             "<acronym>IDL</acronym>">
<!ENTITY ORB             "<acronym>ORB</acronym>">
<!ENTITY SQL             "<acronym>SQL</acronym>">
<!ENTITY RPM             "<acronym>RPM</acronym>">
<!ENTITY XML             "<acronym>XML</acronym>">
<!ENTITY PGSQL           "<application>PostgreSQL</application>">
<!ENTITY MYSQL           "<application>MySQL</application>">
<!ENTITY ORAC            "<application>Oracle</application>">
<!ENTITY INTERB          "<application>Interbase</application>">
<!ENTITY SYBASE          "<application>Sybase</application>">
<!ENTITY MSACC           "<application>MS Access</application>">
<!ENTITY INFOR           "<application>Informix</application>">
<!ENTITY GDASERVERPROVIDER "<link linkend='GdaServerProvider'>GdaServerProvider</link>">
<!ENTITY GDADATAMODEL    "<link linkend='GdaDataModel'>GdaDataModel</link>">
<!ENTITY GDADATAMODELARRAY "<link linkend='GdaDataModelArray'>GdaDataModelArray</link>">
<!ENTITY GDADATAMODELHASH "<link linkend='GdaDataModelHash'>GdaDataModelHash</link>">
<!ENTITY gda-list-server-op "<command>gda-list-server-op-4.0</command>">
<!ENTITY gda-list-config "<command>gda-list-config-4.0</command>">
<!ENTITY gda-sql "<command>gda-sql</command>">
<!ENTITY gda-test-connection "<command>gda-test-connection-4.0</command>">
<!ENTITY fullexample SYSTEM "examples/full_example.c">
<!ENTITY install SYSTEM "installation.xml">
<!ENTITY examples SYSTEM "gettingstarted.xml">
<!ENTITY migration SYSTEM "migration.xml">
<!ENTITY migration2 SYSTEM "migration2.xml">
<!ENTITY data-validation SYSTEM "data_validation.xml">
<!ENTITY data-select SYSTEM "data_select.xml">
<!ENTITY limitations SYSTEM "limitations.xml">
<!ENTITY libgda-GdaCommand SYSTEM "xml/gda-command.xml">
<!ENTITY libgda-config SYSTEM "xml/gda-config.xml">
<!ENTITY libgda-GdaConnection SYSTEM "xml/gda-connection.xml">
<!ENTITY libgda-GdaMutex SYSTEM "xml/gda-mutex.xml">
<!ENTITY libgda-GdaLockable SYSTEM "xml/gda-lockable.xml">
<!ENTITY libgda-GdaRow SYSTEM "xml/gda-row.xml">
<!ENTITY libgda-GdaDataModelArray SYSTEM "xml/gda-data-model-array.xml">
<!ENTITY libgda-GdaDataModelBdb SYSTEM "xml/gda-data-model-bdb.xml">
<!ENTITY libgda-GdaDataModelDir SYSTEM "xml/gda-data-model-dir.xml">
<!ENTITY libgda-GdaDataModel SYSTEM "xml/gda-data-model.xml">
<!ENTITY libgda-GdaDataModelIter SYSTEM "xml/gda-data-model-iter.xml">
<!ENTITY libgda-GdaDataModelImport SYSTEM "xml/gda-data-model-import.xml">
<!ENTITY libgda-GdaDataAccessWrapper SYSTEM "xml/gda-data-access-wrapper.xml">
<!ENTITY libgda-GdaDataProxy SYSTEM "xml/gda-data-proxy.xml">
<!ENTITY libgda-GdaConnection-event SYSTEM "xml/gda-connection-event.xml">
<!ENTITY libgda-GdaColumn SYSTEM "xml/gda-column.xml">
<!ENTITY libgda-init SYSTEM "xml/libgda.xml">
<!ENTITY libgda-log SYSTEM "xml/gda-log.xml">
<!ENTITY libgda-quark-list SYSTEM "xml/gda-quark-list.xml">
<!ENTITY libgda-GdaServerProvider SYSTEM "xml/gda-server-provider.xml">
<!ENTITY libgda-GdaVirtualProvider SYSTEM "xml/gda-virtual-provider.xml">
<!ENTITY libgda-GdaVproviderDataModel SYSTEM "xml/gda-vprovider-data-model.xml">
<!ENTITY libgda-GdaVproviderHub SYSTEM "xml/gda-vprovider-hub.xml">
<!ENTITY libgda-GdaVirtualConnection SYSTEM "xml/gda-virtual-connection.xml">
<!ENTITY libgda-GdaVconnectionDataModel SYSTEM "xml/gda-vconnection-data-model.xml">
<!ENTITY libgda-GdaVconnectionHub SYSTEM "xml/gda-vconnection-hub.xml">
<!ENTITY libgda-GdaServerOperation SYSTEM "xml/gda-server-operation.xml">
<!ENTITY libgda-GdaServerOperationNodes SYSTEM "xml/gda-server-operation-nodes.xml">
<!ENTITY libgda-GdaServerOperationSequences SYSTEM "xml/gda-server-operation-sequences.xml">
<!ENTITY libgda-serverop-intro SYSTEM "server-operation.xml">
<!ENTITY libgda-virtual SYSTEM "virtual.xml">
<!ENTITY libgda-virtual-notice SYSTEM "virtual-notice.xml">
<!ENTITY libgda-xa-transaction SYSTEM "xml/gda-xa-transaction.xml">
<!ENTITY libgda-transaction-status SYSTEM "xml/gda-transaction-status.xml">
<!ENTITY libgda-util SYSTEM "xml/gda-util.xml">
<!ENTITY libgda-GValue SYSTEM "xml/gda-value.xml">
<!ENTITY libgda-GdaConnection SYSTEM "xml/gda-connection.xml">
<!ENTITY GdaStoreMetaType SYSTEM "store-meta-type.xml">
<!ENTITY libgda-GdaDataHandler SYSTEM "xml/gda-data-handler.xml">
<!ENTITY libgda-GdaHandlerString SYSTEM "xml/gda-handler-string.xml">
<!ENTITY libgda-GdaHandlerBoolean SYSTEM "xml/gda-handler-boolean.xml">
<!ENTITY libgda-GdaHandlerTime SYSTEM "xml/gda-handler-time.xml">
<!ENTITY libgda-GdaHandlerNumerical SYSTEM "xml/gda-handler-numerical.xml">
<!ENTITY libgda-GdaHandlerBin SYSTEM "xml/gda-handler-bin.xml">
<!ENTITY libgda-GdaHandlerType SYSTEM "xml/gda-handler-type.xml">
<!ENTITY libgda-GdaBlobOp SYSTEM "xml/gda-blob-op.xml">
<!ENTITY libgda-GdaReportEngine SYSTEM "xml/gda-report-engine.xml">
<!ENTITY libgda-GdaReportDocument SYSTEM "xml/gda-report-document.xml">
<!ENTITY libgda-GdaReportDocbookDocument SYSTEM "xml/gda-report-docbook-document.xml">
<!ENTITY libgda-GdaReportRmlDocument SYSTEM "xml/gda-report-rml-document.xml">
<!ENTITY libgda-GdaHolder SYSTEM "xml/gda-holder.xml">
<!ENTITY libgda-GdaSet SYSTEM "xml/gda-set.xml">
<!ENTITY libgda-GdaStatement SYSTEM "xml/gda-statement.xml">
<!ENTITY libgda-GdaSqlStatement SYSTEM "xml/gda-sql-statement.xml">
<!ENTITY libgda-GdaBatch SYSTEM "xml/gda-batch.xml">
<!ENTITY libgda-GdaSqlParser SYSTEM "xml/gda-sql-parser.xml">
<!ENTITY libgda-GdaMetaStore SYSTEM "xml/gda-meta-store.xml">
<!ENTITY libgda-GdaMetaStruct SYSTEM "xml/gda-meta-struct.xml">
<!ENTITY libgda-GdaDataSelect SYSTEM "xml/gda-data-select.xml">
<!ENTITY libgda-GdaDataSelectPriv SYSTEM "xml/gda-data-select-priv.xml">
<!ENTITY libgda-PStmt SYSTEM "xml/gda-pstmt.xml">
<!ENTITY libgda-Enums SYSTEM "xml/gda-enums.xml">
<!ENTITY libgda-convenient SYSTEM "xml/gda-convenient.xml">
<!ENTITY libgda-GdaDataComparator SYSTEM "xml/gda-data-comparator.xml">
<!ENTITY provider-writing SYSTEM "prov-writing.xml">
<!ENTITY provider-support SYSTEM "xml/provider-support.xml">
<!ENTITY i-s-doc SYSTEM "i_s_doc.xml">
<!ENTITY fdl-appendix SYSTEM "fdl-appendix.sgml">
<!ENTITY howto SYSTEM "howto.xml">
<!ENTITY libgda-TreeIndex SYSTEM "xml/tree_index.sgml">
<!ENTITY GdaSqlManual SYSTEM "gda-sql-manual.xml">
<!ENTITY GdaAttributesManager SYSTEM "xml/gda-attributes-manager.xml">
]>

<book id="index">
  <bookinfo>
    <title>GNOME Data Access 4.0 manual</title>
    <authorgroup>
      <author>
        <firstname>Michael</firstname>
        <surname>Lausch</surname>
        <affiliation>
          <address><email>michael.lausch@1012surf.net</email></address>
        </affiliation>
      </author>
      <author>
        <firstname>Rodrigo</firstname>
        <surname>Moya</surname>
        <affiliation>
          <address><email>rodrigo@gnome-db.org</email></address>
        </affiliation>
      </author>
      <author role="clean up">
	<firstname>Sean</firstname>
	<surname>Allen</surname>
	<affiliation>
	  <address><email>zeroone@worldonline.co.za</email></address>
	</affiliation>
	<contrib>GDP compliance, FDL, added mark-up, English and syntax
        </contrib>
      </author>
      <author>
	<firstname>Xabier</firstname>
	<surname>Rodriguez Calvar</surname>
	<affiliation>
          <orgname>&igalia;</orgname>
	  <address><email>xrcalvar@igalia.com</email></address>
	</affiliation>
	<contrib>How to begin and migration formulae
        </contrib>
      </author>
      <author>
	<firstname>Jose</firstname>
	<surname>Dapena Paz</surname>
	<affiliation>
          <orgname>&igalia;</orgname>
	  <address><email>jdapena@igalia.com</email></address>
	</affiliation>
	<contrib>Some examples
        </contrib>
      </author>
      <author>
        <firstname>Bas</firstname>
        <surname>Driessen</surname>
        <affiliation>
          <orgname>&xobas;</orgname>
          <address><email>bas.driessen@xobas.com</email></address>
        </affiliation>
	<contrib>libgda, gda-postgres, gda-mysql
        </contrib>
      </author>
      <author>
        <firstname>Daniel</firstname>
        <surname>Espinosa Ortiz</surname>
        <affiliation>
          <orgname></orgname>
          <address><email>esodan@gmail.com</email></address>
        </affiliation>
	<contrib>libgda, gda-postgres, gda-mysql
        </contrib>
      </author>
      <author>
        <firstname>Vivien</firstname>
        <surname>Malerba</surname>
        <affiliation>
          <address><email>malerba@gnome-db.org</email></address>
        </affiliation>
	<contrib>Current maintainer
        </contrib>
      </author>
    </authorgroup>
    <date>January 2009</date>
    <copyright>
      <year>1999 - 2009</year>
      <holder>The GNOME Foundation</holder>
    </copyright>
    <abstract>
      <para>
        GNOME Data Access (&GDA;) is an architecture whose 
        purpose is to provide universal access to many different kinds and
        types of data sources. This goes from traditional relational database
        systems, to any imaginable kind of data source such as a mail server,
        a &LDAP; directory...
      </para>
      <para>
        This universality is obtained through the use of
        an easily extensible plug-in system as the mechanism for
	communication between the different components in the architecture.
      </para>
    </abstract>
    <legalnotice id="legalnotice">
      <para>
        Permission is granted to copy, distribute and/or modify this document
        under the terms of the <link linkend="fdl"><citetitle>GNU
        Free Documentation License</citetitle></link>, Version 1.1 or any later
        version published by the Free Software Foundation with no Invariant
        Sections, no Front-Cover Texts, and no Back-Cover Texts.  A copy of the
        license can be found in <link linkend="fdl">the appendix</link>.
      </para>
      <para>
        Many of the names used by companies to distinguish their products and
        services are claimed as trademarks. Where those names appear in any
        GNOME documentation, and those trademarks are made aware to the members
        of the GNOME Documentation Project, the names have been printed in caps
        or initial caps.
      </para>
    </legalnotice>
  </bookinfo>

  <part id="part_begin">
    <title>Getting started</title>
    <chapter id="introduction">
      <title>Introduction</title>
      <para>
	&ODBC; and &SQL; are established standards. The problem is, that &ODBC;
	doesn't specify the wire protocol and for some databases no &ODBC; driver
	exists. You might use <acronym>RPC</acronym>, <acronym>TCP/IP</acronym>,
	or shared memory and signals to pass the request from the client to the
	server. So you have to use the database specific &ODBC; library. This 
	library might not be available for the <acronym>CPU</acronym> or 
	operating system on which the client is running. 
      </para>
      <para>
	&SQL; itself is also not standardised enough, so that source
	compatibility can not be assured for all database servers. And for some
	sort of servers, &SQL; is not even feasible (think about &LDAP;).
      </para>
      <para>
	&GDA; (GNOME Data Access) tries to tackle the &ODBC; problem and help you with the &SQL;
	problem. It's a sort of middleware (or can be blown up to be a middleware
	layer) to access different data sources. It offers a high level view of
	data sources and has some places where you can plug in low level access
	to the database for special tasks.
      </para>
      <para>
	It offers a wrapper around the database internals, thus making it easier
	for programmers to make use of all the power provided by many RDBMS without
	even knowing about it. It comes along with a library, for both
	clients and servers, as a C implementation of this architecture. This level of
	abstraction would make possible to, at a later time, change all the
	internals without having to modify applications using the libraries.
      </para>
      <para>
	Along with these libraries (and associated header files and language 
	bindings for development), &LIBGDA; includes several tools and utilities
	to help you with the task of developing applications based on &LIBGDA;,
	as well as for automating some database-related tasks.
      </para>
      <para>
	&LIBGDA; is implemented for <systemitem class="osname">UNIX
	</systemitem>-like operating systems (including <systemitem 
							   class="osname">Linux</systemitem>), and does not depend on other 
	libraries apart from  <systemitem class="resource">libxml2</systemitem> and 
	<systemitem class="resource">Glib</systemitem>, which makes it a very
	lightweight system also ideal for applications to be run on 
	hardware-limited systems.
      </para>
    </chapter>

    <chapter id="features">
      <title>Features</title>
      <para>
	This section presents the main features of the 4.0 version of Libgda.
      </para>
      <para>
	Libgda is a low-level database abstraction layer built on top of each database C API. In terms of abstraction, 
	Libgda offers the following top features:
	<itemizedlist>
          <listitem>
            <para>Open a connection to any database which type is supported using either a defined data source (defined per
	      user or system wide) or directly providing connection parameters. Several connections can be opened at the
	      same time.</para>
          </listitem>
          <listitem>
            <para>Run any SQL query against an opened connection; furthermore any SQL query can be extended to define query parameters
	      using an easy to understand notation. If the SQL query was a SELECT statement, then an array of data is
	      returned (as a <classname>GdaDataModel</classname> object), and otherwise the number of rows affected
	      by the query is returned. For very large data sets, it is possible to specify that the returned array
	      of data should be based on a cursor to avoid loading it into memory .</para>
          </listitem>
          <listitem>
            <para>Perform most of the data definition queries (including database creation) for the database types which support
	      it using a key/value mechanism.</para>
          </listitem>
          <listitem>
            <para>Create, maintain and extend a view of the database's structure and meta data including the definitions of
	      the tables, constraints, data types, .... It is defined as closely as possible to the information schema SQL
	    standard (ISO/IEC 9075); see the <link linkend="gda-dict">Dictionary - metadata</link> section 
	      for more information.</para>
          </listitem>
          <listitem>
            <para>Easy to extend data models for custom requirements</para>
          </listitem>
          <listitem>
            <para>Support for binary data and for BLOBs in a transparent way, see the <link linkend="libgda-Gda-Value">Gda value section</link></para>
          </listitem>
          <listitem>
            <para>Support for detailed parameters in SQL queries, see the <link linkend="GdaSqlParser">GdaSqlParser</link> object</para>
          </listitem>
	  <listitem>
            <para>Support for virtual connections, see the <link linkend="virtual_connection">Virtual connections chapter</link></para>
          </listitem>
	  <listitem>
            <para>Partially thread-safe, see <link linkend="threads">the threads limitation</link> for
	      more details</para>
          </listitem>
	</itemizedlist>
      </para>
      <para>
	The database types which can be accessed at the time of writing are the following ones:
	<itemizedlist>
          <listitem>
            <para>Access (.MDB files): uses the <ulink url="http://mdbtools.sourceforge.net/">MDB Tools</ulink> library
	      to access the .MDB files, and is limited to getting information about tables and running very simple SELECT
	      queries;</para>
          </listitem>
          <listitem>
            <para>Firebird: compiles, needs testing;</para>
          </listitem>
          <listitem>
            <para>IBM DB2: compiles but is not useable, work in progress;</para>
          </listitem>
          <listitem>
            <para>Microsoft SQL Server and Sybase using the <ulink url="http://www.freetds.org/">FreeTDS</ulink> library:
	      compiles, needs testing;</para>
          </listitem>
          <listitem>
            <para>mSQL: compiles, needs testing;</para>
          </listitem>
          <listitem>
            <para>MySQL: fully functionnal;</para>
          </listitem>
          <listitem>
            <para>ODBC: seems to work correctly, needs testing;</para>
          </listitem>
          <listitem>
            <para>Oracle: work is progress, useable;</para>
          </listitem>
          <listitem>
            <para>PostgreSQL: fully functionnal;</para>
          </listitem>
          <listitem>
            <para>SQLite: fully functionnal;</para>
          </listitem>
          <listitem>
            <para>Sybase: compiles, needs testing;</para>
          </listitem>
          <listitem>
            <para>Xbase: compiles, needs testing</para>
          </listitem>
	</itemizedlist>
      </para>
    </chapter>
    
    <chapter id="architecture">
      <title>Architecture</title>
      <para>
	&LIBGDA; is composed of three independent layers. The lower level is
	covered by the &GDA; providers, which are plug-ins whose task is
	to map the <acronym>RDBMS</acronym>-specific &API; to the &GDA; model.
	That is, they are objects implementing the &GDA; interfaces.
      </para>
      <para>
	Then, in a middle layer, are the client libraries: an easy-to-use and
	full featured library which offers access to all the architecture,
	also including several utility functions to help you on the development
	of applications based on &GDA;. This library, although targeted to client
	applications, also includes a set of helper classes and functions to help
	in the addition of new providers to the &LIBGDA; architecture.
      </para>
      <para>
	Finally, at the upper level sit all the client applications provided in
	the suite, as well as any application that may make use of the client
	libraries.
      </para>
      <mediaobject>
	<imageobject role="html">
          <imagedata fileref="architecture.png" format="PNG"/>
	</imageobject>
	<textobject>
          <phrase>Typical &LIBGDA; application's architecture</phrase>
	</textobject>
	<caption>
          <para>
	    Architecture of an application connected to 4 databases of 3 different types.
          </para>
	</caption>
      </mediaobject>
    </chapter>

    &install;
    &examples;
    &migration;
    &migration2;
    &limitations;
  </part>  
  <part id="part_libgda_api">
    <title>Client API reference</title>
    <para>
      The following sections describe the API available for &GDA; applications.
    </para>

    &howto;
    <chapter>
      <title>Object Hierarchy</title>
      &libgda-TreeIndex;
    </chapter>

    <chapter id="init_config">
      <title>Initialization and configuration</title>
      <para>Configuration examples are given in <link linkend="installation-configuring">this introduction section</link></para>
      &libgda-init;
      &libgda-config;
      <sect1 id="libgda_env_variables">
	<title>Configuring &LIBGDA; with environment variables</title>
	<para>Some functional aspects of &LIBGDA; can be configured using environment variables which are
	  listed here:
	  <itemizedlist>
	    <listitem>
              <para>GDA_CONNECTION_EVENTS_SHOW: if set, then lists the type of events which must be displayed on STDOUT
		(event types are NOTICE, COMMAND, WARNING, ERROR, the variable can contain a list of types separated by
		colons, commas or spaces)</para>
	    </listitem>
	    <listitem>
              <para>GDA_CONNECTION_COMMANDS_SHOW: if set, then all the commands issued to a server will be
		displayed on STDOUT</para>
	    </listitem>
	    <listitem>
              <para>GDA_PROVIDERS_ROOT_DIR: if set, must point to the directory where the providers files are (providers
	      files are shared libraries)</para>
	    </listitem>
	    <listitem>
              <para>LIBGDA_NO_THREADS: if set, then multi threading will be disabled (see the 
		<link linkend="threads">section about multi threading</link> for more information about
		&LIBGDA; threads' support).</para>
	    </listitem>
	    <listitem>
              <para>GDA_DATA_MODEL_DUMP_TITLE: if set, then <link linkend="gda-data-model-dump">gda_data_model_dump()</link>
	      will also output the name of the data model as its first line</para>
	    </listitem>
	    <listitem>
              <para>GDA_DATA_MODEL_DUMP_ROW_NUMBERS: if set, then 
		<link linkend="gda-data-model-dump">gda_data_model_dump()</link> will prepend a column containing row
		numbers</para>
	    </listitem>
	    <listitem>
              <para>GDA_DATA_MODEL_NULL_AS_EMPTY: if set, then 
		<link linkend="gda-data-model-dump">gda_data_model_dump()</link> will show an empty ("") string
		for NULL values, instead of the "NULL" string</para>
	    </listitem>
	    <listitem>
              <para>GDA_DATA_MODEL_DUMP_ATTRIBUTES: if set, then 
		<link linkend="gda-data-model-dump">gda_data_model_dump()</link> will also include a description of
	      the data model's attributes</para>
	    </listitem>
	  </itemizedlist>
	</para>
      </sect1>
    </chapter>

    <chapter id="connection">
      <title>Connections &amp; commands</title>
      <para>
	The &LIBGDA; library allows several connections to databases to be opened at once.
	Once a connection (manipulated through the <link linkend="GdaConnection">GdaConnection</link> object)
	has been created and is opened, it is able to proceed <link linkend="GdaStatement">GdaStatement</link> statements.
      </para>
      <para>
	Each <link linkend="GdaStatement">GdaStatement</link> can only hold one SQL statement (such as SELECT, INSERT,
	CREATE TABLE, BEGIN, etc); statements can be grouped together into  <link linkend="GdaBAtch">GdaBatch</link> batches
	objects. There are two ways for creating a <link linkend="GdaStatement">GdaStatement</link> object:
	<itemizedlist>
	   <listitem>
	     <para>
	       either by passing an SQL string to a parser (a <link linkend="GdaSqlParser">GdaSqlParser</link>).
	     </para>
	     <para>
	       &LIBGDA; unifies the way variables (also known as "placeholders") are defined (because each database type
	       has its own syntax for doing so); consult the <link linkend="GdaSqlParser">GdaSqlParser</link> object's
	       documentation for a description of this syntax.
	     </para>
	   </listitem>
	   <listitem><para>by building it from its structure: see the 
	       <link linkend="GdaSqlStatement">GdaSqlStatement</link> for reference.
	       However keep in mind that this API is meant to be used primarily by database
	       provider's implementations and for &LIBGDA;'s internal usage. A more user friendly
	       API will be added in the future.
	   </para></listitem>
	</itemizedlist>
      </para>
      <para>
	As each database implements its own SQL variant (all variants more or less close to the SQL92 or SQL99 standards), the
	&LIBGDA; library allows one to use either a generic SQL parser, or a parser provided by each database adaptator (database
	provider), through the <link linkend="gda-connection-create-parser">gda_connection_create_parser()</link> method.
      </para>
      <para>
	The following schema illustrates how a statement is executed:
	<mediaobject>
	  <imageobject role="html">
	    <imagedata fileref="howto-exec.png" format="PNG"/>
	  </imageobject>
	  <textobject>
	    <phrase>Statement execution illustrated</phrase>
	  </textobject>
	</mediaobject>
      </para>
      &libgda-convenient;
      &libgda-GdaConnection;
      &libgda-GdaSqlParser;
      &libgda-GdaStatement;
      &libgda-GdaBatch;
      &libgda-GdaHolder;
      &libgda-GdaSet;
      &libgda-GdaConnection-event;
      &libgda-transaction-status;
      &libgda-xa-transaction;
      &GdaStoreMetaType;
    </chapter>

    <chapter id="virtual_connection">
      <title>Virtual connections</title>
      &libgda-virtual;
      &libgda-GdaVirtualProvider;
      &libgda-GdaVproviderDataModel;
      &libgda-GdaVproviderHub;
      &libgda-GdaVirtualConnection;
      &libgda-GdaVconnectionDataModel;
      &libgda-GdaVconnectionHub;
    </chapter>

    <chapter id="data_models">
      <title>Data handling</title>
      <para>
	&LIBGDA; being a data oriented library, data handling is a central point of the library:
	<itemizedlist>
	  <listitem>
            <para>individual values are encapsulated within a <link linkend="GValue">GValue</link> 
	      container (from GLIB)</para>
	  </listitem>
	  <listitem>
            <para>value holders which are each a specification for a value: a type, a name, a description,
	      a default value, etc. Value holders are encapsulated within a 
	      <link linkend="GdaHolder">GdaHolder</link> container object.</para>
	    <para>
	      Note that it is possible to set a hint to make a value holder have its value constrained
	      by the values contained in a column of a <link linkend="GdaDataModel">GdaDataModel</link>.
	    </para>
	  </listitem>
	  <listitem>
            <para>lists of value holders which are encapsulated within a 
	      <link linkend="GdaSet">GdaSet</link> container object.</para>
	    <para>
	      The GdaSet object also makes some computations to group value holders which are
	      constrained by values in the same GdaDataModel (it makes it easy to use value holders
	      which are not really independant).
	    </para>
	  </listitem>
	  <listitem>
            <para>arrays of values organized in rows and columns. All the data in the same 
	      column have the same type, and all the data in each row have the same semantic meaning. 
	      &LIBGDA; uses the <link linkend="GdaDataModel">GdaDataModel</link> 
	      objects to actually hold the data (note that this is actually an interface which has 
	      sevaral implementations depending on the real data organization in the data model).</para>
	    <para>Note that depending on the real implementation, access to the data can be random or
	    done using an iterator, and that the data model can be read-only or modifiable.</para>
	  </listitem>
	  <listitem>
            <para>The <link linkend="GdaDataModelIter">GdaDataModelIter</link> object is used to 
	      iterate through the rows of a <link linkend="GdaDataModel">GdaDataModel</link>.</para>
	  </listitem>
	</itemizedlist>
      </para>
      &libgda-GValue;
      &data-validation;
      &data-select;
      &libgda-GdaBlobOp;
      &libgda-GdaDataModel;
      &libgda-GdaDataSelect;
      &libgda-GdaColumn;
      &libgda-GdaDataModelIter;
      &libgda-GdaDataModelImport;
      &libgda-GdaDataAccessWrapper;
      &libgda-GdaDataModelArray;
      &libgda-GdaRow;
      &libgda-GdaDataModelBdb;
      &libgda-GdaDataModelDir;
      &libgda-GdaDataProxy;
      &libgda-GdaDataComparator;
    </chapter>

    <chapter id="data_conv">
      <title>Data conversions</title>
      <para>
	A single piece of data can have several representations
	depending on its usage: a string representation, an SQL representation and of course a 
	<link linkend="GValue">GValue</link> representation. Conversions from one representation to
	the other is DBMS dependant as each database can have its own SQL representation rules. The
	<link linkend="GdaDataHandler">GdaDataHandler</link> object's purpose is to do all these conversions in a easy way.
	Except when mentionned otherwise, conversions take into account locale settings and DBMS specifications.
      </para>
      <para>
	To convert a data, one needs to instanciate a new data handler from one of the many classes which implement this interface, or
	better to get a pointer to a <link linkend="GdaDataHandler">GdaDataHandler</link> object (no
	need to unref() it after usage, data handler objects are stateless), and so to obtain such a pointer one can:
	<itemizedlist>
	  <listitem>
	    <para>Use the <link linkend="gda-get-default-handler">gda_get_default_handler()</link>: the returned data handler
	      is a generic one and should not be used to convert data to use with any connection, but only to have
	      a portable way of storing and loading data in a locale independant fashion (for serialization purposes).</para>
	  </listitem>
	  <listitem>
	    <para>Ask a <link linkend="GdaServerProvider">GdaServerProvider</link> object for one using the
	    <link linkend="gda-server-provider-get-data-handler-g-type">gda_server_provider_get_data_handler_g_type()</link>
	    or <link linkend="gda-server-provider-get-data-handler-dbms">gda_server_provider_get_data_handler_dbms()</link>:
	    the returned data handler can then safely be used to convert any data to be used with any connection
	    relying on the GdaServerProvider object.</para>
	  </listitem>
	</itemizedlist>
      </para>
      &libgda-GdaDataHandler;
      &libgda-GdaHandlerString;
      &libgda-GdaHandlerBoolean;
      &libgda-GdaHandlerTime;
      &libgda-GdaHandlerNumerical;
      &libgda-GdaHandlerBin;
      &libgda-GdaHandlerType;
    </chapter>

    <chapter id="gda-dict">
      <title>Dictionary - metadata</title>
      <para>
	Each connection has a dictionary object (a <link linkend="GdaMetaStore">GdaMetaStore</link>) attached to it. That
	dictionary is either created by the connection when it needs it, or is created and set by the user 
	(to be able to re-use a dictionary), using the <link linkend="GdaConnection--meta-store">"meta-store"</link> 
	property of the <link linkend="GdaConnection">GdaConnection</link> object.
      </para>
      <para>
	Previous versions of &LIBGDA; used an XML file based dictionary which had several drawbacks (see the 
	<link linkend="migration-2-dict">migrations notes</link> for more details), now a database is used: the default
	is to use an SQLite base database which is easily transportable and can be used in the same way the previous
	XML based dictionary was used.
      </para>
      <para>
	Each <link linkend="GdaMetaStore">GdaMetaStore</link> requires (and creates) a dictionary 
	structure which is a set of tables implementing an 
	"information schema" schema (as defined in the information schema SQL standard (ISO/IEC 9075), and adapted). 
	The user is then free to add more database objects (tables and views) to contain his own data in the dictionary,
	using the <link linkend="gda-meta-store-schema-add-custom-object">gda_meta_store_schema_add_custom_object()</link>
	method.
      </para>
      <para>
	Extracting information can be done using SQL statements on the dictionary database (a special 
	<link linkend="gda_meta_store_extract">gda_meta_store_extract()</link> method), or, for information about
	the database structure, using the <link linkend="GdaMetaStruct">GdaMetaStruct</link> object which creates
	an easy to use in-memory representation	of some database objects.
      </para>

      <sect1 id="GdaMetaStoreSetup">
	<title>Setup</title>
	<para>
	  Each <link linkend="GdaMetaStore">GdaMetaStore</link> object internally uses a (private)
	  <link linkend="GdaConnection">GdaConnection</link> connection object. The following figure illustrates
	  the situation when the programmer uses a <link linkend="GdaConnection">GdaConnection</link> connection object
	  when the meta data is stored in a different database (usually an SQLite file):
	  <mediaobject>
	    <imageobject role="html">
              <imagedata fileref="MetaStore1.png" format="PNG"/>
	    </imageobject>
	    <textobject>
              <phrase></phrase>
	    </textobject>
	    <caption>
              <para>
		GdaConnection object and its associated GdaMetaStore using its own database to store the
		meta data.
              </para>
	    </caption>
	  </mediaobject>
	</para>
	<para>
	  From a programmer's point of view, the following code example shows how to get a connection's associated
	  meta store object, without being able to specify anything about the meta store's private connection (in which
	  case the private connection will be an in-memory database destroyed when the meta store object is destroyed):
	  <programlisting>
GdaConnection *cnc;
GdaMetaStore *store;

cnc = gda_connection_open_from_dsn (...);
g_object_get (G_OBJECT (cnc), "meta-store", &amp;store, NULL);

[... use the meta store object ...]
g_object_unref (store);
	  </programlisting>
	</para>
	<para>
	  One can also specify the meta store object to be used by a connection, as in:
	  <programlisting>
GdaConnection *cnc;
GdaMetaStore *store;

cnc = gda_connection_open_from_dsn (...);
store = gda_meta_store_new_with_file ("/path/to/file");
/* or */
store = gda_meta_store_new ("PostgreSQL://DB_NAME=meta_db");

g_object_set (G_OBJECT (cnc), "meta-store", store, NULL);
g_object_unref (store);
	  </programlisting>
	</para>

	<para>
	  The meta data can also be stored in the same database as the connection the meta data is for. In this case
	  (and if the associated database provider supports it), the dictionary structure can be placed into a spearate
	  schema. The next figure illustrates this situation:
	  <mediaobject>
	    <imageobject role="html">
              <imagedata fileref="MetaStore2.png" format="PNG"/>
	    </imageobject>
	    <textobject>
              <phrase></phrase>
	    </textobject>
	    <caption>
              <para>
		GdaConnection object and its associated GdaMetaStore using the same database.
              </para>
	    </caption>
	  </mediaobject>
	</para>
	<para>
	  From a programmer's point of view, the following code example shows how to do the setup:
	  <programlisting>
GdaConnection *cnc;
GdaMetaStore *store;

cnc = gda_connection_open_from_dsn (...);
store = GDA_META_STORE (g_object_new (GDA_TYPE_META_STORE, "cnc", cnc, NULL));
g_object_set (G_OBJECT (cnc), "meta-store", store, NULL);
g_object_unref (store);
	  </programlisting>
	</para>
      </sect1>

      <sect1 id="GdaMetaStoreCustomData">
	<title>Adding custom data</title>
	<para>
	  This section explains how to add application specific data (custom data) to a 
	  <link linked="GdaMetaStore">GdaMetaStore</link> object.
	</para>
	<para>
	  Applications of course don't need to use that feature to manage their own data but it makes sense to use
	  it if the application also uses metadata to avoid having to manipulate several files for the same "task".
	</para>
	<sect3>
	  <title>Storing data as (key, value) pairs</title>
	  <para>
	    In very simple cases, when the data to store is made of named values, the easiest way is to use the
	    <link linkend="gda-meta-store-set-attribute-value">gda_meta_store_set_attribute_value()</link> and
	    <link linkend="gda-meta-store-get-attribute-value">gda_meta_store_get_attribute_value()</link> methods
	    where the values are stored and retreived as strings.
	  </para>
	</sect3>
	<sect3>
	  <title>Declaring the new custom database objects</title>
	  <para>
	    The <link linkend="gda-meta-store-schema-add-custom-object">gda_meta_store_schema_add_custom_object()</link>
	    method canbe used to add custom objects, which have to be described using an XML syntax. The advantages
	    of using that method are:
	    <itemizedlist>
	      <listitem><para>The object's definition will be the same for all database types</para></listitem>
	      <listitem><para>If another object with a different definition already exists, then a error is returned</para></listitem>
	    </itemizedlist>
	  </para>
	</sect3>
	<sect3>
	  <title>Adding and removing data</title>
	  <para>
	    For the moment adding and removing data must be done as for any other database connection,
	    using the <link linkend="GdaMetaStore's">GdaMetaStore</link>'s internal connection obtained 
	    with <link linkend="gda_meta_store_get_internal_connection">gda_meta_store_get_internal_connection()</link>.
	  </para>
	</sect3>
	<sect3>
	  <title>Removing custom database objects</title>
	  <para>
	    For the moment adding and removing data must be done as for any other database connection,
	    using the <link linkend="GdaMetaStore's">GdaMetaStore</link>'s internal connection obtained 
	    with <link linkend="gda_meta_store_get_internal_connection">gda_meta_store_get_internal_connection()</link>.
	  </para>
	</sect3>
	<para>
	</para>
      </sect1>

      <sect1 id="information_schema">
	<title>Database structure</title>
	<para>
	  &LIBGDA; imposes its own structure (based on objects such as tables and views which name starts with an 
	  underscore '_') for the meta data database associated to a <link linkend="GdaMetaStore">GdaMetaStore</link> object,
	  but a user can also add its own tables or other database objects. The following diagram shows the tables 
	  defined by &LIBGDA; for its internal needs:
	  <mediaobject>
	    <imageobject role="html">
	      <imagedata fileref="information_schema.png" format="PNG"/>
	    </imageobject>
	    <textobject>
	      <phrase>Dictionary's tables and views initially defined by &LIBGDA;</phrase>
	    </textobject>
	  </mediaobject>
	</para>

	<sect2 id="information_schema:data_types">
	  <title>Data types</title>
	  <para>
	    Data types (as reported for example for table's columns) can be one of the following kinds:
	    <itemizedlist>
	      <listitem><para>Builtin data types offered by the database engine such as integers, varchar, etc. Those data 
		  types are all listed in the 
		  <link linkend="is:_builtin_data_types">"_builtin_data_types"</link> table.</para></listitem>
	      <listitem><para>Database domains: domains are data types with optional constraints 
		  (restrictions on the allowed set of values). A domain refers to the base data type from which it is defined
		  (that base data type can also be an array). Those data types are all listed in the
		  <link linkend="is:_domains">"_domains"</link> table.</para></listitem>
	      <listitem><para>User defined data types (which are not part of the SQL standard but featured by some databases
		  such as PostgreSQL) are simple or composed data types based on existing data types 
		  (which may also be arrays). Those data types are all listed in the
		  <link linkend="is:_udt">"_udt"</link> table.</para></listitem>
	      <listitem><para>Arrays of any of the previous data types (one or more dimensions). Arrays are not per-se data
		  types, but rather refer to an existing data type. Arrays are described in the 
		  <link linkend="is:_element_types">"_element_types"</link> table.</para></listitem>
	    </itemizedlist>
	    Note that the data types which are built in, domains or user defined are all also listed in the
	    <link linkend="is:_all_types">"_all_types"</link> view as a convenience.
	  </para>
	  <para>
	    The impact of that data types' hierarchy is that everytime a data type is referenced (from a table's column
	    definition for example), there will be two attributes for the data type: one named 
	    <parameter>data_type</parameter> which, if not NULL, refers to a data type listed in the
	    <link linkend="is:_all_types">"_all_types"</link> view (thus a built in, domain or user defined data type), and
	    one named <parameter>array_spec</parameter> which, if not NULL, refers to an array, listed in the
	    <link linkend="is:_element_types">"_element_types"</link> table. Any of these attributes can be NULL, but they
	    should never be both NULL at the same time.
	  </para>
	  <para>
	    Single dimension arrays will have the <parameter>data_type</parameter> attribute referencing a data type in the
	    <link linkend="is:_all_types">"_all_types"</link> view (and the <parameter>array_spec</parameter> attribute
	    set to NULL), whereas multi dimension arrays will have the <parameter>data_type</parameter> attribute set to NULL
	    and the <parameter>array_spec</parameter> attribute referencing another tow in the 
	    <link linkend="is:_element_types">"_element_types"</link> table.
	  </para>
	  <para>
	    The following diagram illustrates the data types representation and how ther are refered from table's columns,
	    domains, and other database objects which refer to a data type:
	    <mediaobject>
	      <imageobject role="html">
		<imagedata fileref="i_s_data_types.png" format="PNG"/>
	      </imageobject>
	      <textobject>
		<phrase>Dictioanry's tables and views initially defined by &LIBGDA;</phrase>
	      </textobject>
	    </mediaobject>
	  </para>
	</sect2>

	<sect2 id="information_schema:sql_identifiers">
	  <title>SQL identifiers</title>
	  <para>
	    SQL identifiers (database object's names) are case insitive, but it is still possible to specify
	    that an SQL identifier be case sensitive by putting it between double quotes. &LIBGDA; has chosen
	    the convention that case insitive SQL identifiers should all be in lower case in the meta data's tables
	    whereas case sensitive SQL identifiers can contain some upper case ASCII characters.
	  </para>
	  <para>
	    This convention must be respected by database providers' implementations or the 
	    <link linkend="GdaMetaStruct">GdaMetaStruct</link> object and the associated features
	    (such as keyword completion) will not work properly.
	  </para>
	</sect2>

	<sect2>
	  <title>Short and full names</title>
	  <para>
	    Database objects will have two associated names, the <emphasis>short name</emphasis> and the
	    <emphasis>long name</emphasis>, the difference being the same as machine in a local network being called
	    either by its machine name such as "moon" or by its fully qualified domain name such as "moon.my.network", but
	    applied to databases and schemas. The full name corresponding to the 
	    &lt;database&gt;.&lt;schema&gt;.&lt;object_name&gt; or &lt;schema&gt;.&lt;object_name&gt;, and the
	    short name corresponding to the &lt;object_name&gt;.
	  </para>
	  <para>
	    Short name and full name differ when the schema being accessed is not the schema containing the named
	    database object, in which case the full name must be used. Some database specific features may also alter
	    the differences between the short name and the sull name such as the "search_path" variable for PostgreSQL
	    (which is to a unix PATH variable but for schemas).
	  </para>
	</sect2>

	<!-- tables and views documentation -->
	&i-s-doc;
      </sect1>

      &libgda-GdaMetaStore;
      &libgda-GdaMetaStruct;
    </chapter>

    <chapter>
      <title>Data definition (DDL) queries</title>
      &libgda-serverop-intro;
      &libgda-GdaServerOperation;
      &libgda-GdaServerOperationNodes;
      &libgda-GdaServerOperationSequences;
    </chapter>

    <chapter id="misc">
      <title>Miscellaneous</title>
      &libgda-util;
      &libgda-log;
      &libgda-GdaMutex;
      &libgda-GdaLockable;
      &GdaAttributesManager;
    </chapter>
  </part>

  <part id="part_tools">
    <title>&GDA; Tools</title>
    <chapter id="libgda-tools-introduction">
      <title>Introduction</title>
      <para>
	&LIBGDA; offers several command line tools to help disgnose and resolve problems. All the
	provided tools can be run with the "--help" command line argument to give an online help
	and description. Also, some environment variables can be set to control the output for some of
	the tools, see <link linkend="libgda_env_variables">&LIBGDA;'s environment variables</link> section
	for more details.
      </para>
    </chapter>

    <chapter id="libgda-sql">
      <title>&gda-sql;</title>
      <para>
	The &gda-sql; tool is an interactive command line tool to run SQL commands and work
	with dictionaries. This tool has got several options, use the <option>--help</option> option
	to list them all, or consult the man page (<command>man gda-sql</command>)
      </para>
      <para>
	For example to list the installed providers, do:
	<programlisting>
[prompt]> gda-sql-4.0 -L
Provider    | Description                       | DSN parameters     | File                                          
------------+-----------------------------------+--------------------+-----------------------------------------------
SQLite      | Provider for SQLite databases     | DB_NAME,           | /usr/lib/libgda-4.0/providers/libgda-sqlite.so  
                                                  DB_DIR,                                                            
                                                  LOAD_GDA_FUNCTIONS                                                       
Berkeley-DB | Provider for Berkeley databases   | FILE,              | /usr/lib/libgda-4.0/providers/libgda-bdb.so 
                                                  DATABASE                                                                
[...]
	</programlisting>
	To list the configured data sources (DSN):
	<programlisting>
[prompt]> gda-sql-4.0 -l
DSN      | Provider   | Description  | Connection string      | Username
---------+------------+--------------+------------------------+---------
Sales    | PostgreSQL | Sales        | DB_NAME=sales          |
[...]
	</programlisting>
	To run an interractive session, just specify a DSN or a connection string using
	the &quot;&lt;provider&gt;://&lt;connection string&gt;&quot; 
	format (such as for example "Firebird://DATABASE=/path/to/dbfile.fdb"), or set
	the GDA_SQL_CNC environment variable to contain that string, and run the command without any argument, 
	for example:
	<programlisting>
[prompt]> gda-sql-4.0 PostgreSQL://DB_NAME=sales
Welcome to the GDA SQL console, version 3.99.3

Type: .copyright to show usage and distribution terms
      .? for help with internal commands
      .q (or CTRL-D) to quit
      (the '.' can be replaced by a '\')
      or any query terminated by a semicolon

Opening connection 'c0' for: PostgreSQL://DB_NAME=sales
        Getting database schema information, this may take some time... Done.
c0>
	</programlisting>
	Note that the "c0" is the prompt for the first opened connection.
      </para>
      <para>
	Several connections can be opened at once (with only one "active" at any given time), by specifying
	all of them on the command line, or by using the <option>\c</option>
	and <option>\close</option> to manage (open, change, close) the connections; the prompt contains
	the name of the current connection used. The following example opens two connections, one for the "pgsales"
	DSN, and one for the "PostgreSQL://DB_NAME=sales" connection string, and shows the usage of the ".c" command
	to list the opened connections:
	<programlisting>
[prompt]> gda-sql-4.0 pgsales PostgreSQL://DB_NAME=sales
Welcome to the GDA SQL console, version 3.99.3

Type: .copyright to show usage and distribution terms
      .? for help with internal commands
      .q (or CTRL-D) to quit
      (the '.' can be replaced by a '\')
      or any query terminated by a semicolon

Opening connection 'pgsales' for: pgsales
Opening connection 'c1' for: PostgreSQL://DB_NAME=sales
        Getting database schema information, this may take some time... Done.
c1> .c
             List of opened connections
Name    | Provider   | DSN or connection string | Username
--------+------------+--------------------------+---------
pgsales | PostgreSQL | pgsales                  |         
c1      | PostgreSQL | DB_NAME=sales            |         
(2 rows)

c1>
	</programlisting>
      </para>
      <para>
	Here is another sample session showing how to use variables in statements:
	<programlisting><![CDATA[
[prompt]> gda-sql-4.0 -p SQLite -c "DB_DIR=.;DB_NAME=sales_test"
Welcome to the GDA SQL console, version 3.1.2

Type: \copyright to show usage and distribution terms
      \? for help with internal commands
      \q (or CTRL-D) to quit
      or any query terminated by a semicolon

c0> select * from customers;
id | name            | default_served_by | country | city
---+-----------------+-------------------+---------+-----
 2 | Ed Lamton       |                 4 | SP      | MDR 
 3 | Lew Bonito      |                 1 | FR      | TLS 
 4 | Mark Lawrencep  |              NULL | SP      | MDR 
 9 | Greg Popoff     |                 2 | SP      | MDR 
10 | Vladimir Zirkov |                 4 | NULL    | NULL
c0> \set the_id 9
c0> select * from customers where id= ##the_id;
id | name        | default_served_by | country | city
---+-------------+-------------------+---------+-----
 9 | Greg Popoff |                 2 | SP      | MDR 
c0> ]]>
	</programlisting>
      </para>
      <para>
	See the <link linkend="gda-sql">Gda SQL console tool manual section</link> for more information.
      </para>
    </chapter>

    <chapter id="libgda-tools-list-config">
      <title>&gda-list-config;</title>
      <para>
	The &gda-list-config; tool simply lists all the declared data sources, and all the installed
	providers, giving some other usefull information as well for each. This tool has no option.
      </para>
      <para>
	An example output will be:
	<programlisting>
[prompt]> gda-list-config-4.0
=== Installed providers ===
Provider: SQLite
Description: Provider for SQLite databases
Location: /usr/lib/libgda-4.0/providers/libgda-sqlite.so
Data source's parameters (Name / Type / Description):
  DB_NAME / gchararray / Database name
  DB_DIR / gchararray / Directory
  LOAD_GDA_FUNCTIONS / gboolean / Extra functions

Provider: Berkeley-DB
Description: Provider for Berkeley databases
Location: /usr/lib/libgda-4.0/providers/libgda-bdb.so
Data source's parameters (Name / Type / Description):
  FILE / gchararray / Database file
  DATABASE / gchararray / Database name

[...]

=== Declared data sources ===
Data source: Sales
  Key 'DSN' = 'DB_NAME=sales'
  Key 'Description' = 'Sales'
  Key 'Password' = ''
  Key 'Provider' = 'PostgreSQL'
  Key 'Username' = ''

[...]
	</programlisting>
      </para>
    </chapter>

    <chapter id="libgda-tools-test-connection">
      <title>&gda-test-connection;</title>
      <para>
	This tool is a 'ping' like tool to test connectivity to databases. Connections can either
	be declared as DSN, or described in the command line.
      </para>
    </chapter>

    <chapter id="libgda-list-server-op">
      <title>&gda-list-server-op;</title>
      <para>
	The &gda-list-server-op; tool lists available DDL operations for one or all of the installed
	providers. For each type of operation (and each provider), the named parameters are also displayed.
	See the <link linkend="DDLIntro">General words about DDL queries</link> for more information
	about possible operations and usage. This tool has got several options, use the <option>--help</option> option
	to list them all.
      </para>
      <para>
	For example listing all the possible operations (for all the providers) is:
	<programlisting>
[prompt]> gda-list-server-op-4.0 -l
Using XML descriptions in /usr/share/libgda-4.0
Existing operation types:
CREATE_DB
DROP_DB
CREATE_TABLE
DROP_TABLE
RENAME_TABLE
ADD_COLUMN
DROP_COLUMN
CREATE_INDEX
DROP_INDEX
	</programlisting>
	Listing all the operations supported by the SQLite provider (notice that the SQLite provider does not support the
	DROP_COLUMN operation as SQLite does not support it):
	<programlisting>
[prompt]> gda-list-server-op-4.0 -l -p SQLite
Using XML descriptions in /usr/share/libgda-4.0
For provider SQLite
Existing operation types for provider 'SQLite':
CREATE_DB
DROP_DB
CREATE_TABLE
DROP_TABLE
RENAME_TABLE
ADD_COLUMN
CREATE_INDEX
DROP_INDEX
	</programlisting>
	Listing all the possible parameters for the MySQL provider and for the DROP_COLUMN operation:
	<programlisting><![CDATA[
[prompt]> gda-list-server-op-4.0 -o DROP_COLUMN -p MySQL
Using XML descriptions in /usr/share/libgda-4.0
For provider MySQL
Description for type: DROP_COLUMN
<?xml version="1.0"?>
<server_op>
  <path id="/COLUMN_DESC_P" node_type="PARAMLIST" name="Column's description"/>
  <path id="/COLUMN_DESC_P/TABLE_NAME" node_type="PARAMETER" gdatype="gchararray" name="Table" descr="Table's name"/>
  <path id="/COLUMN_DESC_P/COLUMN_NAME" node_type="PARAMETER" gdatype="gchararray" name="Field name"/>
</server_op>]]>
	</programlisting>
	Listing all the possible parameters for the all the installed providers and for the DROP_COLUMN operation:
	<programlisting><![CDATA[
[prompt]> gda-list-server-op-4.0 -o DROP_COLUMN 
Using XML descriptions in /usr/share/libgda-4.0
Description for type: DROP_COLUMN
<?xml version="1.0"?>
<server_op>
  <path id="/COLUMN_DESC_P" node_type="PARAMLIST">
    <prov prov_name="mysql" name="Column's description"/>
    <prov prov_name="postgres" name="Column's description"/>
  </path>
  <path id="/COLUMN_DESC_P/TABLE_NAME" node_type="PARAMETER" gdatype="gchararray">
    <prov prov_name="mysql" name="Table" descr="Table's name"/>
    <prov prov_name="postgres" name="Table" descr="Table's name"/>
  </path>
  <path id="/COLUMN_DESC_P/COLUMN_NAME" node_type="PARAMETER" gdatype="gchararray">
    <prov prov_name="mysql" name="Field name"/>
    <prov prov_name="postgres" name="Field name"/>
  </path>
  <path id="/COLUMN_DESC_P/REFERENCED_ACTION" node_type="PARAMETER" gdatype="gchararray">
    <prov prov_name="postgres" name="References" descr="What to do with references on the column to delete"/>
  </path>
</server_op>]]>
	</programlisting>
      </para>
    </chapter>
  </part>

  <part id="part_libgda-reports">
    <title>Reports</title>
    <chapter id="libgda-reports-introduction">
      <title>Introduction</title>
      <para>
	&LIBGDA;'s report feature has been reworked and is only offers it <link linkend="GdaReportEngine">report engine object</link>, 
	a low level general usage engine to generate reports in the XML format.
      </para>
      <para>
	Working on any XML file allows the report engine to work with all the existing post-processors which will actually
	generate the final file(s) in HTML, PDF or other; for example:
	<itemizedlist>
	  <listitem><para>SVG can be processed by a web browser or further edited using inkscape for example</para></listitem>
	  <listitem><para>DocBook can then be converted to HTML of PDF 
	      (see <ulink url="http://wiki.docbook.org/topic/DocBookXsltPublishingModelDiagram">this docbook Wiki page</ulink>)
	  </para></listitem>
	  <listitem><para>RML files (Report Markup Language), see <ulink url="http://www.reportlab.org/">ReportLab</ulink> or
	      <ulink url="http://en.openreport.org/index.py/static/page/trml2pdf">OpenReport</ulink>) can be converted to HTML or PDF)
	  </para></listitem>
	  <listitem><para>some other XML dialects can also be used such as 
	      <ulink url="http://sourceforge.net/projects/rlib/">RLib</ulink>, 
	      <ulink url="http://www.treshna.com/papyrus/">Papyrus</ulink>, and other.
	  </para></listitem>
	</itemizedlist>
      </para>
      <para>
	To make it easier to use RML or Docbook XML dialects, &LIBGDA; has the 
	<link linkend="GdaReportDocbookDocument">GdaReportDocbookDocument</link> and 
	<link linkend="GdaReportRmlDocument">GdaReportRmlDocument</link> which both offer high level of
	features when dealing with those XML dialects.
      </para>
      <para>
	From a programmer's point of view, the following code example shows how to convert the "report-spec.xml" file
	to a "report.xml" report:
	<programlisting>
GdaConnection *cnc;
GdaReportEngine *eng
xmlDocPtr doc;
GError *error = NULL;

cnc = gda_connection_open_from_dsn (...);
eng = gda_report_engine_new_from_file ("report-spec.xml");
gda_report_engine_declare_object (eng, G_OBJECT (cnc), "main_cnc");

doc = gda_report_engine_run_as_doc (eng, &amp;error);
if (!doc) {
    /* ERROR */
}
else {
    xmlSaveFile ("report.xml", doc);
    xmlFreeDoc (doc);
}
g_object_unref (eng);
	</programlisting>
	For example the XML "report-spec.xml" file could be:
	<programlisting><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<article>
  <articleinfo>
    <title>Customers report example</title>
    <abstract>
      <!-- Use the "abstract" parameter which is supposed to be defined using gda_report_engine_declare_object() -->
      <para><gda_report_param_value param_name="abstract"/></para>
    </abstract>
  </articleinfo>

  <!-- 
       Start a new section, with the "customers" SELECT query, which is supposed to be defined using 
       gda_report_engine_declare_object() 

       Any <gda_report_iter> node will repeat its contents as many times as there are rows in the
       data model returned by the "customers" SELECT query.
    -->
  <gda_report_section query_name="customers" cnc_name="main_cnc">
    <sect1>
      <!-- Will be replaced by: <title>List of customers (5)</title> if there are 5 rows for example -->
      <title>List of customers (<gda_report_param_value param_name="customers|?nrows"/>)</title>

      <!-- List all the customer's names -->
      <ul>
	<gda_report_iter>
	  <li><gda_report_param_value param_name="customers|@name"/></li>
	</gda_report_iter>
      </ul>
    </sect1>
  </gda_report_section>
</article>]]></programlisting>
	For a more detailled example, have a look at the <filename class="directory">samples/Report</filename> of &LIBGDA;'s
	sources.
	</para>
    </chapter>
    <chapter>
      <title>API reference</title>
      &libgda-GdaReportEngine;
      &libgda-GdaReportDocument;
      &libgda-GdaReportDocbookDocument;
      &libgda-GdaReportRmlDocument;
    </chapter>
  </part>

  <part id="part_libgda-xslt">
    <title>XSLT extension</title>
    <chapter id="libgda-xslt-introduction">
      <title>Introduction</title>
      <para>
	&LIBGDA; features an XSLT extension...
      </para>
    </chapter>
    <chapter id="libgda-xslt-api">
      <title>API reference</title>
      <para>TODO</para>
    </chapter>
    <chapter>
      <title>Example</title>
      <para>TODO</para>
    </chapter>
  </part>

  <part id="gda-sql">
    <title>Gda SQL console's user manual</title>
    &GdaSqlManual;
  </part>

  <part id="part_providers">
    <title>Databases providers for developers</title>
      <para>
	For each database engine, &LIBGDA; requires an object which maps &LIBGDA;'s API
	to the native API offered by that database engine. That object, a <emphasis>database provider</emphasis> 
	needs to inherit <link linkend="GdaServerProvider">GdaServerProvider</link> and implement its
	virtual methods.
      </para>
      <para>
	Database provider objects are generally instanciated once by the &LIBGDA; framework and can be used several
	times to open and work on connections to several databases of the same type.
      </para>
      <para>
	Since &LIBGDA; itself is developed in the C language, and that most
	providers are also implemented in that language, the &LIBGDA; library
	itself contains a set of helper classes and functions to guide you
	in the addition of a new provider to the GDA framework. Two reference implementations
	are provided in the <filename class="directory">providers/skel-implementation</filename>
	directory of &LIBGDA;'s sources:
	<itemizedlist>
	  <listitem><para>in <filename class="directory">providers/skel-implementation/capi</filename>: a skeleton
	    implementation from scratch for a database accessed through a C API, where all the methods to implement are partially
	    coded</para></listitem>
	  <listitem><para>in <filename class="directory">providers/skel-implementation/models</filename>: a skeleton
	    implementation to write a provider for sources which are not databases (which do not implement any SQL) such
	    as the Berkeley DB provider (a BDB database is a key/value collection) or the MDB (MS Access files) provider.
	    This kind of provider "export" tables which are in fact data models.</para></listitem>
      </itemizedlist>
    </para>
    <para>
      The helper objects and functions to write database providers are documented in the 
      <link linkend="psupport">Providers' support API</link> section.
    </para>


    <chapter id="psupport">
      <title>Providers' support API</title>
      &libgda-GdaServerProvider;
      &libgda-GdaDataSelectPriv;
      &libgda-PStmt;
      &libgda-quark-list;
      &provider-support;
    </chapter>
    &provider-writing;
  </part>

  <part id="part_index">
    <title>Appendix</title>
    &fdl-appendix;
    <index>
      <title>Index</title>
    </index>
  </part>
</book>

