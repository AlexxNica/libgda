<sect2>
  <title>General words about queries</title>
  <para>
    Every DML (Data Manipulation Language) query is described as a single <link linkend="GdaQuery">GdaQuery</link>
    object. The object is then specialized to represent all the possible DML queries:
    <itemizedlist>
      <listitem>
        <para>selection queries: of type GDA_QUERY_TYPE_SELECT</para>
      </listitem>
      <listitem>
        <para>modification queries: of type GDA_QUERY_TYPE_INSERT, GDA_QUERY_TYPE_UPDATE and GDA_QUERY_TYPE_DELETE</para>
      </listitem>
      <listitem>
        <para>aggregation queries: of type GDA_QUERY_TYPE_UNION, GDA_QUERY_TYPE_INTERSECT and GDA_QUERY_TYPE_EXCEPT</para>
      </listitem>
      <listitem>
        <para>any other SQL queries: when the DML query cannot be interpreted as one of the types above, its type is set to 
	  GDA_QUERY_TYPE_NON_PARSED_SQL;  This type indicates that query parsing has failed, either because the SQL statement is wrong 
	  or because it uses unsupported SQL constructions and/or keywords.</para>
      </listitem>
    </itemizedlist>
  </para>
  <para>
    The <link linkend="GdaQuery">GdaQuery</link> object adapts itself to the query it represents: if possible it will contain lists of objects 
    (such as fields, joins, etc) and will make them available to the outside world, and if not (when the query type is GDA_QUERY_TYPE_NON_PARSED_SQL)
    it will simply store a string representing the SQL text to execute. The limit between the two is that this object cannot "understand" very complex
    SQL queries or "proprietary" SQL dialects.
  </para>
  <para>
    Each <link linkend="GdaQuery">GdaQuery</link> object can be built either using the provided API to add individual elements, or
    using the <link linkend="gda-query-set-sql-text">gda_query_set_sql_text()</link> method. Using the API presents the advantage
    of being faster since it spares the SQL parsing time and using the gda_query_set_sql_text() method is slower but will work for any
    SQL (for non "understood" SQL, it will set its type to GDA_QUERY_TYPE_NON_PARSED_SQL). See <link linkend="GdaQueryConstrExamples">this
      section</link> for some examples.
  </para>
  <para>
    The <link linkend="GdaQuery">GdaQuery</link> object implements the <link linkend="GdaEntity">GdaEntity</link> interface, 
    and all its fields, which inherit from <link linkend="GdaQueryField">GdaQueryField</link>, implement the 
    <link linkend="GdaEntityField">GdaEntityField</link> interface.
  </para>
  <sect3>
    <title>General structure of a query</title>
    <para>
      A query is composed of the following (each object is owned by the query object):
      <itemizedlist>
	<listitem>
          <para>A list of targets (as <link linkend="GdaQueryTarget">GdaQueryTarget</link> objects). Each GdaQueryTarget object
            represents an entity (= an object which implements the <link linkend="GdaEntity">GdaEntity</link>
            interface, for example a database table or another query);
            A single entity can be represented
            several times by different GdaQueryTarget objects (for instance for queries which involve a same table multiple times).
          </para>
          <para>If a target that represents a <link linkend="GdaQuery">GdaQuery</link> object is added to a query,
            then the represented query MUST BE a sub-query of the query the target is added to. In the following query:
            <quote>"SELECT firstname, lastname FROM (SELECT * FROM person WHERE type=1)"</quote>, 
            there is one GdaQueryTarget object
            which represents the <quote>"SELECT * FROM person WHERE type=1"</quote>
            sub-query and that sub-query must be declared
            as a sub-query of the complete query.</para>
	</listitem>
	<listitem>
          <para>A list of joins (as <link linkend="GdaQueryJoin">GdaQueryJoin</link> objects) between the targets. This is
            useful only for selection queries where a GdaQueryJoin represents a SQL join between entities to avoid
            cross products. FIXME: In the example above there is one GdaQueryJoin object to represent the "INNER JOIN" between
            the two GdaQueryTarget objects representing the "person" and "title" entities.</para>
	</listitem>
	<listitem>
          <para>A list of fields (as <link linkend="GdaQueryField">GdaQueryField</link> objects). There are
            several different types of GdaQueryField objects to represent the different uses of fields in data manipulation queries:
	    a field can represent a table.field field, or a function. The different types of query fields are: 
            </para>
          <itemizedlist>
            <listitem><link linkend="GdaQueryFieldAll">GdaQueryFieldAll</link></listitem>
            <listitem><link linkend="GdaQueryFieldField">GdaQueryFieldField</link></listitem>
            <listitem><link linkend="GdaQueryFieldFunc">GdaQueryFieldFunc</link></listitem>
            <listitem><link linkend="GdaQueryFieldAgg">GdaQueryFieldAgg</link></listitem>
            <listitem><link linkend="GdaQueryFieldValue">GdaQueryFieldValue</link></listitem>
          </itemizedlist>
          <para>Query fields can be either visible or invisible (in which case they are only there to be used by other query
            fields, but they do not participate directly in the query). For instance in the <quote>SELECT count (id) FROM mytable</quote>,
	  the query is composed of a GdaQueryTarget for the "mytable" table, of a GdaQueryField for the "count()" function, and
	  of a last GdaQueryField for the "id" table field. </para>
          <para>Some types of query fields have a "value_provider" property which can point to another query field.
            In this case, when the query is executed, the query field which is pointed at is used to provide a value. This is
            particularly the case of modification queries: in a query such as 
            <quote>"INSERT INTO persons (firstname, lastname) VALUES ('name1', 'name2')"</quote>,
            the query fields "firstname" and "lastname"
            have their "value_provider" property pointing to the GdaQueryFieldValue query fields with the values "name1" and
            "name2", respectively.</para>
	</listitem>
	<listitem>
          <para>A list of sub-queries (also as <link linkend="GdaQuery">GdaQuery</link> objects).</para>
	</listitem>
	<listitem>
          <para>A condition on the application of the query (as a <link linkend="GdaQueryCondition">GdaQueryCondition</link>
            object). A condition object can contain several sub-conditions.</para>
	</listitem>
	<listitem>
          <para>Other attributes describing the grouping and ordering.</para>
	</listitem>
      </itemizedlist>
    </para>
    <para>
      The following sections describe the requirements for the construction of each type of query.
      Note that these requirements are only really tested when the query is rendered into an executable statement,
      when errors may be returned.
    </para>
  </sect3>



  <sect3>
    <title>Graphical conventions to represent queries</title>
    <para>
      The <link linkend="GdaGraphviz">GdaGraphviz</link> object can produce .dot files out of a <link linkend="GdaQuery">GdaQuery</link>
      object, which can the processed using the GraphViz tool. 
      This tool produced the internal representations of the queries in this documentation.
    </para>
    <para>
      As an example, the following query <quote>SELECT t1.id, t1.name, t2.name, t3.country, t3.city FROM customers AS t1  INNER JOIN salesrep AS t2  ON (t1.default_served_by=t2.id) LEFT JOIN locations AS t3  ON (t1.country=t3.country AND t1.city=t3.city) WHERE t1.id=12</quote>
      has the internal structure as represented in the following figure.
    </para>
    <mediaobject>
      <imageobject role="fo">
	<imagedata fileref="query01.svg" format="SVG"/>
      </imageobject>
      <imageobject role="html">
	<imagedata fileref="query01.png" format="PNG"/>
      </imageobject>
      <textobject>
	<phrase>Sample SELECT query</phrase>
      </textobject>
      <caption>
	<para>
	  Internal structure of the "SELECT t1.id, t1.name, t2.name, t3.country, t3.city FROM customers AS t1  INNER JOIN salesrep AS t2  ON (t1.default_served_by=t2.id) LEFT JOIN locations AS t3  ON (t1.country=t3.country AND t1.city=t3.city) WHERE t1.id=12" query.
	</para>
      </caption>
    </mediaobject>
    <para>
      Here is how to read the diagram:
      <itemizedlist>
	<listitem>
          <para>Each <link linkend="GdaQueryTarget">GdaQueryTarget</link> object is represented by an orange box (here "customers", "salesrep" and "locations").</para>
	</listitem>
	<listitem>
          <para>Each <link linkend="GdaQueryJoin">GdaQueryJoin</link> object is represented by an arc between the GdaQueryTarget objects it links. Here
            there is one join between "customers" and "salesrep" (INNER join), and one between "customers" and "locations" (LEFT
            join, note the empty circle on the side of the target where NULL values can be part of the join).</para>
	</listitem>
	<listitem>
          <para>Each <link linkend="GdaQueryField">GdaQueryField</link> object is represented by a blue box devided into two rows: the top one
            is the name of the field, and the bottom one is devided into 4 boxes that, in order from left to right, display the
            real type of field ("Field" fo a GdaQueryFieldField, "Value" for a GdaQueryFieldValue, etc), the field visibility (a "V" appears),
            if the field is internal (marked with a "I") and if the field is a query parameter (a "P").</para>
          <para>Also, each blue box representing a GdaQueryFieldField object has an arc to the GdaQueryTarget to which it belongs.
          </para>
	</listitem>
	<listitem>
          <para>The <link linkend="GdaQueryCondition">GdaQueryCondition</link> object, if present, is represented by a yellow box labeled with the
            SQL representation of the condition, and with arcs to all the GdaQueryField objects it uses.
          </para>
	</listitem>
      </itemizedlist>
    </para>
  </sect3>





  <sect3>
    <title>Query Parameters</title>
    <para>
      Any query can require some parameters to be given values before they can be executed. For example, in
      a query like <quote>SELECT name FROM person WHERE age = &lt;value&gt;</quote> (please note that this syntax is for illustration
      purpose only and is not recognised by the &LIBGDA;'s parser, see the section about the SQL queries for more information) "&lt;value&gt;"
      is a parameter whose value must be provided
      before the query can be executed. A parameter can only be represented in a query by a 
      <link linkend="GdaQueryFieldValue">GdaQueryFieldValue</link> query field. A <link linkend="GdaParameter">GdaParameter</link> object
      provides a value for the parameter to the query.
    </para>
    <para>
      A query QU1 can specify that a given parameter QU1:QF1 has its value restricted to the values from a field in another "SELECT" query (QU2:QF1). 
      In this case the
      <link linkend="GdaQueryFieldValue">GdaQueryFieldValue</link> which is a parameter (QU1:QF1) has its "value_prov" property set to the QU2:QF1 field. 
      The QU2 query can be managed by the QU1 query (using
      <link linkend="gda-query-add-param-source">gda_query_add_param_source()</link> and similar methods).
    </para>
    <para>
      The raw list of parameters required to run a query is returned by the 
      <link linkend="gda-query-get-parameters">gda_query_get_parameters()</link> method.
      However, it is usually better to use a <link linkend="GdaParameterList">GdaParameterList</link>
      object which stores the parameters, and organises them in a convenient way. The function that returns a
      GdaParameterList object is <link linkend="gda-query-get-parameter-list">gda_query_get_parameter_list()</link>.
    </para>
  </sect3>
  <sect3>
    <title>Structural requirements for each type of query</title>
    <sect4>
      <title>Selection queries</title>
      <para>
	A selection query can have all the possible structural elements, with the following restrictions:
	<itemizedlist>
	  <listitem>
            <para>All the sub-queries must also be selection queries.</para>
	  </listitem>
	</itemizedlist>
      </para>
    </sect4>
    <sect4>
      <title>Modification queries</title>
      <para>
	Modification queries have the following structural restrictions:
	<itemizedlist>
	  <listitem>
            <para>There must be one and only one target object which represents the entity to be
              modified. Also the represented entity must be modifiable (e.g. it must not be another query
              or a database view).</para>
	  </listitem>
	  <listitem>
            <para>There cannot be any join.</para>
	  </listitem>
	  <listitem>
            <para>All the visible query fields must be <link linkend="GdaQueryFieldField">GdaQueryFieldField</link> fields.</para>
	  </listitem>
	  <listitem>
            <para>If the query is an insertion query, there must be at most one sub-query, and it
              must be a selection query.  The insertion query will be interpreted as "INSERT INTO
              table SELECT ...". As a consequence, the sub-query must render the same number of fields as the
              query itself.</para>
            <para>If there is no sub-query, then all the fields which are value providers MUST be 
              <link linkend="GdaQueryFieldValue">GdaQueryFieldValue</link> fields.</para>
            <para>Insertion queries can't have any associated condition.</para>
	  </listitem>
	  <listitem>
            <para>If the query is a deletion query, then there can't be any visible field at all.  Hidden field
              may exist as part of a condition.</para>
	  </listitem>
	  <listitem>
            <para>If the query is an update query, then all the fields which are value providers MUST NOT be
              <link linkend="GdaQueryFieldAll">GdaQueryFieldAll</link> fields.</para>
	  </listitem>
	</itemizedlist>
      </para>
    </sect4>
    <sect4>
      <title>Aggregation queries</title>
      <para>
	Aggregation queries have the following structural restrictions:
	<itemizedlist>
	  <listitem>
            <para>There cannot be any target or join.</para>
	  </listitem>
	  <listitem>
            <para>There cannot be any condition.</para>
	  </listitem>
	  <listitem>
            <para>All the sub-queries must be selection queries and have the same number of selected fields. Also
              for EXCEPT queries, there can be only two sub-queries.</para>
	  </listitem>
	</itemizedlist>
      </para>
    </sect4>
  </sect3>
  <sect3 ID="SQL_queries">
    <title>SQL queries</title>
    <para>
      Since it is sometimes easier to define a query using an SQL statement, a <link linkend="GdaQuery">GdaQuery</link>
      object can be constructed from any SQL
      1992 statement, using the <link linkend="gda-query-set-sql-text">gda_query_set_sql_text()</link> method. The SQL string passed as an
      argument must be a single SQL statement, not several statements separated by a colon.
    </para>
    <para>
      To define variables in the SQL statement, just add a parameter definition (type, name, description,...) in C-style comments
      right after the value which must be a parameter, such as in the following SQL where the value "10" is in fact a parameter
      names var01 of type integer (the default value for the parameter will be 10):
      <programlisting>
	SELECT 10 /* name:var01 type:integer */, id FROM customers
      </programlisting>
      To avoid specifying a value altogether (the parameter will not have any default value), replace the "10" with "##" as:
      <programlisting>
	SELECT ## /* name:var01 type:integer */, id FROM customers
      </programlisting>
    </para>
    <para>
      So, in the first case when the query is executed, the real executed SQL statement will be 
      <programlisting>
      "SELECT 10, t1.id FROM customers AS t1"
      </programlisting>
      if the "10" value has not been replaced by another value.  A <link linkend="GdaParameter">GdaParameter</link> object 
      (obtained through a <link linkend="GdaParameterList">GdaParameterList</link> object) can replace the "10" 
      value with another value. See the 
      <link linkend="gda-query-get-parameters">gda_query_get_parameters()</link> and
      <link linkend="gda-query-get-parameter-list">gda_query_get_parameter_list()</link> methods for more information.
      In the second case, if no value has been specified by a <link linkend="GdaParameter">GdaParameter</link>, then the query
      will be:
      <programlisting>
      "SELECT NULL, t1.id FROM customers AS t1"
      </programlisting>
    </para>
    <para>
      The available parameter specification attributes are:
      <itemizedlist>
	<listitem><para>"name:" fixes the value's name</para></listitem>
	<listitem><para>"descr:" fixes the value's description</para></listitem>
	<listitem><para>"type:" fixes the value's <link linkend="GType">GType</link> or 
	    <link linkend="GdaDictType">GdaDictType</link>
	    </para></listitem>
	<listitem><para>"isparam:" tells if value is a variable (a parameter) or not (example: "isparam:FALSE").  
	    The default is that it is a parameter.</para></listitem>
	<listitem><para>"nullok:" tells if value may be NULL (example: "nullok:FALSE")</para></listitem>
      </itemizedlist>
    </para>
    <para>
      Note that each attribute can contain more than one word if the attribute value is enclosed in single or double quotes, such
      as:
      <programlisting>
	SELECT ## /* name:"This is quite a long name" type:integer */, id FROM customers
	SELECT ## /* name:'This is quite a long name' type:integer */, id FROM customers
      </programlisting>
    </para>
    <para>Currently, type inference is not reliably supported, so the use of the "type:" tag is strongly encouraged.</para>
  </sect3>



  <sect3 id="GdaQueryConstrExamples">
    <title>Examples of GdaQuery object constructions </title>
    <para>
      <itemizedlist>
	<listitem>
	  <para>A very simple SELECT query named "Select1":
	    <programlisting>SELECT t1.id, t1.name FROM customers AS t1</programlisting>
	    <mediaobject>
	      <imageobject role="fo">
		<imagedata fileref="query02.svg" format="SVG"/>
	      </imageobject>
	      <imageobject role="html">
		<imagedata fileref="query02.png" format="PNG"/>
	      </imageobject>
	    </mediaobject>
	  </para>
	</listitem>
	<listitem>
	  <para>A very simple INSERT query named "Insert1" -- note the dotted arrows (for example from the "name" field to the "(john)" value field)
	    which means that the "name" field will be assigned the contents of the "(john)" value field (namely the "value_provider" property
	    of the "name" field is set to the "(john)" value field); note as well that the "(john)" and "(10)" value fields are hidden (no 'V' 
	    displayed):
	    <programlisting>INSERT INTO customers (id, name) VALUES (10, 'john')</programlisting>
	    <mediaobject>
	      <imageobject role="fo">
		<imagedata fileref="query03.svg" format="SVG"/>
	      </imageobject>
	      <imageobject role="html">
		<imagedata fileref="query03.png" format="PNG"/>
	      </imageobject>
	    </mediaobject>
	  </para>
	</listitem>
	<listitem>
	  <para>A very simple DELETE query named "Delete1" -- note the condition object shown in the yellow box (which is the WHERE condition) and
	    the 'P' in the (not shown) "Person Id" value field which denotes that the value field is a parameter (the parameter name and type are 
	    not shown); also note that all the query fields are hidden:
	    <programlisting>DELETE FROM customers WHERE id=## /*type:gint name:"Person Id"*/</programlisting>
	    <mediaobject>
	      <imageobject role="fo">
		<imagedata fileref="query04.svg" format="SVG"/>
	      </imageobject>
	      <imageobject role="html">
		<imagedata fileref="query04.png" format="PNG"/>
	      </imageobject>
	    </mediaobject>
	  </para>
	</listitem>
	<listitem>
	  <para>A very simple UPDATE query named "Update1" -- note the condition object shown in the yellow box (which is the WHERE condition);
	    also note first that all the query fields are hidden except for the "name" field which is the table field updated and second that
	    the value for the update is assigned to the "name" field using a dotted arrow (see the INSERT example for more information):
	    <programlisting>UPDATE customers SET name='Joe' WHERE id=10</programlisting>
	    <mediaobject>
	      <imageobject role="fo">
		<imagedata fileref="query05.svg" format="SVG"/>
	      </imageobject>
	      <imageobject role="html">
		<imagedata fileref="query05.png" format="PNG"/>
	      </imageobject>
	    </mediaobject>
	  </para>
	</listitem>
	<listitem>
	  <para>A more complex query named "Complex" which uses a sub-query as a target entity:
	    <programlisting>SELECT t1.f2 FROM (SELECT t1.id AS f1, t1.name AS f2 FROM customers AS t1 ) AS t1 WHERE t1.f1=2</programlisting>
	    <mediaobject>
	      <imageobject role="fo">
		<imagedata fileref="query06.svg" format="SVG"/>
	      </imageobject>
	      <imageobject role="html">
		<imagedata fileref="query06.png" format="PNG"/>
	      </imageobject>
	    </mediaobject>
	  </para>
	</listitem>
      </itemizedlist>
    </para>
  </sect3>
</sect2>
