<chapter id="limitations">
  <title>Limitations</title>

  <sect1 id="limitations_mysql"><title>For MySQL</title>
    <para>
      The following limitations apply to MySQL databases accessed via Libgda:
    </para>
    <sect2><title>gda_server_provider_get_last_insert_id()</title>
      <para>The gda_server_provider_get_last_insert_id() function returns the value generated for an AUTO_INCREMENT
	column by the previous INSERT or UPDATE statement. Use this function after you have performed an INSERT statement
	into a table that contains an AUTO_INCREMENT field. For more information, see the MySQL documentation for the
	mysql_insert_id() function.</para>
    </sect2>
  </sect1>

  <sect1 id="limitations_oracle"><title>For Oracle</title>
    <para>
      The following limitations apply to Oracle databases accessed via Libgda:
      <itemizedlist>
	<listitem><para>At the moment tables' fields shema information retreival is very slow, so as a work around, use a dictionary
	to store the database schema and do incremental updates on modified/created tables.</para></listitem>
      </itemizedlist>
    </para>

    <sect2><title>gda_server_provider_get_last_insert_id()</title>
      <para>The gda_server_provider_get_last_insert_id() function is not implemented.</para>
    </sect2>
  </sect1>

  <sect1 id="limitations_postgres"><title>For PostgreSQL</title>
    <para>
      The following limitations apply to PostgreSQL databases accessed via Libgda:
    </para>
    <sect2><title>BLOB handling</title>
      <para>
	<itemizedlist>
	  <listitem><para>Postgres uses the "Oid" data type to internally store BLOBs, but this type is also used
	      to store other information within the database. Libgda assumes that any column of type "Oid" represents a
	      blob. If this is not the case, then you must cast it to the correct data type within your SQL query (for example
	      as "SELECT oid::varchar FROM...")</para></listitem>
	  <listitem><para>As Libgda tries as much as possible to avoid orphaned BLOBs, it assumes that any BLOB Oid is
	      present in at most one column of a table (and if not
	      present, then the BLOB is orphaned); if a same BLOB is present in more than one column of a table, then
	      expect some problems.</para></listitem>
	  <listitem><para>BLOB manipulations can only occur within a transaction, 
	      so you should start a transaction before any operation
	      on BLOBs, otherwise Libgda will automatically start one</para></listitem>
	</itemizedlist>
      </para>
    </sect2>
    <sect2><title>gda_server_provider_get_last_insert_id()</title>
      <para>The gda_server_provider_get_last_insert_id() function returns the Oid of the last inserted row, 
	of the last INSERT command (or execute of a INSERT query) that inserted exactly one row into a table that has OIDs. 
	Otherwise, this function returns NULL. 
	This function will also return NULL if the table affected by the INSERT statement does not contain OIDs. </para>
    </sect2>
  </sect1>

  <sect1 id="limitations_sqlite"><title>For SQLite</title>
    <para>
      The following limitations apply to SQLite databases accessed via Libgda:
    </para>
    <sect2><title>gda_server_provider_get_last_insert_id()</title>
      <para>The gda_server_provider_get_last_insert_id() function returns the ROWID of the most recent INSERT into the database 
	(The rowid is always available as an undeclared column named ROWID, OID, or _ROWID_, and if the table has a column 
	of type INTEGER PRIMARY KEY then that column is another an alias for the rowid).
	For more information, see the SQLite documentation for the sqlite3_last_insert_rowid() function.</para>
    </sect2>
  </sect1>

  <sect1 id="limitations_others"><title>For Other providers</title>
    <para>
      The following limitations apply to all the other databases accessed via Libgda:
    </para>
    <sect2><title>gda_server_provider_get_last_insert_id()</title>
      <para>The gda_server_provider_get_last_insert_id() function is not implemented.</para>
    </sect2>
  </sect1>
  
</chapter>
