<chapter id="limitations">
  <title>Limitations</title>

  <sect1 id="limitations_global"><title>Global limitations</title>
    <para>
      &LIBGDA;'s global limitations are:
      <sect2 id="threads"><title>Multi threading</title>
	<para>&LIBGDA; is not thread safe. However it supports working with threads as long as
	  any object created by the API is used by one single thread (that is there is no
	  situation when two threads try to acces the same object at the same time).
	</para>
	<para>For example it is safe to start a thread and in that thread create a connection
	  which is only used in that thread.</para>
      </sect2>
    </para>
  </sect1>

  <sect1 id="limitations_mysql"><title>For MySQL</title>
    <para>
      The following limitations apply to MySQL databases accessed via Libgda: none.
    </para>
  </sect1>

  <sect1 id="limitations_oracle"><title>For Oracle</title>
    <para>
      The following limitations apply to Oracle databases accessed via Libgda:
      <itemizedlist>
	<listitem><para>At the moment tables' fields shema information retreival is very slow, so as a work around, use a dictionary
	to store the database schema and do incremental updates on modified/created tables.</para></listitem>
      </itemizedlist>
    </para>
  </sect1>

  <sect1 id="limitations_postgres"><title>For PostgreSQL</title>
    <para>
      The following limitations apply to PostgreSQL databases accessed via Libgda:
    </para>
    <sect2><title>BLOB handling</title>
      <para>
	<itemizedlist>
	  <listitem><para>Postgres uses the "Oid" data type to internally store BLOBs, but this type is also used
	      to store other information within the database. Libgda assumes that any column of type "Oid" represents a
	      blob. If this is not the case, then you must cast it to the correct data type within your SQL query (for example
	      as "SELECT oid::varchar FROM...")</para></listitem>
	  <listitem><para>As Libgda tries as much as possible to avoid orphaned BLOBs, it assumes that any BLOB Oid is
	      present in at most one column of a table (and if not
	      present, then the BLOB is orphaned); if a same BLOB is present in more than one column of a table, then
	      expect some problems.</para></listitem>
	  <listitem><para>BLOB manipulations can only occur within a transaction, 
	      so you should start a transaction before any operation
	      on BLOBs, otherwise Libgda will automatically start one</para></listitem>
	</itemizedlist>
      </para>
    </sect2>

    <sect2><title>Last inserted row's values</title>
      <para>
	The <link linkend="gda-connection-statement-execute-non-select">gda_connection_statement_execute_non_select()</link>'s last_insert_row attribute will return a <link linkend="GdaSet">GdaSet</link> object only if the table has OIDs.
      </para>
    </sect2>
  </sect1>

  <sect1 id="limitations_sqlite"><title>For SQLite</title>
    <para>
      The following limitations apply to SQLite databases accessed via Libgda:
    </para>
    <sect2><title>Last inserted row's values</title>
      <para>
	The <link linkend="gda-connection-statement-execute-non-select">gda_connection_statement_execute_non_select()</link>'s last_insert_row attribute uses the hidden "_ROWID_" column for each table, but it may fail if the table has a column with the same name.
      </para>
    </sect2>
  </sect1>
  
</chapter>
