<!doctype book PUBLIC "-//Davenport//DTD DocBook V3.0//EN" [

<!ENTITY LIBGDA          "<application>libgda</application>">
<!ENTITY GNOMEDB         "<application>GNOME-DB</application>">
<!ENTITY igalia          '<ulink url="http://www.igalia.com">Igalia, S.L.</ulink>'>
<!ENTITY API             "<acronym>API</acronym>">
<!ENTITY DBMS            "<acronym>DBMS</acronym>">
<!ENTITY DSN             "<acronym>DSN</acronym>">
<!ENTITY ODBC            "<acronym>ODBC</acronym>">
<!ENTITY GDA             "<acronym>GDA</acronym>">
<!ENTITY LDAP            "<acronym>LDAP</acronym>">
<!ENTITY CORBA           "<acronym>CORBA</acronym>">
<!ENTITY IDL             "<acronym>IDL</acronym>">
<!ENTITY ORB             "<acronym>ORB</acronym>">
<!ENTITY SQL             "<acronym>SQL</acronym>">
<!ENTITY RPM             "<acronym>RPM</acronym>">
<!ENTITY XML             "<acronym>XML</acronym>">
<!ENTITY PGSQL           "<application>PostgreSQL</application>">
<!ENTITY MYSQL           "<application>MySQL</application>">
<!ENTITY ORAC            "<application>Oracle</application>">
<!ENTITY INTERB          "<application>Interbase</application>">
<!ENTITY SYBASE          "<application>Sybase</application>">
<!ENTITY MSACC           "<application>MS Access</application>">
<!ENTITY INFOR           "<application>Informix</application>">
<!ENTITY GDASERVERPROVIDER "<xref linkend='libgda-GdaServerProvider'>">
<!ENTITY GDADATAMODEL    "<xref linkend='libgda-GdaDataModel'>">
<!ENTITY GDADATAMODELARRAY "<xref linkend='libgda-GdaDataModelArray'>">
<!ENTITY GDADATAMODELHASH "<xref linkend='libgda-GdaDataModelHash'>">
<!ENTITY fullexample SYSTEM "examples/full_example.c" CDATA linespecific>
<!entity migration.sgml system "migration.sgml">
<!ENTITY libgda-batch SYSTEM "sgml/gda-batch.sgml">
<!ENTITY libgda-client SYSTEM "sgml/gda-client.sgml">
<!ENTITY libgda-command SYSTEM "sgml/gda-command.sgml">
<!ENTITY libgda-config SYSTEM "sgml/gda-config.sgml">
<!ENTITY libgda-connection SYSTEM "sgml/gda-connection.sgml">
<!ENTITY libgda-data-model-array SYSTEM "sgml/gda-data-model-array.sgml">
<!ENTITY libgda-data-model-hash SYSTEM "sgml/gda-data-model-hash.sgml">
<!ENTITY libgda-data-model-list SYSTEM "sgml/gda-data-model-list.sgml">
<!ENTITY libgda-data-model SYSTEM "sgml/gda-data-model.sgml">
<!ENTITY libgda-error SYSTEM "sgml/gda-error.sgml">
<!ENTITY libgda-export SYSTEM "sgml/gda-export.sgml">
<!ENTITY libgda-field SYSTEM "sgml/gda-field.sgml">
<!ENTITY libgda-init SYSTEM "sgml/libgda.sgml">
<!ENTITY libgda-log SYSTEM "sgml/gda-log.sgml">
<!ENTITY libgda-parameter SYSTEM "sgml/gda-parameter.sgml">
<!ENTITY libgda-quark-list SYSTEM "sgml/gda-quark-list.sgml">
<!ENTITY libgda-row SYSTEM "sgml/gda-row.sgml">
<!ENTITY libgda-select SYSTEM "sgml/gda-select.sgml">
<!ENTITY libgda-server-provider SYSTEM "sgml/gda-server-provider.sgml">
<!ENTITY libgda-table SYSTEM "sgml/gda-table.sgml">
<!ENTITY libgda-transaction SYSTEM "sgml/gda-transaction.sgml">
<!ENTITY libgda-util SYSTEM "sgml/gda-util.sgml">
<!ENTITY libgda-value SYSTEM "sgml/gda-value.sgml">
<!ENTITY libgda-xml-connection SYSTEM "sgml/gda-xml-connection.sgml">
<!ENTITY libgda-xml-database SYSTEM "sgml/gda-xml-database.sgml">
<!ENTITY libgda-xml-document SYSTEM "sgml/gda-xml-document.sgml">
<!ENTITY libgda-xql-atom SYSTEM "sgml/gda-xql-atom.sgml">
<!ENTITY libgda-xql-bin SYSTEM "sgml/gda-xql-bin.sgml">
<!ENTITY libgda-xql-column SYSTEM "sgml/gda-xql-column.sgml">
<!ENTITY libgda-xql-const SYSTEM "sgml/gda-xql-const.sgml">
<!ENTITY libgda-xql-delete SYSTEM "sgml/gda-xql-delete.sgml">
<!ENTITY libgda-xql-dml SYSTEM "sgml/gda-xql-dml.sgml">
<!ENTITY libgda-xql-dual SYSTEM "sgml/gda-xql-dual.sgml">
<!ENTITY libgda-xql-field SYSTEM "sgml/gda-xql-field.sgml">
<!ENTITY libgda-xql-func SYSTEM "sgml/gda-xql-func.sgml">
<!ENTITY libgda-xql-insert SYSTEM "sgml/gda-xql-insert.sgml">
<!ENTITY libgda-xql-item SYSTEM "sgml/gda-xql-item.sgml">
<!ENTITY libgda-xql-join SYSTEM "sgml/gda-xql-join.sgml">
<!ENTITY libgda-xql-list SYSTEM "sgml/gda-xql-list.sgml">
<!ENTITY libgda-xql-query SYSTEM "sgml/gda-xql-query.sgml">
<!ENTITY libgda-xql-select SYSTEM "sgml/gda-xql-select.sgml">
<!ENTITY libgda-xql-stack SYSTEM "sgml/gda-xql-stack.sgml">
<!ENTITY libgda-xql-target SYSTEM "sgml/gda-xql-target.sgml">
<!ENTITY libgda-xql-update SYSTEM "sgml/gda-xql-update.sgml">
<!ENTITY libgda-xql-utils SYSTEM "sgml/gda-xql-utils.sgml">
<!ENTITY libgda-xql-value SYSTEM "sgml/gda-xql-value.sgml">
<!ENTITY libgda-xql-valueref SYSTEM "sgml/gda-xql-valueref.sgml">
<!ENTITY libgda-report-types SYSTEM "sgml/gda-report-types.sgml">
<!ENTITY libgda-report-document SYSTEM "sgml/gda-report-document.sgml">
<!ENTITY fdl-appendix SYSTEM "fdl-appendix.sgml">
]>

<book id="index">
  <bookinfo>
    <title>GNOME Data Access manual</title>
    <authorgroup>
      <author>
        <firstname>Michael</firstname>
        <surname>Lausch</surname>
        <affiliation>
          <address><email>michael.lausch@1012surf.net</email></address>
        </affiliation>
      </author>
      <author>
        <firstname>Rodrigo</firstname>
        <surname>Moya</surname>
        <affiliation>
          <address><email>rodrigo@gnome-db.org</email></address>
        </affiliation>
      </author>
      <author>
        <firstname>Vivien</firstname>
        <surname>Malerba</surname>
        <affiliation>
          <address><email>malerba@linuxave.net</email></address>
        </affiliation>
      </author>
      <author role="clean up">
	<firstname>Sean</firstname>
	<surname>Allen</surname>
	<affiliation>
	  <address><email>zeroone@worldonline.co.za</email></address>
	</affiliation>
	<contrib>GDP compliance, FDL, added mark-up, English and syntax
        </contrib>
      </author>
      <author>
	<firstname>Xabier</firstname>
	<surname>Rodríguez Calvar</surname>
	<affiliation>
          <orgname>&igalia;</orgname>
	  <address><email>xrcalvar@igalia.com</email></address>
	</affiliation>
	<contrib>How to begin and migration formulae
        </contrib>
      </author>
      <author>
	<firstname>José</firstname>
	<surname>Dapena Paz</surname>
	<affiliation>
          <orgname>&igalia;</orgname>
	  <address><email>jdapena@igalia.com</email></address>
	</affiliation>
	<contrib>Some examples
        </contrib>
      </author>
    </authorgroup>
    <date>1999 February</date>
    <copyright>
      <year>1999-2002</year>
      <holder>The GNOME Foundation</holder>
    </copyright>
    <abstract>
      <para>
        GNOME Data Access (&GDA;) is an architecture whose 
        purpose is to provide universal access to many different kinds and
        types of data sources. This goes from traditional relational database
        systems, to any imaginable kind of data source such as a mail server,
        a &LDAP; directory...
      </para>
      <para>
        This universality is obtained through the use of
        an easily extensible plug-in system as the mechanism for
	communication between the different components in the architecture.
      </para>
    </abstract>
    <legalnotice id="legalnotice">
      <para>
        Permission is granted to copy, distribute and/or modify this document
        under the terms of the <link linkend="fdl"><citetitle>GNU
        Free Documentation License</citetitle></link>, Version 1.1 or any later
        version published by the Free Software Foundation with no Invariant
        Sections, no Front-Cover Texts, and no Back-Cover Texts.  A copy of the
        license can be found in <xref linkend="fdl">.
      </para>
      <para>
        Many of the names used by companies to distinguish their products and
        services are claimed as trademarks. Where those names appear in any
        GNOME documentation, and those trademarks are made aware to the members
        of the GNOME Documentation Project, the names have been printed in caps
        or initial caps.
      </para>
    </legalnotice>
  </bookinfo>

  <chapter id="introduction">
    <title>Introduction</title>
    <para>
      &ODBC; and &SQL; are established standards. The problem is, that &ODBC;
      doesn't specify the wire protocol and for some databases no &ODBC; driver
      exists. You might use <acronym>RPC</acronym>, <acronym>TCP/IP</acronym>,
      or shared memory and signals to pass the request from the client to the
      server. So you have to use the database specific &ODBC; library. This 
      library might not be available for the <acronym>CPU</acronym> or 
      operating system on which the client is running. 
    </para>
    <para>
      &SQL; itself is also not standardised enough, so that source
      compatibility can not be assured for all database servers. And for some
      sort of servers, &SQL; is not even feasible (think about &LDAP;).
    </para>
    <para>
      &GDA; tries to tackle the &ODBC; problem and help you with the &SQL;
      problem. It's a sort of middleware (or can be blown up to be a middleware
      layer) to access different data sources. It offers a high level view of
      data sources and has some places where you can plug in low level access
      to the database for special tasks.
    </para>
    <para>
      GNOME Data Access (&GDA;) is defined as a set of plug-in interfaces.
      The level of abstraction provided by &GDA; makes it possible to access
      any kind of data source, provided that a plug-in implementing 
      those interfaces and accessing this particular data source is
      written.
    </para>
    <para>
      It offers a wrapper around the database internals, thus making it easier
      for programmers to make use of all the power provided by many RDBMS without
      even knowing about it. It comes along with a library, for both
      clients and servers, as a C implementation of this architecture. This level of
      abstraction would make possible to, at a later time, change all the
      internals without having to modify applications using the libraries.
    </para>
    <para>
      Along with these libraries (and associated header files and language 
      bindings for development), &LIBGDA; includes several tools and utilities
      to help you with the task of developing applications based on &LIBGDA;,
      as well as for automating some database-related tasks.
    </para>
    <para>
      &LIBGDA; is implemented for <systemitem class="osname">UNIX
      </systemitem>-like operating systems (including <systemitem 
      class="osname">Linux</systemitem>), and does not depend on other 
      libraries apart from  <systemitem class="resource">libxml2</systemitem> and 
      <systemitem class="resource">Glib</systemitem>, which makes it a very
      lightweight system also ideal for applications to be run on 
      hardware-limited systems. It was once part of the &GNOMEDB; project, and
      is still used as the basis for it, but it's been separated from it to
      remove all GNOME dependencies and thus allow non-GNOME applications to
      be developed based on it.
    </para>
  </chapter>
  
  <chapter id="architecture">
    <title>&LIBGDA; architecture</title>
    <para>
      &LIBGDA; is composed of three independent layers. The lower level is
      covered by the &GDA; providers, which are plug-ins whose task is
      to map the <acronym>RDBMS</acronym>-specific &API; to the &GDA; model.
      That is, they are objects implementing the &GDA; interfaces.
    </para>
    <para>
      Then, in a middle layer, are the client libraries: an easy-to-use and
      full featured library which offers access to all the architecture,
      also including several utility functions to help you on the development
      of applications based on &GDA;. This library, although targeted to client
      applications, also includes a set of helper classes and functions to help
      in the addition of new providers to the &LIBGDA; architecture.
    </para>
    <para>
      Finally, at the upper level sit all the client applications provided in
      the suite, as well as any application that may make use of the client
      libraries.
    </para>
  </chapter>
  
  <chapter id="installation">
    <title>Installation</title>
    <sect1 id="installation-introduction">
      <title>Introduction</title>
      <para>
        On our web site, <ulink url="http://www.redhat.com" type="http">RedHat
        </ulink> and <ulink url="http://www.debian.org" type="http">Debian
        </ulink> packages are available, so you shouldn't have any problem
        installing it. For a standard installation, there is are no further
        steps, but, you'd better know configuration
        options, just in case you come across a non-standard installation, or 
        in case of problems during a standard installation.
      </para>
    </sect1>
    <sect1 id="installation-installing">
      <title>Installing</title>
      <para>
        Installation depends on which format you choose to download. If
        you've got a package such as &RPM; or <acronym>DEB</acronym>, check
        your package manager documentation for how to install new packages.
      </para>
      <para>
        If you downloaded the source code (in a tarball), you must
        compile the software. For doing so, once you have unpacked
        the source tree, you must:
        <screen>
          <prompt>$</prompt><userinput>./configure</userinput>
          <prompt>$</prompt><userinput>make</userinput>
          <prompt>$</prompt><userinput>make install</userinput>
        </screen>
      </para>
      <para>
        This will generate the makefiles for your specific platform,
        compile all the source tree, and install the binaries and
        documentation in your system.
      </para>
      <para>
        If you don't find a file named <filename>configure</filename>, there
        should be one called <filename>autogen.sh</filename>. In this case,
        run <filename>autogen.sh</filename>, which will create and run the
        generated <filename>configure</filename> file.
      </para>
      <para>
        You can specify several arguments to <filename>configure</filename> (or
        <filename>autogen.sh</filename>). The most significant are (you can
        check all the available arguments by running
        <command>configure --help</command>):
      </para>
      <itemizedlist mark="bullet">
        <listitem>
          <para>
            <userinput>--prefix=&lt;directory&gt;</userinput>: Prefix where
             package will be installed
          </para>
        </listitem>
        <listitem>
          <para>
            <userinput>--with-mysql=&lt;directory&gt;</userinput>: Specify
            directory where &MYSQL; libraries are installed
          </para>
        </listitem>
        <listitem>
          <para>
            <userinput>--with-postgres=&lt;directory&gt;</userinput>:
            Specify directory where &PGSQL; libraries are installed
          </para>
        </listitem>
        <listitem>
          <para>
            <userinput>--with-sybase=&lt;directory&gt;</userinput>: Specify
            directory where &SYBASE; libraries are installed
          </para>
        </listitem>
        <listitem>
          <para>
            <userinput>--with-ldap=&lt;directory&gt;</userinput>: Specify
             directory where &LDAP; libraries are installed
          </para>
        </listitem>
        <listitem>
          <para>
            <userinput>--with-oracle=&lt;directory&gt;</userinput>: Specify
            directory where &ORAC; libraries are installed
          </para>
        </listitem>
        <listitem>
          <para>
            <userinput>--with-interbase=&lt;directory&gt;</userinput>: Specify
            directory where &INTERB; libraries are installed
          </para>
        </listitem>
        <listitem>
          <para>
            <userinput>--with-mdb=&lt;directory&gt;</userinput>: Specify
            directory where the MDB libraries (for accessing &MSACC; files)
            are installed
          </para>
        </listitem>
	<listitem>
          <para>
            <userinput>--with-sqlite=&lt;directory&gt;</userinput>: Specify
            directory where the SQLite libraries are installed
          </para>
        </listitem>
      </itemizedlist>
      <para>
        Providers are not installed by default, so you must specifically add
        those arguments when running <filename>configure</filename>.
      </para>
      <para>
        If you find any problem during the configuration, compilation or
        installation process, do not hesitate in contacting the
        &GNOMEDB; mailing list (<email>gnome-db-list@gnome.org</email>, first
        send an email to <email>gnome-db-list-request@gnome.org</email> with 
        the subject SUBSCRIBE, if you are not already subscribed).
      </para>
      <sect2 ID="installation-debian">
        <title>Debian installation</title>
          <para>
            If you are using <ULINK URL="http://www.debian.org">Debian</ULINK> you
	    will need to install a few packages in the following way:
	  </para>
          <PROGRAMLISTING>
            <SYSTEMITEM CLASS="prompt">$</SYSTEMITEM> <USERINPUT> apt-get install <EMPHASIS>package-names</EMPHASIS></USERINPUT>
          </PROGRAMLISTING>
          <para>
            These are the packages you will need for this:
          </para>
          <ITEMIZEDLIST>
            <LISTITEM>libgda2-1</LISTITEM>
            <LISTITEM>libgda2-common</LISTITEM>
            <LISTITEM>libgda2-dev</LISTITEM>
            <LISTITEM>libgda2-doc</LISTITEM>
            <LISTITEM>libgda2-dbg</LISTITEM>
          </ITEMIZEDLIST>
          <para>
            You can obtain information about any packages with:
          </para>
          <PROGRAMLISTING>
            <SYSTEMITEM CLASS="prompt">$</SYSTEMITEM> <USERINPUT> apt-cache show <EMPHASIS>package-names</EMPHASIS></USERINPUT>
          </PROGRAMLISTING>
          <para>
            If you cannot find this packages, you must include in
            <filename class="directory">/etc/apt/sources.list</filename>
            a line like this:
          </para>
          <PROGRAMLISTING>
            deb http://gluck.debian.org/~kov/debian woody gnome2
          </PROGRAMLISTING>
      </sect2>
    </sect1>
    <sect1 ID="compiling">
      <title>Compiling with the library</title>
        <para>
          To compile you will need to set the C flags and to link the library, so we recommend
          to use the <EMPHASIS>pkg-config</EMPHASIS> command.
        </para>
        <PROGRAMLISTING>
          <SYSTEMITEM CLASS="prompt">$</SYSTEMITEM> <USERINPUT> gcc -o main `pkg-config --cflags --libs libgda` main.c</USERINPUT>
        </PROGRAMLISTING>
    </sect1>
    <sect1 id="installation-configuring">
      <title>Configuring</title>
      <para>
        Depending on the use you're going to get out of &LIBGDA;, you may have
        to dig deep into its internals, but don't be afraid, things have been
        implemented to be easy to use.
      </para>
      <sect2 id="installation-development">
        <title>Configuration for development</title>
        <para>
          If you want to develop applications using &LIBGDA;, you should 
          install the libgda-dev[el] package if you do a &RPM; or <LINK
	  LINKEND="installation-debian">Debian-based</LINK>
          installation. If you compiled the source code, development files are
          installed in your system.
        </para>
        <para>
          The only step you need to do to make sure everything is well 
          installed, is to check that &LIBGDA; libraries and binaries are seen
          by your system. That is, make sure that the &LIBGDA; 
          <filename class="directory">bin/</filename> directory is in your
          <envar>PATH</envar> environment variable, as well as the
          <filename class="directory">lib/</filename> in your 
          <envar>LD_LIBRARY_PATH</envar> (or 
          <filename>/etc/ld.so.conf</filename> file).
        </para>
        <para>
          You have to include a headers file, and it is:
        </para>
        <programlisting>
#include &lt;libgda/libgda.h&gt;
        </programlisting>
      </sect2>
      <sect2 id="installation-client">
        <title>Configuration for accessing a database</title>
        <para>
          If you want to access a data source through a &GDA;
          provider, you must first of all have access to this provider, and
          most importantly, this provider should have access to its specific
          data source. So, first have your database up and running.
          For this, you'll have to check your specific data source
          documentation, or see the &LIBGDA; providers' specific documentation.
        </para>
        <para>
          Once you've got your &GDA; provider installed,
          whether on your machine or on another one on the network, you must
          configure your local system to have access to it. If you're on a
          local installation, once you have installed the &GDA; provider (by 
          compiling it or by installing its &RPM; or Debian package), the 
          provider is visible in your machine. This is because the provider
          installs itself in a well known location that makes &LIBGDA;
	  itself know about the new provider.
        </para>
        <para>
          Then, the next step is to configure the data sources you want
          available on your system. For doing this, you should, as for now, use
          &GNOMEDB;, which is a front-end to &LIBGDA; for the 
          <ulink url="http://www.gnome.org" type="http">GNOME project</ulink>.
          <footnote>
	    <para>
	      It would be a good idea to add a command-line tool for managing
              the configuration, as now, using <systemitem class="resource">
              GConf</systemitem>, is not a matter of hacking on a config text
              file, as it was before with <function>gnome_config</function>.
              The &API; for doing so is already available in the <filename>
              libgda-common</filename>library, so it would be really easy.
              Volunteers?
	    </para>
	  </footnote>
	</para>
	<para>
	  Command-line tools will be provided in &LIBGDA; for doing so in a
          not-too-distant future, so you may want to know what information
          you need to setup a data source.
	</para>
	<para>
	  One of the problem &GDA; solves is the naming of
          data sources. Every database system has it's own way of defining
	  names for it's databases. For example &MYSQL; uses the hostname, 
          port number, and the name of the database. Other databases, like
          Solid use the hostname and port number only. There is no support
          for multiple databases per server. Because the client does not
          need all these details, the &LIBGDA; configuration defines all the
	  properties of such a data source, so that the correct data base
          server can be contacted. This information is accessed by the
          client library and sent to the provider, which in turn will parse
          the string to decide which database must be connected to. The
          data stored for each data source is as follows:
	  
	  <programlistingco>
	    <areaspec>
	      <area id="provider" coords="2">
	      <area id="dsn" coords="3">
              <area id="description" coords="4">
	      <area id="username" coords="5">
	      <area id="password" coords="6">
            </areaspec>
	    <programlisting>
	      [sales]
	      Provider=MySQL
              DSN=DATABASE=test;HOST=localhost;PORT=1111
	      Description=MySQL Test Database in native mode
	      Username=username
	      Password=password
	    </programlisting>
	    <calloutlist>
	      <callout arearefs="provider">
		<para>
    		  The provider for this database is the gda-mysql
		  provider. The value of this entry is used as the
		  object ID for the plug-in activation.
		</para>
	      </callout>
	      <callout arearefs="dsn">
		<para>
		  This is the most important entry. The value of
		  this entry is the string sent to the provider so
		  that it knows which datasource to access. How this
		  entry is interpreted by the providers is described 
		  in the provider section.
		</para>
		<para>
		  There are, though, a set of default properties that can
		  be used for the connection string for all providers. Those
		  are:
		  <itemizedlist>
		    <listitem>
		      <para>USERNAME: user name to be used for authentication.</para>
		    </listitem>
		    <listitem>
		      <para>PASSWORD: password to be used for authentication.</para>
		    </listitem>
		  </itemizedlist>
		</para>
	      </callout>
	      <callout arearefs="description">
		<para>
		  The value of this entry is a short description of
		  the datasource. It is here for convenience only
		  and it is not used for any purpose.
		</para>
	      </callout>
	      <callout arearefs="username">
	        <para>
		  The user name to be used when connecting to the database.
		</para>
	      </callout>
	      <callout arearefs="password">
	        <para>
		  The password to be used when connecting to the database.
		  This is stored in plain text, so be sure you restrict access
		  to the configuration file (<filename>~/.libgda/config</filename>)
		  to any &quot;dangerous&quot; users.
		</para>
	      </callout>
	    </calloutlist>
	  </programlistingco>
	</para>
        <para>
          The &XML; configuration file (<filename
	  class="directory">~/.libgda/config</filename>) is not
	  recommended to be modified by hand and, about our example, it is
	  something like this:
        </para>
	<programlisting>
&lt;?xml version="1.0"?&gt;
&lt;libgda-config&gt;
  &lt;section path="/apps/libgda/Datasources/sales"&gt;
    &lt;entry name="DSN" type="string" value="PORT=1111;DATABASE=test;HOST=localhost"/&gt;
    &lt;entry name="Description" type="string" value="MySQL Test Database in native mode"/&gt;
    &lt;entry name="Password" type="string" value="password"/&gt;
    &lt;entry name="Provider" type="string" value="MySQL"/&gt;
    &lt;entry name="Username" type="string" value="username"/&gt;
  &lt;/section&gt;
&lt;/libgda-config&gt;
        </programlisting>
        <sect3 ID="data-sources-API-functions">
        <title>Managing data sources with API functions</title>
          <sect4>
            <title>Create data sources</title>
            <para>
                      To create a data source you must use the function <LINK
              LINKEND="gda-config-save-data-source"><EMPHASIS>gda-config-save-data-source ()
              </EMPHASIS></LINK>
            </para>
            <para>
                      Here you see how to create a data source named
              <EMPHASIS>foo_ds</EMPHASIS>. If you do not need to give an username or password to
              enter the database, you could put <EMPHASIS>NULL</EMPHASIS>.
            </para>
            <programlisting>
            gda_config_save_data_source ("foo_ds", "PostgreSQL", "DATABASE=foo_db",
                                         "description of foo_ds", "foo_username, "foo_password");
            gda_config_save_data_source ("other_foo_ds", "MySQL", "DATABASE=other_foo_db,HOST=db.foo.com",
                                         "description of other_foo_ds", "foo", NULL);
            </programlisting>
            <para>
              For more details about provider specific information see in the section about
              <LINK LINKEND="installation-provider">providers specific information</LINK>.
            </para>
            <para>
              There was a little bug<footnote>It can be fixed, but it
              is better not to run the risk of it.</footnote>, and it
	      is that <LINK
	      LINKEND="gda-config-save-data-source">gda_config_save_data_source()</LINK> 
              does not create the configuration directory <filename
	      class="directory">~/.libgda</filename>, so you have to do
	      it.
            </para>
            <para>
              There is no problem about calling several times to this
	      function because if you save an existing data source, it
	      is replaced.
            </para>
          </sect4>
          <sect4>
            <title>Removing data sources</title>
            <para>
                      To remove a data source you must use the function <LINK
              LINKEND="gda-config-remove-data-source"><EMPHASIS>gda-config-remove-data-source ()
              </EMPHASIS></LINK>
            </para>
            <para>
                      Here you see how to remove a data source named
              <EMPHASIS>foo_ds</EMPHASIS>.
            </para>
            <programlisting>
            gda_config_remove_data_source("foo_ds");
            </programlisting>
          </sect4>
          <sect4>
            <title>Listing available data sources</title>
            <para>
                      To list available data sources you must use the function <LINK
              LINKEND="gda-config-get-data-source-list"><EMPHASIS>gda_config_get_data_source_list ()
              </EMPHASIS></LINK>
            </para>
            <para>
              Here you see a function which lists the available data sources.
            </para>
            <PROGRAMLISTINGCO>
              <AREASPEC UNITS="LINECOLUMN">
                <AREA ID="gda-config-get-data-source-list-1" COORDS="8 1">
                <AREA ID="gda-config-get-data-source-list-2" COORDS="21 1">
              </AREASPEC>
              <programlisting>
              void
              list_datasources (void)
              {
                GList *ds_list;
                GList *node;
                GdaDataSourceInfo *info;
              
                ds_list = gda_config_get_data_source_list ();
              
                g_print ("\n");
                for (node = g_list_first (ds_list); node != NULL; node = g_list_next (node))
                  {
                    info = (GdaDataSourceInfo *) node->data;
              
                    g_print
                      ("NAME: %s PROVIDER: %s CNC: %s DESC: %s USER: %s PASSWORD: %s\n",
                       info->name, info->provider, info->cnc_string, info->description,
                       info->username, info->password);
              
                  }
                g_print ("\n");
              
                gda_config_free_data_source_list (ds_list);
              
              }
              </programlisting>
              <CALLOUTLIST>
                <CALLOUT AREAREFS="gda-config-get-data-source-list-1">
                  <PARA>Our function.</PARA>
                </CALLOUT>
                <CALLOUT AREAREFS="gda-config-get-data-source-list-2">
                  <PARA>Note that you must free the list when you finish using it.</PARA>
                </CALLOUT>
              </CALLOUTLIST>
            </PROGRAMLISTINGCO>
          </sect4>
          <sect4>
            <title>Listing available providers</title>
            <para>
              To list the available data sources you must use the function <LINK
              LINKEND="gda-config-get-provider-list"><EMPHASIS>gda_config_get_provider_list ()
              </EMPHASIS></LINK>
            </para>
            <para>
              Here you see a function which lists available providers.
            </para>
            <PROGRAMLISTINGCO>
              <AREASPEC UNITS="LINECOLUMN">
                <AREA ID="gda-config-get-provider-list-1" COORDS="8 1">
                <AREA ID="gda-config-get-provider-list-2" COORDS="19 1">
              </AREASPEC>
              <programlisting>
              void
              list_providers (void)
              {
                GList *prov_list;
                GList *node;
                GdaProviderInfo *info;
              
                prov_list = gda_config_get_provider_list ();
              
                for (node = g_list_first (prov_list); node != NULL;
                     node = g_list_next (node))
                  {
                    info = (GdaProviderInfo *) node->data;
              
                    g_print ("ID: %s\n", info->id);
              
                  }
              
                gda_config_free_provider_list (prov_list);
              
              }
              </programlisting>
              <CALLOUTLIST>
                <CALLOUT AREAREFS="gda-config-get-provider-list-1">
                  <PARA>Our function.</PARA>
                </CALLOUT>
                <CALLOUT AREAREFS="gda-config-get-provider-list-2">
                  <PARA>Note that you must free the list when you finish using it.</PARA>
                </CALLOUT>
              </CALLOUTLIST>
            </PROGRAMLISTINGCO>
          </sect4>
        </sect3>
      </sect2>
      <sect2 id="installation-provider">
        <title>Provider's specific information</title>
        <para>
          This section provides information specific to each of the available
          &LIBGDA; providers.
        </para>
	<sect3 id="installation-provider-default">
	  <title>Default provider</title>
	  <para>
	    The &GDA; default provider is always installed 
            with &LIBGDA, which means that you've got always a default
	    database system available for you. To connect to a default 
            provider's database, you only need to specify, in the &DSN; string,
            a string of the form "FILENAME=/directory/for/the/database". When
            you	first connect to the new data source, the &GDA; default 
            provider will create the database, in the directory you specified
            in the &DSN; string, if it does not exist. This default provider
	    uses XML as the format for that file.
	  </para>
	</sect3>
	<sect3 id="installation-provider-odbc">
	  <title>&ODBC; Provider</title>
	  <para>
	    The &ODBC; provider is a special case, since &ODBC; is itself a 
            data access layer, the same as &LIBGDA;, So, in the case of the
            &GDA; &ODBC; provider, the &DSN; string is completely up to the
            &ODBC; driver manager. That is, the &GDA; &ODBC; provider does not
            parse it all, nor does it try to understand what it means; it
            simply passes it over to the &ODBC; library.
	  </para>
	  <para>
	    So, if you want to use &LIBGDA; with &ODBC;, you should first know
            how to set up an &ODBC; data source, and then just specify the
            &DSN; string you would pass to the &ODBC; library in the &DSN;
            string of the &GDA; data sources.
	  </para>
	  <para>
	    There is a project called
	    <ulink url="http://www.unixodbc.org">unixODBC</ulink>,
            which provides some graphical tools to help you in
	    setting up &ODBC; data sources. You may find it
	    interesting to give it a try.
	  </para>
	</sect3>
	<sect3 id="installation-provider-postgres">
	  <title>&PGSQL; Provider</title>
	  <para>
	    To use the &GDA; &PGSQL; provider, you'll need
	    the <application>gda-postgres</application> package.	
	  </para>
	  <para>
	    The &PGSQL; provider accepts the following
	    arguments in the &GDA; data source's &DSN; string:
	     <itemizedlist>
	       <listitem>
	         <para>
	           HOST: name of the host where
		   the database server is running. If it begins with a slash
		   then the protocol used is Unix-domain instead of TCP/IP and
		   its value is the name of the directory where the file is
		   stored. By default: /tmp.
		 </para>
               </listitem>
	       <listitem>
		 <para>
		   HOSTADDR: IP of the host where the database server is
		   running (avoids DNS lookup). If this option has a value,
		   TCP/IP communications is used.

		   If neither a host name or host address is specified, the
		   connection will be established using a local Unix domain
		   socket.
		 </para>
	       </listitem>
	       <listitem>
	         <para>
	           PORT: Port number or socket filename extension for
		   Unix-domain connections.
		 </para>
               </listitem>
	       <listitem>
		 <para>
		   DATABASE: name of the database you want to access. This one
		   is called 'dbname' in the &PGSQL; documentation.
		 </para>
	       </listitem>
	       <listitem>
	         <para>
	           USER: user name to connect as.
		 </para>
               </listitem>
	       <listitem>
	         <para>
	           PASSWORD: password if the connection requires it.
		 </para>
               </listitem>
	       <listitem>
	         <para>
	           OPTIONS: trace/debug options to be sent to the server.
		 </para>
               </listitem>
	       <listitem>
	         <para>
	           TTY: a file or tty for optional debug output from the
		   back-end.
		 </para>
               </listitem>
	       <listitem>
	         <para>
	           REQUIRESSL: set to '1' to force SSL connection to the
		   back-end. Set to '0' to negotiate with server.
		 </para>
               </listitem>
	     </itemizedlist>
	     The description of the parameters is almost copied from the
	     &PGSQL; documentation. Refer to it for details on how some
	     environment variables can also set these parameters.
	   </para>
	 </sect3>
        <sect3 id="installation-provider-mysql">
          <title>&MYSQL; Provider</title>
          <para>
	    To configure a data source to access a &MYSQL; database,
	    you'll need to install the &GDA; &MYSQL; provider (package
	    <filename>gda-mysql</filename>).
          </para>
	  <para>
	    It accepts the following arguments in the &DSN;
	    string:	
	     <itemizedlist>
	       <listitem>
	         <para>
	           HOST:
		 </para>
               </listitem>
	       <listitem>
	         <para>
	           DATABASE:
		 </para>
               </listitem>
	       <listitem>
	         <para>
	           USERNAME:
		 </para>
               </listitem>
	       <listitem>
	         <para>
	           PASSWORD:
		 </para>
               </listitem>
	       <listitem>
	         <para>
	           PORT:
		 </para>
               </listitem>
	       <listitem>
	         <para>
	           UNIX_SOCKET:
		 </para>
               </listitem>
	       <listitem>
	         <para>
	           FLAGS:
		 </para>
               </listitem>
	     </itemizedlist>
	  </para>
        </sect3>
	<sect3 id="installation-provider-sybase">
	  <title>&SYBASE; Provider</title>
	  <para>
	    To use the &GDA; &SYBASE; provider, you'll need
	    the <application>gda-sybase</application> package.	
	  </para>
	  <para>
	    The &SYBASE; provider accepts the following
	    arguments in the &GDA; data source's &DSN; string:
	     <itemizedlist>
	       <listitem>
	         <para>
		   HOST: name of the host where the database server is
		   running.
		   </para>
               </listitem>
	       <listitem>
	         <para>
	           USERNAME: user name to connect as.
		 </para>
               </listitem>
	       <listitem>
	         <para>
	           APPNAME:
		 </para>
               </listitem>
	       <listitem>
	         <para>
	           PASSWORD: password if the connection requires it.
		 </para>
               </listitem>
	       <listitem>
		 <para>
		   DATABASE:
		 </para>
	       </listitem>
	     </itemizedlist>
	   </para>
	 </sect3>
      </sect2>
    </sect1>
  </chapter>
  <chapter ID="connecting">
    <title>Beginning</title>
    <sect1 ID="initializing">
      <title>Initialising</title>
      <para>
        First of all you have to initialise the gda library, i.e. to call the
        <LINK LINKEND="gda-init"><EMPHASIS>gda_init ()</EMPHASIS></LINK> function.
      </para>
      <programlisting>
        gda_init ("TestGDA", "0.1", argc, argv);
      </programlisting>
      <para>
        After initialising you can work as usual or make a function with the whole
        stuff, calling <LINK LINKEND="gda-main-run">gda_main_run()</LINK>. Note that
        if you use this way you will need to call <LINK
        LINKEND="gda-main-quit">gda_main_quit()</LINK> in order to finish the program.
      </para>
      <PROGRAMLISTING>
      void
      do_stuff ()
      {
        GdaClient *client;
        GdaConnection *connection;
      
        list_providers ();
        list_datasources ();
      
        client = gda_client_new ();
      
        g_print ("CONNECTING\n");
        connection = gda_client_open_connection (client, "calvaris", NULL, NULL);
        g_print ("CONNECTED\n");
      
        proving_errors (connection);
      
        process_accounts(connection);
      
        process_accounts2(connection);
      
        gda_client_close_all_connections (client);
      
        gda_main_quit();
      }
      
      
      int
      main (int argc, char **argv)
      {
      
        g_print ("STARTING\n");
        gda_init ("TestGDA", "0.1", argc, argv);
      
        save_ds ();
        //  remove_ds();
      
        gda_main_run ((GdaInitFunc) do_stuff, (gpointer) NULL);
        //  do_stuff();
      }
      </PROGRAMLISTING>
    </sect1>
    <sect1 ID="connections">
      <title>Connecting</title>
      <para>
                To connect you need to use two functions. We use
        <LINK LINKEND="gda-client-new"><EMPHASIS>gda_client_new ()</EMPHASIS></LINK>
        to create a connection pool and use
        <LINK LINKEND="gda-client-open-connection"><EMPHASIS>gda_client_open_connection ()</EMPHASIS></LINK>
        to create the specific connections to the different data sources.
      </para>
      <PROGRAMLISTINGCO>
        <AREASPEC UNITS="LINECOLUMN">
          <AREA ID="connecting-1" COORDS="10 1">
          <AREA ID="connecting-2" COORDS="13 1">
          <AREA ID="connecting-3" COORDS="20 1">
        </AREASPEC>
        <programlisting>
        void
        do_stuff ()
        {
          GdaClient *client;
          GdaConnection *connection;
        
          list_providers ();
          list_datasources ();
        
          client = gda_client_new ();
        
          g_print ("CONNECTING\n");
          connection = gda_client_open_connection (client, "calvaris", NULL, NULL);
          g_print ("CONNECTED\n");
        
          proving_errors (connection);
        
          process_accounts(connection);
        
          gda_client_close_all_connections (client);
        
        }
        </programlisting>
        <CALLOUTLIST>
          <CALLOUT AREAREFS="connecting-1">
            <PARA>Creates the connection pool.</PARA>
          </CALLOUT>
          <CALLOUT AREAREFS="connecting-2">
            <para>
              Creates the connection to calvaris data source with the default username and
              password you have specify when
              <LINK LINKEND="installation-client">creating the data source</LINK>. However, you
              can specify them if you want.
            </para>
          </callout>
          <CALLOUT AREAREFS="connecting-3">
            <para>
              It's a good practice to close connections when you finish using them. It
              doesn't mean that you must close them each time you use them. It's better
              open the connections when program starts and use them during the whole
              execution.
            </para>
          </callout>
        </CALLOUTLIST>
      </PROGRAMLISTINGCO>
    </sect1>
  </chapter>
  <chapter ID="processing-queries">
    <title>Processing queries</title>
    <sect1>
      <title>Executing sentences</title>
      <sect2 ID="building-commands">
        <title>Building commands</title>
        <para>
          Before invoking a query you have to build the structure containing the
          command and you can do this with <LINK LINKEND="gda-command-new">
          <EMPHASIS>gda_command_new ()</EMPHASIS></LINK>.
        </para>
        <para>
          The command type we most commonly use is <LINK
          LINKEND="GdaCommandType">GDA_COMMAND_TYPE_SQL</LINK> because we will only
          focus on &SQL; queries<footnote>There are other command types, as &XML; and so on.
          </footnote>
        </para>
        <PROGRAMLISTINGCO>
          <AREASPEC UNITS="LINECOLUMN">
            <AREA ID="GdaCommandOptions-1" COORDS="2 1">
            <AREA ID="GdaCommandOptions-2" COORDS="3 1">
          </AREASPEC>
          <programlisting>
          typedef enum {
                  GDA_COMMAND_OPTION_IGNORE_ERRORS  = 1,
                  GDA_COMMAND_OPTION_STOP_ON_ERRORS = 1 &lt;&lt; 1,
                  GDA_COMMAND_OPTION_BAD_OPTION     = 1 &lt;&lt; 2
          } <LINK LINKEND="GdaCommandOptions">GdaCommandOptions</LINK>;
          </programlisting>
          <CALLOUTLIST>
            <CALLOUT AREAREFS="GdaCommandOptions-1">
              <PARA>
                        Ignores all errors and executes all sentences returning data models.
                For failed sentences, it returns an empty data model.
              </PARA>
            </CALLOUT>
            <CALLOUT AREAREFS="GdaCommandOptions-2">
              <para>
                Stops when finding and error and doesn't return data models.
              </para>
            </callout>
          </CALLOUTLIST>
        </PROGRAMLISTINGCO>
        <para>
          Here you see an example of creating a command:
        </para>
        <PROGRAMLISTINGCO>
          <AREASPEC UNITS="LINECOLUMN">
            <AREA ID="gda-command-new-1" COORDS="7 1">
            <AREA ID="gda-command-new-2" COORDS="8 1">
            <AREA ID="gda-command-new-3" COORDS="10 1">
          </AREASPEC>
          <programlisting>
          gint
          execute_sql_non_query (GdaConnection *connection, const gchar * buffer)
          {
            GdaCommand *command;
            gint number;
          
            command = gda_command_new (buffer, GDA_COMMAND_TYPE_SQL, GDA_COMMAND_OPTION_STOP_ON_ERRORS);
            number  = gda_connection_execute_non_query (connection, command, NULL);
          
            gda_command_free (command);
          
            return (number);
          }
          </programlisting>
          <CALLOUTLIST>
            <CALLOUT AREAREFS="gda-command-new-1">
              <PARA>
                Our function. You can give it several comma-separated sentences.
              </PARA>
            </CALLOUT>
            <CALLOUT AREAREFS="gda-command-new-2">
              <para>
                We will see it <LINK LINKEND="making-queries">later</LINK>.
              </para>
            </callout>
            <CALLOUT AREAREFS="gda-command-new-3">
              <para>
                It is a good practice to free the commands.
              </para>
            </callout>
          </CALLOUTLIST>
        </PROGRAMLISTINGCO>
      </sect2>
      <sect2 ID="making-queries">
        <title>Making <EMPHASIS>non queries</EMPHASIS></title>
        <para>
          <EMPHASIS>Non queries</EMPHASIS> are queries that does not return data, only the
          number of rows affected, as a DELETE or an UPDATE. We use <LINK
          LINKEND="gda-connection-execute-non-query"><EMPHASIS>
          gda_connection_execute_non_query()</EMPHASIS></LINK>
        </para>
        <programlisting>
        gint
        execute_sql_non_query (GdaConnection *connection, const gchar * buffer)
        {
          GdaCommand *command;
          gint number;
        
          command = gda_command_new (buffer, GDA_COMMAND_TYPE_SQL, GDA_COMMAND_OPTION_STOP_ON_ERRORS);
          number  = gda_connection_execute_non_query (connection, command, NULL);
        
          gda_command_free (command);
        
          return (number);
        }
        </programlisting>
      </sect2>
      <sect2 ID="normal-queries">
        <title>Making normal queries</title>
        <para>
          Normal queries are queries that return data (<LINK
          LINKEND="data-model">data models</LINK>). You have two ways to do this:
        </para>
        <ITEMIZEDLIST>
          <LISTITEM>
            <LINK LINKEND="gda-connection-execute-single-command">
              gda_data_model_execute_single_command()</LINK>
          </LISTITEM>
          <LISTITEM>
            <LINK LINKEND="gda-connection-execute-command">
              gda_data_model_execute_command()</LINK>
          </LISTITEM>
        </ITEMIZEDLIST>
        <para>
          You can use the first way when you want to invoke only a single command.
          Second way is used to execute several comma-separated sentences. It is recommended
          to use <LINK LINKEND="gda-connection-execute-single-command">
          gda_connection_execute_single_command ()</LINK>. Here you see an
          example:
        </para>
        <PROGRAMLISTINGCO>
          <AREASPEC UNITS="LINECOLUMN">
            <AREA ID="normal-query-1" COORDS="13 1">
            <AREA ID="normal-query-2" COORDS="15 1">
          </AREASPEC>
          <programlisting>
          gboolean
          execute_sql_command (GdaConnection *connection, const gchar * buffer)
          {
            GdaCommand *command;
            GList *list;
            GList *node;
            gboolean errors=FALSE;
          
            GdaDataModel *dm;
          
          
            command = gda_command_new (buffer, GDA_COMMAND_TYPE_SQL, GDA_COMMAND_OPTION_STOP_ON_ERRORS);
            list = gda_connection_execute_command (connection, command, NULL);
            if (list!=NULL)
              for (node=g_list_first(list); node != NULL; node=g_list_next(node))
                {
                  dm=(GdaDataModel *) node->data;
                  if (dm == NULL)
                    {
                      errors=TRUE;
                    }
                  else
                    {
                      show_table (dm);
                      g_object_unref(dm);
                    }
                }
            else
              {
                errors=TRUE;
              }
            gda_command_free (command);
          
            return (errors);
          }
          </programlisting>
          <CALLOUTLIST>
            <CALLOUT AREAREFS="normal-query-1">
              <PARA>
                Executes the query and obtains a list of <LINK LINKEND="data-model">data models</LINK>
              </PARA>
            </CALLOUT>
            <CALLOUT AREAREFS="normal-query-2">
              <PARA>
                Loop for moving through the list of data models. If you use <LINK
                LINKEND="gda-connection-execute-single-command">
                gda_connection_execute_single_command()</LINK>, you should not need to use a loop,
                because this function would return a <LINK LINKEND="data-model">data model</LINK>.
              </PARA>
            </CALLOUT>
          </CALLOUTLIST>
        </PROGRAMLISTINGCO>
      </sect2>
      </sect1>
      
    <sect1 ID="data-model">
      <title>Managing <EMPHASIS>data models</EMPHASIS></title>
      <para>
        Each time we execute a normal query, we will obtain a <LINK
        LINKEND="libgda-GdaDataModel"><EMPHASIS>GdaDataModel
        </EMPHASIS></LINK> object, which is the way to see what the query returned. As
        <LINK
        LINKEND="libgda-GdaDataModel">GdaDataModel</LINK> is an object, we can manage it with <LINK
        LINKEND="libgda-GdaDataModel">GdaDataModel</LINK> class.
      </para>
      <para>
        Before continuing, we must say that it is possible to modify a data model, but as we
        are accessing using &SQL;, it is not recommended to modify it, so modifications on the
        database must be done using &SQL;.
      </para>
      <para>
        Let's see the functions we need:
      </para>
      <ITEMIZEDLIST>
        <LISTITEM>
          <LINK LINKEND="gda-data-model-get-n-rows">gda_data_model_get_n_rows()</LINK>
        </LISTITEM>
        <LISTITEM>
          <LINK LINKEND="gda-data-model-get-n-columns">gda_data_model_get_n_columns()</LINK>
        </LISTITEM>
        <LISTITEM>
          <LINK LINKEND="gda-data-model-describe-column">gda_data_model_describe_column()</LINK>
        </LISTITEM>
        <LISTITEM>
          <LINK LINKEND="gda-data-model-get-column-title">gda_data_model_get_column_title()</LINK>
        </LISTITEM>
        <LISTITEM>
          <LINK LINKEND="gda-data-model-get-column-position">gda_data_model_get_column_position()</LINK>
        </LISTITEM>
        <LISTITEM>
          <LINK LINKEND="gda-data-model-get-row">gda_data_model_get_row()</LINK>
        </LISTITEM>
        <LISTITEM>
          <LINK LINKEND="gda-data-model-get-value-at">gda_data_model_get_value_at()</LINK>
        </LISTITEM>
        <LISTITEM>
          <LINK LINKEND="gda-row-get-value">gda_row_get_value()</LINK>
        </LISTITEM>
      </ITEMIZEDLIST>
      <para>
        This functions are very easy to use, so let's see some clear 
        examples:
      </para>
      <sect2 ID="data-model-table-access">
        <title>Example using direct cell access</title>
        <para>
          This function accesses the data model by directly accessing cells (using
          <LINK LINKEND="gda-data-model-get-value-at">gda_data_model_get_value_at ()
          </LINK>)
        </para>
        <PROGRAMLISTINGCO>
          <AREASPEC UNITS="LINECOLUMN">
            <AREA ID="data-model-1-1" COORDS="8 1">
            <AREA ID="data-model-1-2" COORDS="13 1">
            <AREA ID="data-model-1-3" COORDS="18 1">
          </AREASPEC>
          <programlisting>
          void
          show_table (GdaDataModel * dm)
          {
            gint row_id;
            gint column_id;
            GdaValue *value;
          
            for (column_id = 0; column_id < gda_data_model_get_n_columns (dm);
                 column_id++)
              g_print("%s\t",gda_data_model_get_column_title (dm, column_id));
            g_print("\n");
          
            for (row_id = 0; row_id < gda_data_model_get_n_rows (dm); row_id++)
              {
                for (column_id = 0; column_id < gda_data_model_get_n_columns (dm);
                     column_id++)
                  {
                    value =
                      (GdaValue *) gda_data_model_get_value_at (dm, column_id, row_id);
                    g_print ("%s\t", gda_value_stringify (value));
                  }
                g_print("\n");
              }
          }
          </programlisting>
          <CALLOUTLIST>
            <CALLOUT AREAREFS="data-model-1-1">
              <PARA>
                Loop for writing column names.
              </PARA>
            </CALLOUT>
            <CALLOUT AREAREFS="data-model-1-2">
              <PARA>
                Double loop accessing values using
                <LINK
                LINKEND="gda-data-model-get-value-at">gda_data_model_get_value_at ()
                </LINK>
              </PARA>
            </CALLOUT>
            <CALLOUT AREAREFS="data-model-1-3">
              <PARA>
                Data returned is a <LINK LINKEND="libgda-gda-value">GdaValue</LINK> object.
              </PARA>
            </CALLOUT>
          </CALLOUTLIST>
        </PROGRAMLISTINGCO>
      </sect2>
      <sect2 ID="data-model-row-access">
        <title>Example using row access</title>
        <para>
          This function accesses the data model by accessing rows (using
          <LINK LINKEND="gda-data-model-get-row">gda_data_model_get_row ()
          </LINK> and
          <LINK LINKEND="gda-row-get-value"> gda_row_get_value ()
          </LINK>)
        </para>
        <PROGRAMLISTINGCO>
          <AREASPEC UNITS="LINECOLUMN">
            <AREA ID="data-model-2-1" COORDS="10 1">
            <AREA ID="data-model-2-2" COORDS="15 1">
            <AREA ID="data-model-2-3" COORDS="18 1">
          </AREASPEC>
          <programlisting>
            <ANCHOR ID="show_table2">
          void
          show_table2 (GdaDataModel * dm)
          {
            gint row_id;
            gint column_id;
            GdaValue *value;
            GdaRow *row;
          
            for (column_id = 0; column_id < gda_data_model_get_n_columns (dm);
                 column_id++)
              g_print("%s\t",gda_data_model_get_column_title (dm, column_id));
            g_print("\n");
          
            for (row_id = 0; row_id < gda_data_model_get_n_rows (dm); row_id++)
              {
                row = (GdaRow *) gda_data_model_get_row (dm, row_id);
                for (column_id = 0; column_id < gda_data_model_get_n_columns (dm);
                     column_id++)
                  {
                    value = gda_row_get_value (row, column_id);
                    string=gda_value_stringify (value);
                    g_print ("%s\t", string);
                    gda_value_free(value);
                    g_free(string);
                  }
                g_print ("\n");
              }
          }
          </programlisting>
          <CALLOUTLIST>
            <CALLOUT AREAREFS="data-model-2-1">
              <PARA>
                Loop for writing column names.
              </PARA>
            </CALLOUT>
            <CALLOUT AREAREFS="data-model-2-2">
              <PARA>
                Outer loop obtaining rows using
                <LINK
                LINKEND="gda-data-model-get-row">gda_data_model_get_row ()
                </LINK>
              </PARA>
            </CALLOUT>
            <CALLOUT AREAREFS="data-model-2-3">
              <PARA>
                Inner loop obtaining the value using
                <LINK
                LINKEND="gda-row-get-value">gda_row_get_value ()
                </LINK>. Notice that <LINK
                LINKEND="gda-row-get-value">gda_row_get_value ()</LINK>
                doesn't return a <EMPHASIS>const <LINK
                LINKEND="libgda-gda-value">GdaValue</LINK></EMPHASIS>, so we
                have to free it. 
              </PARA>
            </CALLOUT>
          </CALLOUTLIST>
        </PROGRAMLISTINGCO>
        
      </sect2>
      <sect2 ID="data-model-free">
        <title>Freeing data models</title>
        <para>
          When you finish using data models you must free it, but GdaDataModel class
          does not have a function to do it, so you have to use <EMPHASIS>g_object_unref
          ()</EMPHASIS>.
        </para>
      </sect2>
    </sect1>
    <sect1 ID="gdavalue">
      <title>Managing values</title>
      <para>
        Values returned by functions of managing data are <LINK
        LINKEND="libgda-gda-value">GdaValue</LINK> objects. <LINK
        LINKEND="libgda-gda-value">GdaValue</LINK> class has many functions
        to access data, so we show the most important ones 
        of them:
      </para>
      <ITEMIZEDLIST>
        <LISTITEM>
          <LINK LINKEND="gda-value-free">gda_value_free()</LINK>
        </LISTITEM>
        <LISTITEM>
          <LINK LINKEND="gda-value-is-null">gda_value_is_null()</LINK>
        </LISTITEM>
        <LISTITEM>
          <LINK LINKEND="gda-value-copy">gda_value_copy()</LINK>
        </LISTITEM>
        <LISTITEM>
          <LINK LINKEND="gda-value-compare">gda_value_compare()</LINK>
        </LISTITEM>
        <LISTITEM>
          <LINK LINKEND="gda-value-stringify">gda_value_stringify()</LINK>
        </LISTITEM>
      </ITEMIZEDLIST>
      <para>
        There are many functions to know what is the type of a value and to manage values,
        that can be seen in <LINK
        LINKEND="libgda-gda-value">GdaValue</LINK> class.
      </para>
      <para>
        We will return to the examples about last section to notice some
        important details: 
      </para>
      <PROGRAMLISTINGCO>
        <AREASPEC UNITS="LINECOLUMN">
          <AREA ID="gda-value-1" COORDS="10 1">
          <AREA ID="gda-value-2" COORDS="15 1">
          <AREA ID="gda-value-3" COORDS="18 1">
          <AREA ID="gda-value-4" COORDS="22 1">
        </AREASPEC>
        <programlisting>
        void
        show_table2 (GdaDataModel * dm)
        {
          gint row_id;
          gint column_id;
          GdaValue *value;
          GdaRow *row;
          gchar *string;
        
          for (column_id = 0; column_id < gda_data_model_get_n_columns (dm);
               column_id++)
            g_print("%s\t",gda_data_model_get_column_title (dm, column_id));
          g_print("\n");
        
          for (row_id = 0; row_id < gda_data_model_get_n_rows (dm); row_id++)
            {
              row = (GdaRow *) gda_data_model_get_row (dm, row_id);
              for (column_id = 0; column_id < gda_data_model_get_n_columns (dm);
                   column_id++)
                {
                  value = gda_row_get_value (row, column_id);
                  string=gda_value_stringify (value);
                  g_print ("%s\t", string);
                  gda_value_free(value);
                  g_free(string);
                }
              g_print ("\n");
            }
        }
        </programlisting>
        <CALLOUTLIST>
          <CALLOUT AREAREFS="gda-value-1">
            <PARA>
              Loop for writing column names.
            </PARA>
          </CALLOUT>
          <CALLOUT AREAREFS="gda-value-2">
            <PARA>
              Outer loop obtaining rows using
              <LINK
              LINKEND="gda-data-model-get-row">gda_data_model_get_row ()
              </LINK>
            </PARA>
          </CALLOUT>
          <CALLOUT AREAREFS="gda-value-3">
            <PARA>
              Inner loop obtaining the value using
              <LINK
              LINKEND="gda-row-get-value">gda_row_get_value ()
              </LINK>. Notice that <LINK
              LINKEND="gda-row-get-value">gda_row_get_value ()
              </LINK> doesn't return a
              <EMPHASIS>const <LINK
              LINKEND="libgda-gda-value">GdaValue</LINK></EMPHASIS>, so we
              have to free it. 
            </PARA>
           </CALLOUT>
          <CALLOUT AREAREFS="gda-value-4">
            <PARA>
              We have the difference here. As you can see above, <LINK
              LINKEND="gda-value-stringify">gda_value_stringify ()</LINK> does not return a
              <EMPHASIS>const</EMPHASIS> gchar *, so you have to free it. First way is quite
              attractive but it is not good.
            </PARA>
          </CALLOUT>
        </CALLOUTLIST>
      </PROGRAMLISTINGCO>
    </sect1>
  </chapter>
  <chapter>
    <title>Transactions and batch processes</title>
    <sect1 ID="transactions">
      <title>Managing transactions</title>
      <para>
        The special functions we need to do this are defined in the
        <LINK LINKEND="libgda-GdaTransaction">GdaTransaction</LINK>,
        <LINK LINKEND="libgda-GdaConnection">GdaConnection</LINK> and
        <LINK LINKEND="libgda-gda-command">GdaCommand</LINK>
        classes, and they are:
      </para>
      <ITEMIZEDLIST>
        <LISTITEM>
          <LINK LINKEND="gda-transaction-new">gda_transaction_new ()</LINK>
        </LISTITEM>
        <LISTITEM>
          <LINK LINKEND="gda-connection-begin-transaction">gda_connection_begin_transaction ()</LINK>
        </LISTITEM>
        <LISTITEM>
          <LINK LINKEND="gda-connection-commit-transaction">gda_connection_commit_transaction ()</LINK>
        </LISTITEM>
        <LISTITEM>
          <LINK LINKEND="gda-connection-rollback-transaction">gda_connection_rollback_transaction ()</LINK>
        </LISTITEM>
        <LISTITEM>
          <LINK LINKEND="gda-command-set-transaction">gda_command_set_transaction ()</LINK>
        </LISTITEM>
      </ITEMIZEDLIST>
      <para>
        Things you have to do to manage transactions are:
      </para>
      <ORDEREDLIST NUMERATION="arabic">
        <LISTITEM><para>Create transaction</para></LISTITEM>
        <LISTITEM><para>Link transaction to a connection</para></LISTITEM>
        <LISTITEM>
          <para>For each command you want to execute:</para>
          <ORDEREDLIST NUMERATION="loweralpha">
            <LISTITEM><para>Create command</para></LISTITEM>
            <LISTITEM><para>Link transaction to command</para></LISTITEM>
            <LISTITEM><para>Execute command</para></LISTITEM>
            <LISTITEM><para>Free command</para></LISTITEM>
          </ORDEREDLIST>
        </LISTITEM>
        <LISTITEM><para>Commit o rollback transaction</para></LISTITEM>
        <LISTITEM><para>Free transaction</para></LISTITEM>
      </ORDEREDLIST>
      <para>
        Here you can see an example:
      </para>
      <PROGRAMLISTINGCO>
        <AREASPEC UNITS="LINECOLUMN">
          <AREA ID="transactions-1" COORDS="6 1">
          <AREA ID="transactions-2" COORDS="7 1">
          <AREA ID="transactions-3" COORDS="14 1">
          <AREA ID="transactions-4" COORDS="27 1">
          <AREA ID="transactions-5" COORDS="28 1">
          <AREA ID="transactions-6" COORDS="51 1">
        </AREASPEC>
        <programlisting>
        void process_accounts(GdaConnection *connection)
        {
          GdaTransaction *transaction_one, *transaction_two;
          GdaCommand *command;
        
          transaction_one=gda_transaction_new("accounts1");
          gda_connection_begin_transaction(connection,transaction_one);
        
          command=gda_command_new (
                                   "UPDATE accounts SET balance=balance+50"
                                   "WHERE account_code=456",
                                   GDA_COMMAND_TYPE_SQL,
                                   GDA_COMMAND_OPTION_STOP_ON_ERRORS);
          gda_command_set_transaction(command,transaction_one);
          gda_connection_execute_non_query(connection,command,NULL);
          gda_command_free(command);
        
          command=gda_command_new (
                                   "UPDATE accounts SET balance=balance-50"
                                   "WHERE account_code=12",
                                   GDA_COMMAND_TYPE_SQL,
                                   GDA_COMMAND_OPTION_STOP_ON_ERRORS);
          gda_command_set_transaction(command,transaction_one);
          gda_connection_execute_non_query(connection,command,NULL);
          gda_command_free(command);
        
          gda_connection_commit_transaction(connection,transaction_one);
          g_object_unref(transaction_one);
        
          transaction_two=gda_transaction_new("accounts2");
          gda_connection_begin_transaction(connection,transaction_two);
        
          command=gda_command_new (
                                   "UPDATE accounts SET balance=balance+400"
                                   "WHERE account_code=456",
                                   GDA_COMMAND_TYPE_SQL,
                                   GDA_COMMAND_OPTION_STOP_ON_ERRORS);
          gda_command_set_transaction(command,transaction_two);
          gda_connection_execute_non_query(connection,command,NULL);
          gda_command_free(command);
        
          command=gda_command_new (
                                   "UPDATE accounts SET balance=balance-400"
                                   "WHERE account_code=12",
                                   GDA_COMMAND_TYPE_SQL,
                                   GDA_COMMAND_OPTION_STOP_ON_ERRORS);
          gda_command_set_transaction(command,transaction_two);
          gda_connection_execute_non_query(connection,command,NULL);
          gda_command_free(command);
        
          gda_connection_rollback_transaction(connection,transaction_two);
          g_object_unref(transaction_one);
        
          execute_sql_command(connection,"SELECT * FROM accounts");
        }
        </programlisting>
        <CALLOUTLIST>
          <CALLOUT AREAREFS="transactions-1">
            <PARA>
              Creates first transaction.
            </PARA>
          </CALLOUT>
          <CALLOUT AREAREFS="transactions-2">
            <PARA>
              Links it to connection.
            </PARA>
          </CALLOUT>
          <CALLOUT AREAREFS="transactions-3">
            <PARA>
              Links command to transaction.
            </PARA>
          </CALLOUT>
          <CALLOUT AREAREFS="transactions-4">
            <PARA>
              Makes commit on transaction.
            </PARA>
          </CALLOUT>
          <CALLOUT AREAREFS="transactions-5">
            <PARA>
              Frees transaction.
            </PARA>
          </CALLOUT>
          <CALLOUT AREAREFS="transactions-6">
            <PARA>
              Makes rollback on second transaction.
            </PARA>
          </CALLOUT>
        </CALLOUTLIST>
      </PROGRAMLISTINGCO>
    </sect1><!--
    <sect1 ID="batch">
      <title>Batch</title>
      
      <para>
      Batch processes are supposed to be also a simple way to manage transactions,
      but I could not work on it because it is not included in the library.
      </para>
      
    </sect1>
      -->
  </chapter>
  <chapter ID="managing-errors">
    <title>Managing errors</title>
    <para>
      You can manage errors with <LINK
      LINKEND="libgda-GdaError">GdaError</LINK> class and obtain them with
      function <LINK
      LINKEND="gda-connection-get-errors"><EMPHASIS>gda_connection_get_errors()
      </EMPHASIS></LINK> so let's see them and an example: 
    </para>
    <para>
      Here you see the functions to manage errors:
    </para>
    <ITEMIZEDLIST>
      <LISTITEM>
        <LINK LINKEND="gda-error-get-description">gda_error_get_description()</LINK>
      </LISTITEM>
      <LISTITEM>
        <LINK LINKEND="gda-error-get-number">gda_error_get_number()</LINK>
      </LISTITEM>
      <LISTITEM>
        <LINK LINKEND="gda-error-get-source">gda_error_get_source()</LINK>
      </LISTITEM>
      <LISTITEM>
        <LINK LINKEND="gda-error-get-sqlstate">gda_error_get_sqlstate()</LINK>
      </LISTITEM>
    </ITEMIZEDLIST>
    <para>
      Here you can see an example of using this:
    </para>
    <PROGRAMLISTINGCO>
      <AREASPEC UNITS="LINECOLUMN">
        <AREA ID="errors-1" COORDS="8 1">
        <AREA ID="errors-2" COORDS="10 1">
      </AREASPEC>
      <programlisting>
      gboolean
      get_errors (GdaConnection *connection)
      {
        GList *list;
        GList *node;
        GdaError *error;
      
        list = (GList *) gda_connection_get_errors (connection);
      
        for (node = g_list_first (list); node != NULL; node = g_list_next (node))
          {
            error = (GdaError *) node->data;
            g_print ("Error no: %d\t", gda_error_get_number (error));
            g_print ("desc: %s\t", gda_error_get_description (error));
            g_print ("source: %s\t", gda_error_get_source (error));
            g_print ("sqlstate: %s\n", gda_error_get_sqlstate (error));
          }
      }
      </programlisting>
      <CALLOUTLIST>
        <CALLOUT AREAREFS="errors-1">
          <PARA>
            Obtains errors list.
          </PARA>
        </CALLOUT>
        <CALLOUT AREAREFS="errors-2">
          <PARA>
            Loop for getting error information.
          </PARA>
        </CALLOUT>
      </CALLOUTLIST>
    </PROGRAMLISTINGCO>
  </chapter>
  <chapter ID="main_example">
    <title>Full example</title>
    <PROGRAMLISTING>
<inlinegraphic entityref="fullexample"></inlinegraphic>
    </PROGRAMLISTING>
  </chapter>
  <chapter ID="migration">
    <title>Some formulae for migration from old version</title>
    <sect1 ID="migration-compilation">
      <title>Compiling and initialising</title>
      <para>
        To <LINK LINKEND="compiling">compile</LINK> you do not need to link
        with many libraries and configure directories of headers files, only
        capture the output of <EMPHASIS>pkg-config</EMPHASIS> as follows:
        <PROGRAMLISTING>
          <SYSTEMITEM CLASS="prompt">$</SYSTEMITEM> <USERINPUT> gcc -o main `pkg-config --cflags --libs libgda` main.c</USERINPUT>
        </PROGRAMLISTING>
      </para>
      <para>
        Further more, you only need to include one <LINK
        LINKEND="installation-development">headers file</LINK> and it is:
        <programlisting>
    #include &lt;libgda/libgda.h&gt;
        </programlisting>
      </para>
      <para>
        As in the old version, you need to call <LINK
        LINKEND="gda-init"><EMPHASIS>gda_init()</EMPHASIS></LINK> to
        <LINK LINKEND="initializing">initialise</LINK> the library:
        <programlisting>
          gda_init ("TestGDA", "0.1", argc, argv);
        </programlisting>
      </para>
    </sect1>
    <sect1 ID="migration-configuration">
      <title>Configuration and connections</title>
      <para>
        If you before created connections directly to data sources, you
        will now use a <EMPHASIS>connections pool</EMPHASIS> and will be
        necessary to <LINK LINKEND="installation-client">create the data
        source</LINK> because you create connection using the data source
        identifier.
      </para>
      <sect2 ID="migration-data-sources">
        <title>Creating data sources</title>
        <para>
          You have two ways to do this, one of them is creating them using
          some <LINK LINKEND="installation-client">utility of
          &GNOMEDB;</LINK> or using <LINK
          LINKEND="data-sources-API-functions">API functions</LINK>.
          Remember the little <LINK
          LINKEND="data-sources-API-functions">bug</LINK>.
        </para>
        <para>
          There is no problem about calling several times to this
          function because if you save an existing data source, it
          is replaced, so it could be advisable<footnote>But you must think
          of security if you distribute the source code because people would see
          the passwords of your databases.</footnote> to save the data source
          each time you want to create the connection.
        </para>
      </sect2>
      <sect2 ID="migration-connections">
        <title>Creating connections</title>
        <para>
          You can see <LINK LINKEND="connections">how to create a
          connection</LINK> easily in a chapter above.
        </para>
      </sect2>
    </sect1>
    <sect1 ID="migration-executing-commands">
      <title>Executing commands</title>
      <sect2 ID="migration-creating-commands">
        <title>Creating commands</title>
        <para>
          It can be made, more or less, as in the old version, using
          <LINK LINKEND="gda-command-new">gda_command_new()</LINK>, but
          now, this function needs a few parameters and, in this version,
          you do not link a command to a connection, so you execute a
          command in a connection as we'll see <LINK
          LINKEND="migration-executing-non-queries">later</LINK>. You
          can see how to create commands and examples about this <LINK
          LINKEND="building-commands">here</LINK>.
        </para>
      </sect2>
      <sect2 ID="migration-executing-non-queries">
        <title>Executing <EMPHASIS>non queries</EMPHASIS></title>
        <para>
          <EMPHASIS>Non queries</EMPHASIS> are queries that do not return
          data, as insertions, deletions, and so on. The function we use is
          <LINK
          LINKEND="gda-connection-execute-non-query">gda_connection_execute_non_query
          ()</LINK> and returns the number of affected tuples or -1 in case
          of error. <LINK LINKEND="making-queries">Here</LINK> you see an
          example.
        </para>
        <para>
          It is better not to execute more than one &SQL; sentence for each
          command because the result can be unexpected.
        </para>
      </sect2>
      <sect2 ID="migration-executing-normal-queries">
        <title>Executing normal queries</title>
        <para>
          A normal query is a query that return data. This is made as a
          <LINK LINKEND="libgda-GdaDataModel">data model</LINK>, analogous
          to <EMPHASIS>GdaRecordset</EMPHASIS> in the old
          version<footnote>Now you have a <LINK
          LINKEND="libgda-provider-recordset">GdaRecordset</LINK> class,
          but it is not recommended.</footnote>.
        </para>
        <para>
          As you can see in the following example, the function we use to
          obtain data from a &SQL; sentence is <LINK
          LINKEND="gda-connection-execute-single-command">gda_connection_execute_single_command
          ()</LINK> and needs the parameters of <LINK
          LINKEND="migration-executing-non-queries">non queries</LINK>. The
          difference is that now the function returns the <LINK
          LINKEND="libgda-GdaDataModel">data model</LINK> or
          <EMPHASIS>NULL</EMPHASIS> in case of error.
        </para>
        <para>
          As in the case of <LINK
          INKEND="gda-connection-execute-non-query">non queries</LINK>, you
          must not use several semicolon-separated sentences, because you
          have a special function to do this<footnote><LINK
          LINKEND="gda-connection-execute-command">gda_connection_execute_command
          ()</LINK></footnote>, but it is not recommended.
        </para>
      </sect2>
    </sect1>
    <sect1>
      <title>Managing data</title>
      <para>
        As we have said before, data is obtained as <LINK
        LINKEND="libgda-GdaDataModel">data models</LINK>. We can consider
        it as a representation of the table.
      </para>
      <para>
        We can access the table at <LINK
        LINKEND="data-model-row-access">row level</LINK> or <LINK
        LINKEND="data-model-table-access">table level</LINK>. We will focus
        on <LINK LINKEND="data-model-row-access">row level</LINK> because
        it is the most similar to the old version.
      </para>
      <para>
        As you can see in the <LINK
        LINKEND="data-model-row-access">example</LINK>, the access is made
        with the <EMPHASIS>C</EMPHASIS> style using a
        <literal>for</literal> to obtain data from rows and columns.
      </para>
      <para>
        We talk about <LINK LINKEND="data-model-table-access">table
        access</LINK> only saying that the access is made in a very similar
        way. The only difference is that <LINK
        LINKEND="gda-data-model-get-value-at">gda_data_model_get_value_at
        ()</LINK> returns a <literal>const</literal> and we have not to
        free it.
      </para>
      <sect2>
        <title>Something important about data models</title>
        <para>
          As you can see viewing <LINK
          LINKEND="libgda-GdaDataModel">GdaDataModel</LINK> class, it has
          not a <LINK LINKEND="data-model-free">free</LINK> method, so we
          have to free it using <literal>g_object_unref</literal>.
        </para>
        <para>
          Theoretically, you could modify data models and dump changes over
          the database, but it is not recommended because you might make
          changes using &SQL;, so we consider data models not to be
          modifiable.
        </para>
      <sect2>
        <title>Accessing directly to columns</title>
        <para>
          There is not exist a function to access columns directly using
          the column name, but you can obtain its index using <LINK
          LINKEND="gda-data-model-get-column-position">gda_data_model_get_column_position
          ()</LINK>, as you can see in this example:
          <PROGRAMLISTING>
          value=gda_row_get_value(row,
              gda_data_model_get_column_position(data_model,"id_product"));
          </PROGRAMLISTING>
        </para>
      </sect2>
    </sect1>
    <sect1>
      <title>Managing errors</title>
      <para>
        There is a function very similar to the last version and you can
        see a very clear <LINK LINKEND="managing-errors">example</LINK> in
        the <LINK LINKEND="managing-errors">Managing errors section</LINK>.
      </para>
    </sect1>
    <sect1>
      <title>Managing transactions</title>
      <para>
        In the old version, to manage transactions was more simple but less
        powerful. In the new version it is supposed that we can launch
        several transactions over the same connection but some database
        drivers, as	&PGSQL;, do not implement it, so we do not recommend
        it. If you want to launch several transactions, you must open
        several connections, but you can do it over the same
        <EMPHASIS>pool</EMPHASIS>. You can see a clear <LINK
        LINKEND="transactions">example</LINK> in the <LINK
        LINKEND="transactions">Transactions section</LINK>.
      </para>
    </sect1>
  </chapter>
  <chapter id="libgda-api">
    <title>&LIBGDA; API Reference</title>
    <para>
      The following sections describe the API available for &GDA; applications.
    </para>
    &libgda-init;
    &libgda-batch;
    &libgda-client;
    &libgda-command;
    &libgda-config;
    &libgda-connection;
    &libgda-data-model-array;
    &libgda-data-model-hash;
    &libgda-data-model-list;
    &libgda-data-model;
    &libgda-error;
    &libgda-export;
    &libgda-field;
    &libgda-log;
    &libgda-parameter;
    &libgda-quark-list;
    &libgda-row;
    &libgda-select;
    &libgda-table;
    &libgda-transaction;
    &libgda-util;
    &libgda-value;
    &libgda-xml-connection;
    &libgda-xml-database;
    &libgda-xml-document;
  </chapter>

  <chapter id="libgda-providers">
    <title>GDA Providers</title>
    <sect1 id="libgda-provider-introduction">
    <title>Introduction</title>
    <para>
       For each different data source supported by &LIBGDA; there must be a
       GObject that implements the virtual methods defined in &GDASERVERPROVIDER;
       class.
    </para>
    <para>
       Providers must also create their own object to implement the virtual
       methods defined in &GDADATAMODEL; or one of
       its subclasses (currently &GDADATAMODELARRAY; and &GDADATAMODELHASH;) 
       to support recordsets.
    </para>
    <para>
      Since &LIBGDA; itself is developed in the C language, and that most
      providers are also implemented in that language, the &LIBGDA; library
      itself contains a set of helper classes and functions to guide you
      in the addition of a new provider to the GDA framework.
    </para>
    </sect1>
    <sect1 id="libgda-provider-class">
      <title>The GdaServerProvider class</title>
      <para>
	The &GDASERVERPROVIDER; is the class you should implement for adding
	a new provider. This class is just a typical GObject-based class,
	with a set of virtual methods, that are the ones that you must
	implement. These virtual methods are declared in the class structure,
	in the <filename>gda-server-provider.h</filename> file. They are
	explained in detail in the following subsections.
      </para>
      <sect2 id="libgda-provider-open-connection">
	<title>open_connection</title>
	   <para>
	   Sets up the connection to the database back-end using the parameters
	   received as arguments and returns a boolean TRUE if the connection
	   is successfully established, otherwise FALSE.
	</para>
      </sect2>
	<sect2 id="libgda-provider-close-connection">
	<title>close_connection</title>
	<para>
	  Frees the resources allocated for the connection and returns TRUE
	  if everything is ok
	</para>
      </sect2>
      <sect2 id="libgda-provider-get-database">
	<title>get_database</title>
	<para>
	  Returns the name of the currently open database for a given
	  connection.
	</para>
      </sect2>
      <sect2 id="libgda-provider-change-database">
	<title>change_database</title>
	<para>
	  Change the database being used in the active connection.
	</para>
      </sect2>
      <sect2 id="libgda-provider-create-database">
	<title>create_database</title>
	<para>
	  Creates a new database whose name is received in a parameter.	
	</para>
      </sect2>
      <sect2 id="libgda-provider-drop-database">
	<title>drop_database</title>
	<para>
	  Drops an existing database whose name is received in a parameter.
	</para>
      </sect2>
      <sect2 id="libgda-provider-execute-command">
	<title>execute_command</title>
	<para>
	  Executes a command and returns a GList of &GDADATAMODEL; with the
	  results.
	</para>
      </sect2>
      <sect2 id="libgda-provider-begin-transaction">
	<title>begin_transaction</title>
	<para>
	  Initiates a transaction if the DB back-end supports transactions.
	</para>
      </sect2>
      <sect2 id="libgda-provider-commit-transaction">
	<title>commit_transaction</title>
	<para>
	  Commits a transaction if the DB back-end supports transactions.
	</para>
      </sect2>
      <sect2 id="libgda-provider-rollback-transaction">
	<title>rollback_transaction</title>
	<para>
	  Rollback a transaction if the DB back-end supports transactions.
	</para>
      </sect2>
      <sect2 id="libgda-provider-supports">
	<title>supports</title>
	<para>
	  Tests if a given feature is supported by the provider and the
	  DB back-end. You can view the list of features in <filename>
	  gda-connection.h</filename>, enumeration GdaConnectionFeature.
	</para>
      </sect2>
      <sect2 id="libgda-provider-get-schema">
	<title>get_schema</title>
	<para>
	  Returns a &GDADATAMODEL; with the schema information requested.
	  You can view the list of features in <filename>
	  gda-connection.h</filename>, enumeration GdaConnectionSchema.
	  This schema information is what describes the objects in the
	  database, and is the way applications can manage the structure
	  of several database systems without knowing anything about
	  their specific way of retrieving this information.
	</para>
	<para>
	  The <function>get_schema</function> virtual method gets a
	  <type>GdaConnectionSchema</type> argument, which describes
	  the kind of schema the client making the call is interested
	  in, along with a <type>GdaParameterList</type> argument,
	  which contains the list of arguments sent by the user to
	  explicitly provide more information for the search.
	</para>
	<para>
	  The information to be returned for each schema, along with
	  the supported parameters, is described in the following table.
	</para>
	<table frame="all">
	  <title>Standard Schema and supported parameters</title>
	  <tgroup cols="4" colsep="1" rowsep="1" align="justify">
	    <colspec colname="c1">
	    <colspec colname="c2">
	    <colspec colname="c3">
	    <colspec colname="c4">
	    <thead>
	      <row>
		<entry>Object type</entry>
		<entry>GDA identifier</entry>
		<entry>Supported Parameters</entry>
		<entry>Returned fields</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry>Tables</entry>
		<entry><parameter>GDA_CONNECTION_SCHEMA_TABLES</parameter></entry>
		<entry>"name" (name of table, optional)</entry>
		<entry>name, owner, comments, SQL definition
	      </row>
	      <row>
		<entry>Tables' parents</entry>
		<entry><parameter>GDA_CONNECTION_SCHEMA_PARENT_TABLES</parameter></entry>
		<entry>"name" (name of table, optional)</entry>
		<entry>name, order of inheritance</entry>
	      </row>
	      <row>
		<entry>Views</entry>
		<entry><parameter>GDA_CONNECTION_SCHEMA_VIEWS</parameter></entry>
		<entry>"name" (name of view, optional)</entry>
		<entry>name, owner, comments, SQL definition</entry>
	      </row>
	      <row>
		<entry>Table (or view) fields</entry>
		<entry><parameter>GDA_CONNECTION_SCHEMA_FIELDS</parameter></entry>
		<entry>"name" (name of table (or view), required)</entry>
		<entry>name, type, size, scale, not null?, primary key?, unique index?, references</entry>
	      </row>
	      <row>
		<entry>Sequences</entry>
		<entry><parameter>GDA_CONNECTION_SCHEMA_SEQUENCES</parameter></entry>
		<entry>"name" (name of sequence, optional)</entry>
		<entry>name, owner, comments, SQL definition</entry>
	      </row>
	      <row>
		<entry>Procedures</entry>
		<entry><parameter>GDA_CONNECTION_SCHEMA_PROCEDURES</parameter></entry>
		<entry>"name" (name of procedure, optional)</entry>
		<entry>name, owner, comments, return type, number of arguments, SQL definition</entry>
	      </row>
	      <row>
		<entry>Procedure parameters</entry>
		<entry><parameter>GDA_CONNECTION_SCHEMA_PROCEDURE_PARAMS</parameter></entry>
		<entry>"name" (name of procedure, required)</entry>
		<entry>name, usage (in, out, inout), type</entry>
	      </row>
	      <row>
		<entry>Aggregates</entry>
		<entry><parameter>GDA_CONNECTION_SCHEMA_AGGREGATES</parameter></entry>
		<entry>"name" (name of aggregate, optional)</entry>
		<entry>name, owner, comments, return type, in type, SQL definition</entry>
	      </row>
	      <row>
		<entry>Types</entry>
		<entry><parameter>GDA_CONNECTION_SCHEMA_TYPES</parameter></entry>
		<entry>"name" (name of type, optional)</entry>
		<entry>name, owner, comments, GDA type</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>
      </sect2>
    </sect1>
    <sect1 id="libgda-provider-recordset">
      <title>The recordset class</title>
      <para>
	You have to extend one of &GDADATAMODEL;, &GDADATAMODELARRAY; or
	&GDADATAMODELHASH;. The easiest to extend are the last two. They both
	derive from &GDADATAMODEL;.
      </para>
      <para>
	Here is the list of methods that you have to override. If you use
	&GDADATAMODELHASH;, you don't need to override 
	append_row.
      </para>
      <itemizedlist>
	<listitem>
	  <para>get_n_rows</para>
	  <para>
	    Returns the number of rows in the data model. If the provider
	    can know in advance the number of rows the database server has
	    returned, this function should just return that, and not
	    retrieve any data. On the other hand, if it can't it should
	    either retrieve all data, or move to the last record in the
	    recordset and retrieve the row number, if the underlying
	    data source allows it.
	  </para>
	</listitem>
	<listitem>
	  <para>get_n_columns</para>
	  <para>
	    Returns the number of columns in the data model.
	  </para>
	</listitem>
	<listitem>
	  <para>describe_column</para>
	  <para>
	    Returns information about a given column, in the form of
	    a <xref linkend="GdaFieldAttributes">GdaFieldAttributes</xref>.
	  </para>
	</listitem>
	<listitem>
	  <para>get_row</para>
	  <para>
	    Retrieves a row from the data model. This function is very important
	    for the implementation of editable data models. What this function
	    returns is a <xref linkend"GdaRow">GdaRow</xref>, which providers
	    should uniquely identify (via <xref linkend="gda-row-set-id">gda_row_set_id</xref>).
	    This is needed so that later on, client applications can use the same
	    <xref linkend="GdaRow">GdaRow</xref> returned by this method in
	    the <function>update_row</function> and <function>remove_row</function>
	    methods.
	  </para>
	</listitem>
	<listitem>
	  <para>get_value_at</para>
	  <para>
	    Returns the value stored in a given cell of the data model.
	  </para>
	</listitem>
	<listitem>
	  <para>is_editable</para>
	  <para>
	    Checks whether the data model can be modified or not. If the provider
	    supports the edition of data models, it should return TRUE in this
	    function. If it doesn't (for instance, because it can't uniquely identify
	    rows in the data model), it should return FALSE.
	  </para>
	  <para>
	    Before a data model can be edited, client applications must call the
	    <xref linkend="gda-data-model-begin-edit">gda_data_model_begin_edit</xref>
	    function, which emits the "begin_edit" signal on the
	    <xref linkend="GdaDataModel">GdaDataModel</xref> class. So, providers
	    should connect to this signal to be informed when the data model
	    starts being editing. In the callback connected to that signal,
	    it should start a transaction, for instance.
	  </para>
	  <para>
	    In a similar way, there are 2 other signals that provider's data model
	    implementations should pay attention to. Those are "end_edit" and
	    "cancel_edit". In "end_edit", if all went ok, providers should
	    COMMIT the transaction started in "begin_edit". In "cancel_edit",
	    a ROLLBACK should be made.
	  </para>
	</listitem>
	<listitem>
	  <para>append_row</para>
	  <para>
	    Appends a row to the data model. Usually, this means, in the provider,
	    executing an INSERT SQL command on the table being read by the
	    data model.
	  </para>
	</listitem>
	<listitem>
	  <para>update_row</para>
	  <para>
	    Updates an existing row in the data model. The row should have been
	    uniquely identified in the provider code, as explained for the
	    get_row method.
	  </para>
	</listitem>
	<listitem>
	  <para>remove_row</para>
	  <para>
	    Removes a row from the data model. Usually, this means, in the provider,
	    executing a DELETE SQL command on the table being read by the data model.
	    The row should have been
	    uniquely identified in the provider code, as explained for the
	    get_row method.
	  </para>
	</listitem>
      </itemizedlist>
    </sect1>
    &libgda-server-provider;
  </chapter>

  <chapter id="libgda-xql">
    <title>XML Queries</title>
    <para>
    </para>
    &libgda-xql-atom;
    &libgda-xql-bin;
    &libgda-xql-column;
    &libgda-xql-const;
    &libgda-xql-delete;
    &libgda-xql-dml;
    &libgda-xql-dual;
    &libgda-xql-field;
    &libgda-xql-func;
    &libgda-xql-insert;
    &libgda-xql-item;
    &libgda-xql-join;
    &libgda-xql-list;
    &libgda-xql-query;
    &libgda-xql-select;
    &libgda-xql-stack;
    &libgda-xql-target;
    &libgda-xql-update;
    &libgda-xql-utils;
    &libgda-xql-value;
    &libgda-xql-valueref;
  </chapter>

  <chapter id="libgda-reports">
    <title>&GDA; Report Engine</title>
    <para>
    </para>
    &libgda-report-types;
    &libgda-report-document;
  </chapter>
  
  &fdl-appendix;
</book>

