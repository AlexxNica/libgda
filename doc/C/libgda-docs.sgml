<!doctype book PUBLIC "-//Davenport//DTD DocBook V3.0//EN" [

<!ENTITY LIBGDA          "<application>libgda</application>">
<!ENTITY GNOMEDB         "<application>GNOME-DB</application>">
<!ENTITY API             "<acronym>API</acronym>">
<!ENTITY DBMS            "<acronym>DBMS</acronym>">
<!ENTITY DSN             "<acronym>DSN</acronym>">
<!ENTITY ODBC            "<acronym>ODBC</acronym>">
<!ENTITY GDA             "<acronym>GDA</acronym>">
<!ENTITY LDAP            "<acronym>LDAP</acronym>">
<!ENTITY CORBA           "<acronym>CORBA</acronym>">
<!ENTITY IDL             "<acronym>IDL</acronym>">
<!ENTITY ORB             "<acronym>ORB</acronym>">
<!ENTITY SQL             "<acronym>SQL</acronym>">
<!ENTITY RPM             "<acronym>RPM</acronym>">
<!ENTITY XML             "<acronym>XML</acronym>">
<!ENTITY PGSQL           "<application>PostgreSQL</application>">
<!ENTITY MYSQL           "<application>MySQL</application>">
<!ENTITY ORAC            "<application>Oracle</application>">
<!ENTITY INTERB          "<application>Interbase</application>">
<!ENTITY SYBASE          "<application>Sybase</application>">
<!ENTITY MSACC           "<application>MS Access</application>">
<!ENTITY INFOR           "<application>Informix</application>">
<!ENTITY GDASERVERPROVIDER "<xref linkend='libgda-GdaServerProvider'>">
<!ENTITY GDADATAMODEL    "<xref linkend='libgda-GdaDataModel'>">
<!ENTITY GDADATAMODELARRAY "<xref linkend='libgda-GdaDataModelArray'>">
<!ENTITY GDADATAMODELHASH "<xref linkend='libgda-GdaDataModelHash'>">
<!ENTITY libgda-batch SYSTEM "sgml/gda-batch.sgml">
<!ENTITY libgda-client SYSTEM "sgml/gda-client.sgml">
<!ENTITY libgda-command SYSTEM "sgml/gda-command.sgml">
<!ENTITY libgda-config SYSTEM "sgml/gda-config.sgml">
<!ENTITY libgda-connection SYSTEM "sgml/gda-connection.sgml">
<!ENTITY libgda-data-model-array SYSTEM "sgml/gda-data-model-array.sgml">
<!ENTITY libgda-data-model-hash SYSTEM "sgml/gda-data-model-hash.sgml">
<!ENTITY libgda-data-model-list SYSTEM "sgml/gda-data-model-list.sgml">
<!ENTITY libgda-data-model SYSTEM "sgml/gda-data-model.sgml">
<!ENTITY libgda-error SYSTEM "sgml/gda-error.sgml">
<!ENTITY libgda-export SYSTEM "sgml/gda-export.sgml">
<!ENTITY libgda-field SYSTEM "sgml/gda-field.sgml">
<!ENTITY libgda-init SYSTEM "sgml/libgda.sgml">
<!ENTITY libgda-log SYSTEM "sgml/gda-log.sgml">
<!ENTITY libgda-parameter SYSTEM "sgml/gda-parameter.sgml">
<!ENTITY libgda-quark-list SYSTEM "sgml/gda-quark-list.sgml">
<!ENTITY libgda-row SYSTEM "sgml/gda-row.sgml">
<!ENTITY libgda-select SYSTEM "sgml/gda-select.sgml">
<!ENTITY libgda-server-provider SYSTEM "sgml/gda-server-provider.sgml">
<!ENTITY libgda-table SYSTEM "sgml/gda-table.sgml">
<!ENTITY libgda-transaction SYSTEM "sgml/gda-transaction.sgml">
<!ENTITY libgda-util SYSTEM "sgml/gda-util.sgml">
<!ENTITY libgda-value SYSTEM "sgml/gda-value.sgml">
<!ENTITY libgda-xml-connection SYSTEM "sgml/gda-xml-connection.sgml">
<!ENTITY libgda-xml-database SYSTEM "sgml/gda-xml-database.sgml">
<!ENTITY libgda-xml-document SYSTEM "sgml/gda-xml-document.sgml">
<!ENTITY libgda-xql-atom SYSTEM "sgml/gda-xql-atom.sgml">
<!ENTITY libgda-xql-bin SYSTEM "sgml/gda-xql-bin.sgml">
<!ENTITY libgda-xql-column SYSTEM "sgml/gda-xql-column.sgml">
<!ENTITY libgda-xql-const SYSTEM "sgml/gda-xql-const.sgml">
<!ENTITY libgda-xql-delete SYSTEM "sgml/gda-xql-delete.sgml">
<!ENTITY libgda-xql-dml SYSTEM "sgml/gda-xql-dml.sgml">
<!ENTITY libgda-xql-dual SYSTEM "sgml/gda-xql-dual.sgml">
<!ENTITY libgda-xql-field SYSTEM "sgml/gda-xql-field.sgml">
<!ENTITY libgda-xql-func SYSTEM "sgml/gda-xql-func.sgml">
<!ENTITY libgda-xql-insert SYSTEM "sgml/gda-xql-insert.sgml">
<!ENTITY libgda-xql-item SYSTEM "sgml/gda-xql-item.sgml">
<!ENTITY libgda-xql-join SYSTEM "sgml/gda-xql-join.sgml">
<!ENTITY libgda-xql-list SYSTEM "sgml/gda-xql-list.sgml">
<!ENTITY libgda-xql-query SYSTEM "sgml/gda-xql-query.sgml">
<!ENTITY libgda-xql-select SYSTEM "sgml/gda-xql-select.sgml">
<!ENTITY libgda-xql-stack SYSTEM "sgml/gda-xql-stack.sgml">
<!ENTITY libgda-xql-target SYSTEM "sgml/gda-xql-target.sgml">
<!ENTITY libgda-xql-update SYSTEM "sgml/gda-xql-update.sgml">
<!ENTITY libgda-xql-utils SYSTEM "sgml/gda-xql-utils.sgml">
<!ENTITY libgda-xql-value SYSTEM "sgml/gda-xql-value.sgml">
<!ENTITY libgda-xql-valueref SYSTEM "sgml/gda-xql-valueref.sgml">
<!ENTITY libgda-report-types SYSTEM "sgml/gda-report-types.sgml">
<!ENTITY libgda-report-document SYSTEM "sgml/gda-report-document.sgml">
<!ENTITY fdl-appendix SYSTEM "fdl-appendix.sgml">
]>

<book id="index">
  <bookinfo>
    <title>GNOME Data Access manual</title>
    <authorgroup>
      <author>
        <firstname>Michael</firstname>
        <surname>Lausch</surname>
        <affiliation>
          <address><email>michael.lausch@1012surf.net</email></address>
        </affiliation>
      </author>
      <author>
        <firstname>Rodrigo</firstname>
        <surname>Moya</surname>
        <affiliation>
          <address><email>rodrigo@gnome-db.org</email></address>
        </affiliation>
      </author>
      <author>
        <firstname>Vivien</firstname>
        <surname>Malerba</surname>
        <affiliation>
          <address><email>malerba@linuxave.net</email></address>
        </affiliation>
      </author>
      <author role="clean up">
	<firstname>Sean</firstname>
	<surname>Allen</surname>
	<affiliation>
	  <address><email>zeroone@worldonline.co.za</email></address>
	</affiliation>
	<contrib>GDP compliancy, FDL, added markup, English and syntax
        </contrib>
      </author>
    </authorgroup>
    <date>1999 February</date>
    <copyright>
      <year>1999-2002</year>
      <holder>The GNOME Foundation</holder>
    </copyright>
    <abstract>
      <para>
        GNOME Data Access (&GDA;) is an architecture whose 
        purpose is to provide universal access to many different kinds and
        types of data sources. This goes from traditional relational database
        systems, to any imaginable kind of data source such as a mail server,
        a &LDAP; directory...
      </para>
      <para>
        This universality is obtained through the use of
        an easily extensible plugin system as the mechanism for
	communication between the different components in the architecture.
      </para>
    </abstract>
    <legalnotice id="legalnotice">
      <para>
        Permission is granted to copy, distribute and/or modify this document
        under the terms of the <link linkend="fdl"><citetitle>GNU
        Free Documentation License</citetitle></link>, Version 1.1 or any later
        version published by the Free Software Foundation with no Invariant
        Sections, no Front-Cover Texts, and no Back-Cover Texts.  A copy of the
        license can be found in <xref linkend="fdl">.
      </para>
      <para>
        Many of the names used by companies to distinguish their products and
        services are claimed as trademarks. Where those names appear in any
        GNOME documentation, and those trademarks are made aware to the members
        of the GNOME Documentation Project, the names have been printed in caps
        or initial caps.
      </para>
    </legalnotice>
  </bookinfo>

  <chapter id="introduction">
    <title>Introduction</title>
    <para>
      &ODBC; and &SQL; are established standards. The problem is, that &ODBC;
      doesn't specify the wire protocol and for some databases no &ODBC; driver
      exists. You might use <acronym>RPC</acronym>, <acronym>TCP/IP</acronym>,
      or shared memory and signals to pass the request from the client to the
      server. So you have to use the database specific &ODBC; library. This 
      library might not be available for the <acronym>CPU</acronym> or 
      operating system on which the client is running. 
    </para>
    <para>
      &SQL; itself is also not standardized enough, so that source
      compatibility can not be assured for all database servers. And for some
      sort of servers, &SQL; is not even feasable (think about &LDAP;).
    </para>
    <para>
      &GDA; tries to tackle the &ODBC; problem and help you with the &SQL;
      problem. It's a sort of middleware (or can be blown up to be a middleware
      layer) to access different data sources. It offers a high level view of
      data sources and has some places where you can plug in low level access
      to the database for special tasks.
    </para>
    <para>
      GNOME Data Access (&GDA;) is defined as a set of plugin interfaces.
      The level of abstraction provided by &GDA; makes it possible to access
      any kind of data source, provided that a plugin implementing 
      those interfaces and accessing this particular data source is
      written.
    </para>
    <para>
      It offers a wrapper around the database internals, thus making it easier
      for programmers to make use of all the power provided by many RDBMS without
      even knowing about it. It comes along with a library, for both
      clients and servers, as a C implementation of this architecture. This level of
      abstraction would make possible to, at a later time, change all the
      internals without having to modify applications using the libraries.
    </para>
    <para>
      Along with these libraries (and associated header files and language 
      bindings for development), &LIBGDA; includes several tools and utilities
      to help you with the task of developing applications based on &LIBGDA;,
      as well as for automating some database-related tasks.
    </para>
    <para>
      &LIBGDA; is implemented for <systemitem class="osname">UNIX
      </systemitem>-like operating systems (including <systemitem 
      class="osname">Linux</systemitem>), and does not depend on other 
      libraries apart from  <systemitem class="resource">libxml2</systemitem> and 
      <systemitem class="resource">Glib</systemitem>, which makes it a very
      lightweight system also ideal for applications to be run on 
      hardware-limited systems. It was once part of the &GNOMEDB; project, and
      is still used as the basis for it, but it's been separated from it to
      remove all GNOME dependencies and thus allow non-GNOME applications to
      be developed based on it.
    </para>
  </chapter>
  
  <chapter id="architecture">
    <title>&LIBGDA; architecture</title>
    <para>
      &LIBGDA; is composed of three independant layers. The lower level is
      covered by the &GDA; providers, which are plugins whose task is
      to map the <acronym>RDBMS</acronym>-specific &API; to the &GDA; model.
      That is, they are objects implementing the &GDA; interfaces.
    </para>
    <para>
      Then, in a midlle layer, are the client libraries: an easy-to-use and
      full featured library which offers access to all the architecure,
      also including several utility functions to help you on the development
      of applications based on &GDA;. This library, although targeted to client
      applications, also includes a set of helper classes and functions to help
      in the addition of new providers to the &LIBGDA; architecture.
    </para>
    <para>
      Finally, at the upper level sit all the client applications provided in
      the suite, as well as any application that may make use of the client
      libraries.
    </para>
  </chapter>
  
  <chapter id="installation">
    <title>Installation</title>
    <sect1 id="installation-introduction">
      <title>Introduction</title>
      <para>
        On our web site, <ulink url="http://www.redhat.com" type="http">RedHat
        </ulink> and <ulink url="http://www.debian.org" type="http">Debian
        </ulink> packages are available, so you shouldn't have any problem
        installing it. For a standard installation, there is are no further
        steps, but, you'd better know configuration
        options, just in case you come across a non-standard installation, or 
        in case of problems during a standard installation.
      </para>
    </sect1>
    <sect1 id="installation-installing">
      <title>Installing</title>
      <para>
        Installation depends on which format you choose to download. If
        you've got a package such as &RPM; or <acronym>DEB</acronym>, check
        your package manager documentation for how to install new packages.
      </para>
      <para>
        If you downloaded the source code (in a tarball), you must
        compile the software. For doing so, once you have unpacked
        the source tree, you must:
        <screen>
          <prompt>$</prompt><userinput>./configure</userinput>
          <prompt>$</prompt><userinput>make</userinput>
          <prompt>$</prompt><userinput>make install</userinput>
        </screen>
      </para>
      <para>
        This will generate the makefiles for your specific platform,
        compile all the source tree, and install the binaries and
        documentation in your system.
      </para>
      <para>
        If you don't find a file named <filename>configure</filename>, there
        should be one called <filename>autogen.sh</filename>. In this case,
        run <filename>autogen.sh</filename>, which will create and run the
        generated <filename>configure</filename> file.
      </para>
      <para>
        You can specify several arguments to <filename>configure</filename> (or
        <filename>autogen.sh</filename>). The most significant are (you can
        check all the available arguments by running
        <command>configure --help</command>):
      </para>
      <itemizedlist mark="bullet">
        <listitem>
          <para>
            <userinput>--prefix=&lt;directory&gt;</userinput>: Prefix where
             package will be installed
          </para>
        </listitem>
        <listitem>
          <para>
            <userinput>--with-mysql=&lt;directory&gt;</userinput>: Specify
            directory where &MYSQL; libraries are installed
          </para>
        </listitem>
        <listitem>
          <para>
            <userinput>--with-postgres=&lt;directory&gt;</userinput>:
            Specify directory where &PGSQL; libraries are installed
          </para>
        </listitem>
        <listitem>
          <para>
            <userinput>--with-sybase=&lt;directory&gt;</userinput>: Specify
            directory where &SYBASE; libraries are installed
          </para>
        </listitem>
        <listitem>
          <para>
            <userinput>--with-ldap=&lt;directory&gt;</userinput>: Specify
             directory where &LDAP; libraries are installed
          </para>
        </listitem>
        <listitem>
          <para>
            <userinput>--with-oracle=&lt;directory&gt;</userinput>: Specify
            directory where &ORAC; libraries are installed
          </para>
        </listitem>
        <listitem>
          <para>
            <userinput>--with-interbase=&lt;directory&gt;</userinput>: Specify
            directory where &INTERB; libraries are installed
          </para>
        </listitem>
        <listitem>
          <para>
            <userinput>--with-mdb=&lt;directory&gt;</userinput>: Specify
            directory where the MDB libraries (for accessing &MSACC; files)
            are installed
          </para>
        </listitem>
	<listitem>
          <para>
            <userinput>--with-sqlite=&lt;directory&gt;</userinput>: Specify
            directory where the SQLite libraries are installed
          </para>
        </listitem>
      </itemizedlist>
      <para>
        Providers are not installed by default, so you must specifically add
        those arguments when running <filename>configure</filename>.
      </para>
      <para>
        If you find any problem during the configuration, compilation or
        installation process, do not hesitate in contacting the
        &GNOMEDB; mailing list (<email>gnome-db-list@gnome.org</email>, first
        send an email to <email>gnome-db-list-request@gnome.org</email> with 
        the subject SUBSCRIBE, if you are not already subscribed).
      </para>
    </sect1>
    <sect1 id="installation-configuring">
      <title>Configuring</title>
      <para>
        Depending on the use you're going to get out of &LIBGDA;, you may have
        to dig deep into its internals, but don't be afraid, things have been
        implemented to be easy to use.
      </para>
      <sect2 id="installation-development">
        <title>Configuration for development</title>
        <para>
          If you want to develop applications using &LIBGDA;, you should 
          install the libgda-dev[el] package if you do a &RPM; or Debian-based
          installation. If you compiled the source code, development files are
          installed in your system.
        </para>
        <para>
          The only step you need to do to make sure everything is well 
          installed, is to check that &LIBGDA; libraries and binaries are seen
          by your system. That is, make sure that the &LIBGDA; 
          <filename class="directory">bin/</filename> directory is in your
          <envar>PATH</envar> environment variable, as well as the
          <filename class="directory">lib/</filename> in your 
          <envar>LD_LIBRARY_PATH</envar> (or 
          <filename>/etc/ld.so.conf</filename> file).
        </para>
      </sect2>
      <sect2 id="installation-client">
        <title>Configuration for accessing a database</title>
        <para>
          If you want to access a data source through a &GDA;
          provider, you must first of all have access to this provider, and
          most importantly, this provider should have access to its specific
          data source. So, first have your database up and running.
          For this, you'll have to check your specific data source
          documentation, or see the &LIBGDA; providers' specific documentation.
        </para>
        <para>
          Once you've got your &GDA; provider installed,
          whether on your machine or on another one on the network, you must
          configure your local system to have access to it. If you're on a
          local installation, once you have installed the &GDA; provider (by 
          compiling it or by installing its &RPM; or Debian package), the 
          provider is visible in your machine. This is because the provider
          installs itself in a well known location that makes &LIBGDA;
	  itself know about the new provider.
        </para>
        <para>
          Then, the next step is to configure the data sources you want
          available on your system. For doing this, you should, as for now, use
          &GNOMEDB;, which is a frontend to &LIBGDA; for the 
          <ulink url="http://www.gnome.org" type="http">GNOME project</ulink>.
          <footnote>
	    <para>
	      It would be a good idea to add a command-line tool for managing
              the configuration, as now, using <systemitem class="resource">
              GConf</systemitem>, is not a matter of hacking on a config text
              file, as it was befofe with <function>gnome_config</function>.
              The &API; for doing so is already available in the <filename>
              libgda-common</filename>library, so it would be really easy.
              Volunteers?
	    </para>
	  </footnote>
	</para>
	<para>
	  Command-line tools will be provided in &LIBGDA; for doing so in a
          not-too-distant future, so you may want to know what information
          you need to setup a data source.
	</para>
	<para>
	  One of the problem &GDA; solves is the naming of
          data sources. Every database system has it's own way of defining
	  names for it's databases. For example &MYSQL; uses the hostname, 
          port number, and the name of the database. Other databases, like
          Solid use the hostname and port number only. There is no support
          for multiple databases per server. Because the client does not
          need all these details, the &LIBGDA; configuration defines all the
	  properties of such a data source, so that the correct data base
          server can be contacted. This information is accessed by the
          client library and sent to the provider, which in turn will parse
          the string to decide which database must be connected to. The
          data stored for each data source is as follows:
	  
	  <programlistingco>
	    <areaspec>
	      <area id="provider" coords="2">
	      <area id="dsn" coords="3">
              <area id="description" coords="4">
	      <area id="username" coords="5">
	      <area id="password" coords="6">
            </areaspec>
	    <programlisting>
	      [sales]
	      Provider=MySQL
              DSN=DATABASE=test;HOST=localhost;PORT=1111
	      Description=MySQL Test Database in native mode
	      Username=username
	      Password=password
	    </programlisting>
	    <calloutlist>
	      <callout arearefs="provider">
		<para>
    		  The provider for this database is the gda-mysql
		  provider. The value of this entry is used as the
		  object ID for the plugin activation.
		</para>
	      </callout>
	      <callout arearefs="dsn">
		<para>
		  This is the most important entry. The value of
		  this entry is the string sent to the provider so
		  that it knows which datasouce to access. How this
		  entry is interpreted by the providers is described 
		  in the provider section.
		</para>
		<para>
		  There are, though, a set of default properties that can
		  be used for the connection string for all providers. Those
		  are:
		  <itemizedlist>
		    <listitem>
		      <para>USERNAME: user name to be used for authentication.</para>
		    </listitem>
		    <listitem>
		      <para>PASSWORD: password to be used for authentication.</para>
		    </listitem>
		  </itemizedlist>
		</para>
	      </callout>
	      <callout arearefs="description">
		<para>
		  The value of this entry is a short description of
		  the datasource. It is here for convenience only
		  and it is not used for any purpose.
		</para>
	      </callout>
	      <callout arearefs="username">
	        <para>
		  The user name to be used when connecting to the database.
		</para>
	      </callout>
	      <callout arearefs="password">
	        <para>
		  The password to be used when connecting to the database.
		  This is stored in plain text, so be sure you restrict access
		  to the configuration file (<filename>~/.libgda/config</filename>)
		  to any &quot;dangerous&quot; users.
		</para>
	      </callout>
	    </calloutlist>
	  </programlistingco>
	</para>
      </sect2>
      <sect2 id="installation-provider">
        <title>Provider's specific information</title>
        <para>
          This section provides information specific to each of the available
          &LIBGDA; providers.
        </para>
	<sect3 id="installation-provider-default">
	  <title>Default provider</title>
	  <para>
	    The &GDA; default provider is always installed 
            with &LIBGDA, which means that you've got always a default
	    database system available for you. To connect to a default 
            provider's database, you only need to specify, in the &DSN; string,
            a string of the form "FILENAME=/directory/for/the/database". When
            you	first connect to the new data source, the &GDA; default 
            provider will create the database, in the directory you specified
            in the &DSN; string, if it does not exist. This default provider
	    uses XML as the format for that file.
	  </para>
	</sect3>
	<sect3 id="installation-provider-odbc">
	  <title>&ODBC; Provider</title>
	  <para>
	    The &ODBC; provider is a special case, since &ODBC; is itself a 
            data access layer, the same as &LIBGDA;, So, in the case of the
            &GDA; &ODBC; provider, the &DSN; string is completely up to the
            &ODBC; driver manager. That is, the &GDA; &ODBC; provider does not
            parse it all, nor does it try to understand what it means; it
            simply passes it over to the &ODBC; library.
	  </para>
	  <para>
	    So, if you want to use &LIBGDA; with &ODBC;, you should first know
            how to set up an &ODBC; data source, and then just specify the
            &DSN; string you would pass to the &ODBC; library in the &DSN;
            string of the &GDA; data sources.
	  </para>
	  <para>
	    There is a project called
	    <ulink url="http://www.unixodbc.org">unixODBC</ulink>,
            which provides some graphical tools to help you in
	    setting up &ODBC; data sources. You may find it
	    interesting to give it a try.
	  </para>
	</sect3>
	<sect3 id="installation-provider-postgres">
	  <title>&PGSQL; Provider</title>
	  <para>
	    To use the &GDA; &PGSQL; provider, you'll need
	    the <application>gda-postgres</application> package.	
	  </para>
	  <para>
	    The &PGSQL; provider accepts the following
	    arguments in the &GDA; data source's &DSN; string:
	     <itemizedlist>
	       <listitem>
	         <para>
	           HOST: name of the host where
		   the database server is running. If it begins with a slash
		   then the protocol used is Unix-domain instead of TCP/IP and
		   its value is the name of the directory where the file is
		   stord. By default: /tmp.
		 </para>
               </listitem>
	       <listitem>
		 <para>
		   HOSTADDR: IP of the host where the database server is
		   running (avoids DNS lookup). If this option has a value,
		   TCP/IP communications is used.

		   If neither a host name or host address is specified, the
		   connection will be stablished using a local Unix domain
		   socket.
		 </para>
	       </listitem>
	       <listitem>
	         <para>
	           PORT: Port number or socket filename extension for
		   Unix-domain connections.
		 </para>
               </listitem>
	       <listitem>
		 <para>
		   DATABASE: name of the database you want to access. This one
		   is called 'dbname' in the &PGSQL; documentation.
		 </para>
	       </listitem>
	       <listitem>
	         <para>
	           USER: user name to connect as.
		 </para>
               </listitem>
	       <listitem>
	         <para>
	           PASSWORD: password if the connection requires it.
		 </para>
               </listitem>
	       <listitem>
	         <para>
	           OPTIONS: trace/debug options to be sent to the server.
		 </para>
               </listitem>
	       <listitem>
	         <para>
	           TTY: a file or tty for optional debug output from the
		   backend.
		 </para>
               </listitem>
	       <listitem>
	         <para>
	           REQUIRESSL: set to '1' to force SSL connection to the
		   backend. Set to '0' to negotiate with server.
		 </para>
               </listitem>
	     </itemizedlist>
	     The description of the parameters is almost copied from the
	     &PGSQL; documentation. Refer to it for details on how some
	     environment variables can also set these parameters.
	   </para>
	 </sect3>
        <sect3 id="installation-provider-mysql">
          <title>&MYSQL; Provider</title>
          <para>
	    To configure a data source to access a &MYSQL; database,
	    you'll need to install the &GDA; &MYSQL; provider (package
	    <filename>gda-mysql</filename>).
          </para>
	  <para>
	    It accepts the following arguments in the &DSN;
	    string:	
	     <itemizedlist>
	       <listitem>
	         <para>
	           HOST:
		 </para>
               </listitem>
	       <listitem>
	         <para>
	           DATABASE:
		 </para>
               </listitem>
	       <listitem>
	         <para>
	           USERNAME:
		 </para>
               </listitem>
	       <listitem>
	         <para>
	           PASSWORD:
		 </para>
               </listitem>
	       <listitem>
	         <para>
	           PORT:
		 </para>
               </listitem>
	       <listitem>
	         <para>
	           UNIX_SOCKET:
		 </para>
               </listitem>
	       <listitem>
	         <para>
	           FLAGS:
		 </para>
               </listitem>
	     </itemizedlist>
	  </para>
        </sect3>
	<sect3 id="installation-provider-sybase">
	  <title>&SYBASE; Provider</title>
	  <para>
	    To use the &GDA; &SYBASE; provider, you'll need
	    the <application>gda-sybase</application> package.	
	  </para>
	  <para>
	    The &SYBASE; provider accepts the following
	    arguments in the &GDA; data source's &DSN; string:
	     <itemizedlist>
	       <listitem>
	         <para>
		   HOST: name of the host where the database server is
		   running.
		   </para>
               </listitem>
	       <listitem>
	         <para>
	           USERNAME: user name to connect as.
		 </para>
               </listitem>
	       <listitem>
	         <para>
	           APPNAME:
		 </para>
               </listitem>
	       <listitem>
	         <para>
	           PASSWORD: password if the connection requires it.
		 </para>
               </listitem>
	       <listitem>
		 <para>
		   DATABASE:
		 </para>
	       </listitem>
	     </itemizedlist>
	   </para>
	 </sect3>
      </sect2>
    </sect1>
  </chapter>
  
  <chapter id="libgda-api">
    <title>&LIBGDA; API Reference</title>
    <para>
      The following sections describe the API available for &GDA; applications.
    </para>
    &libgda-init;
    &libgda-batch;
    &libgda-client;
    &libgda-command;
    &libgda-config;
    &libgda-connection;
    &libgda-data-model-array;
    &libgda-data-model-hash;
    &libgda-data-model-list;
    &libgda-data-model;
    &libgda-error;
    &libgda-export;
    &libgda-field;
    &libgda-log;
    &libgda-parameter;
    &libgda-quark-list;
    &libgda-row;
    &libgda-select;
    &libgda-table;
    &libgda-transaction;
    &libgda-util;
    &libgda-value;
    &libgda-xml-connection;
    &libgda-xml-database;
    &libgda-xml-document;
  </chapter>

  <chapter id="libgda-providers">
    <title>GDA Providers</title>
    <sect1 id="libgda-provider-introduction">
    <title>Introduction</title>
    <para>
       For each different data source supported by &LIBGDA; there must be a
       GObject that implements the virtual methods defined in &GDASERVERPROVIDER;
       class.
    </para>
    <para>
       Providers must also create their own object to implement the virtual
       methods defined in &GDADATAMODEL; or one of
       its subclasses (currently &GDADATAMODELARRAY; and &GDADATAMODELHASH;) 
       to support recordsets.
    </para>
    <para>
      Since &LIBGDA; itself is developed in the C language, and that most
      providers are also implemented in that language, the &LIBGDA; library
      itself contains a set of helper classes and functions to guide you
      in the addition of a new provider to the GDA framework.
    </para>
    </sect1>
    <sect1 id="libgda-provider-class">
      <title>The GdaServerProvider class</title>
      <para>
	The &GDASERVERPROVIDER; is the class you should implement for adding
	a new provider. This class is just a typical GObject-based class,
	with a set of virtual methods, that are the ones that you must
	implement. These virtual methods are declared in the class structure,
	in the <filename>gda-server-provider.h</filename> file. They are
	explained in detail in the following subsections.
      </para>
      <sect2 id="libgda-provider-open-connection">
	<title>open_connection</title>
	   <para>
	   Sets up the connection to the database backend using the parameters
	   received as arguments and returns a boolean TRUE if the connection
	   is successfully established, otherwise FALSE.
	</para>
      </sect2>
	<sect2 id="libgda-provider-close-connection">
	<title>close_connection</title>
	<para>
	  Frees the resources allocated for the connection and returns TRUE
	  if everything is ok
	</para>
      </sect2>
      <sect2 id="libgda-provider-get-database">
	<title>get_database</title>
	<para>
	  Returns the name of the currently open database for a given
	  connection.
	</para>
      </sect2>
      <sect2 id="libgda-provider-change-database">
	<title>change_database</title>
	<para>
	  Change the database being used in the active connection.
	</para>
      </sect2>
      <sect2 id="libgda-provider-create-database">
	<title>create_database</title>
	<para>
	  Creates a new database whose name is received in a parameter.	
	</para>
      </sect2>
      <sect2 id="libgda-provider-drop-database">
	<title>drop_database</title>
	<para>
	  Drops an existing database whose name is received in a parameter.
	</para>
      </sect2>
      <sect2 id="libgda-provider-execute-command">
	<title>execute_command</title>
	<para>
	  Executes a command and returns a GList of &GDADATAMODEL; with the
	  results.
	</para>
      </sect2>
      <sect2 id="libgda-provider-begin-transaction">
	<title>begin_transaction</title>
	<para>
	  Initiates a transaction if the DB backend supports transactions.
	</para>
      </sect2>
      <sect2 id="libgda-provider-commit-transaction">
	<title>commit_transaction</title>
	<para>
	  Commits a transaction if the DB backend supports transactions.
	</para>
      </sect2>
      <sect2 id="libgda-provider-rollback-transaction">
	<title>rollback_transaction</title>
	<para>
	  Rollback a transaction if the DB backend supports transactions.
	</para>
      </sect2>
      <sect2 id="libgda-provider-supports">
	<title>supports</title>
	<para>
	  Tests if a given feature is supported by the provider and the
	  DB backend. You can view the list of features in <filename>
	  gda-connection.h</filename>, enumeration GdaConnectionFeature.
	</para>
      </sect2>
      <sect2 id="libgda-provider-get-schema">
	<title>get_schema</title>
	<para>
	  Returns a &GDADATAMODEL; with the schema information requested.
	  You can view the list of features in <filename>
	  gda-connection.h</filename>, enumeration GdaConnectionSchema.
	  This schema information is what describes the objects in the
	  database, and is the way applications can manage the structure
	  of several database systems without knowing anything about
	  their specific way of retrieving this information.
	</para>
	<para>
	  The <function>get_schema</function> virtual method gets a
	  <type>GdaConnectionSchema</type> argument, which describes
	  the kind of schema the client making the call is interested
	  in, along with a <type>GdaParameterList</type> argument,
	  which contains the list of arguments sent by the user to
	  explicitly provide more information for the search.
	</para>
	<para>
	  The information to be returned for each schema, along with
	  the supported parameters, is described in the following table.
	</para>
	<table frame="all">
	  <title>Standard Schema and supported parameters</title>
	  <tgroup cols="4" colsep="1" rowsep="1" align="justify">
	    <colspec colname="c1">
	    <colspec colname="c2">
	    <colspec colname="c3">
	    <colspec colname="c4">
	    <thead>
	      <row>
		<entry>Object type</entry>
		<entry>GDA identifier</entry>
		<entry>Supported Parameters</entry>
		<entry>Returned fields</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry>Tables</entry>
		<entry><parameter>GDA_CONNECTION_SCHEMA_TABLES</parameter></entry>
		<entry>"name" (name of table, optional)</entry>
		<entry>name, owner, comments, SQL definition
	      </row>
	      <row>
		<entry>Tables' parents</entry>
		<entry><parameter>GDA_CONNECTION_SCHEMA_PARENT_TABLES</parameter></entry>
		<entry>"name" (name of table, optional)</entry>
		<entry>name, order of inheritance</entry>
	      </row>
	      <row>
		<entry>Views</entry>
		<entry><parameter>GDA_CONNECTION_SCHEMA_VIEWS</parameter></entry>
		<entry>"name" (name of view, optional)</entry>
		<entry>name, owner, comments, SQL definition</entry>
	      </row>
	      <row>
		<entry>Table (or view) fields</entry>
		<entry><parameter>GDA_CONNECTION_SCHEMA_FIELDS</parameter></entry>
		<entry>"name" (name of table (or view), required)</entry>
		<entry>name, type, size, scale, not null?, primary key?, unique index?, references</entry>
	      </row>
	      <row>
		<entry>Sequences</entry>
		<entry><parameter>GDA_CONNECTION_SCHEMA_SEQUENCES</parameter></entry>
		<entry>"name" (name of sequence, optional)</entry>
		<entry>name, owner, comments, SQL definition</entry>
	      </row>
	      <row>
		<entry>Procedures</entry>
		<entry><parameter>GDA_CONNECTION_SCHEMA_PROCEDURES</parameter></entry>
		<entry>"name" (name of procedure, optional)</entry>
		<entry>name, owner, comments, return type, number of arguments, SQL definition</entry>
	      </row>
	      <row>
		<entry>Procedure parameters</entry>
		<entry><parameter>GDA_CONNECTION_SCHEMA_PROCEDURE_PARAMS</parameter></entry>
		<entry>"name" (name of procedure, required)</entry>
		<entry>name, usage (in, out, inout), type</entry>
	      </row>
	      <row>
		<entry>Aggregates</entry>
		<entry><parameter>GDA_CONNECTION_SCHEMA_AGGREGATES</parameter></entry>
		<entry>"name" (name of aggregate, optional)</entry>
		<entry>name, owner, comments, return type, in type, SQL definition</entry>
	      </row>
	      <row>
		<entry>Types</entry>
		<entry><parameter>GDA_CONNECTION_SCHEMA_TYPES</parameter></entry>
		<entry>"name" (name of type, optional)</entry>
		<entry>name, owner, comments, GDA type</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>
      </sect2>
    </sect1>
    <sect1 id="libgda-provider-recordset">
      <title>The recordset class</title>
      <para>
	You have to extend one of &GDADATAMODEL;, &GDADATAMODELARRAY; or
	&GDADATAMODELHASH;. The easiest to extend are the last two. They both
	derive from &GDADATAMODEL;.
      </para>
      <para>
	Here is the list of methods that you have to override. If you use
	&GDADATAMODELHASH;, you don't need to override 
	append_row.
      </para>
      <itemizedlist>
	<listitem>
	  <para>get_n_rows</para>
	  <para>
	    Returns the number of rows in the data model. If the provider
	    can know in advance the number of rows the database server has
	    returned, this function should just return that, and not
	    retrieve any data. On the other hand, if it can't it should
	    either retrieve all data, or move to the last record in the
	    recordset and retrieve the row number, if the underlying
	    data source allows it.
	  </para>
	</listitem>
	<listitem>
	  <para>get_n_columns</para>
	  <para>
	    Returns the number of columns in the data model.
	  </para>
	</listitem>
	<listitem>
	  <para>describe_column</para>
	  <para>
	    Returns information about a given column, in the form of
	    a <xref linkend="GdaFieldAttributes">GdaFieldAttributes</xref>.
	  </para>
	</listitem>
	<listitem>
	  <para>get_row</para>
	  <para>
	    Retrieves a row from the data model. This function is very important
	    for the implementation of editable data models. What this function
	    returns is a <xref linkend"GdaRow">GdaRow</xref>, which providers
	    should uniquely identify (via <xref linkend="gda-row-set-id">gda_row_set_id</xref>).
	    This is needed so that later on, client applications can use the same
	    <xref linkend="GdaRow">GdaRow</xref> returned by this method in
	    the <function>update_row</function> and <function>remove_row</function>
	    methods.
	  </para>
	</listitem>
	<listitem>
	  <para>get_value_at</para>
	  <para>
	    Returns the value stored in a given cell of the data model.
	  </para>
	</listitem>
	<listitem>
	  <para>is_editable</para>
	  <para>
	    Checks whether the data model can be modified or not. If the provider
	    supports the edition of data models, it should return TRUE in this
	    function. If it doesn't (for instance, because it can't uniquely identify
	    rows in the data model), it should return FALSE.
	  </para>
	  <para>
	    Before a data model can be edited, client applications must call the
	    <xref linkend="gda-data-model-begin-edit">gda_data_model_begin_edit</xref>
	    function, which emits the "begin_edit" signal on the
	    <xref linkend="GdaDataModel">GdaDataModel</xref> class. So, providers
	    should connect to this signal to be informed when the data model
	    starts being editing. In the callback connected to that signal,
	    it should start a transaction, for instance.
	  </para>
	  <para>
	    In a similar way, there are 2 other signals that provider's data model
	    implementations should pay attention to. Those are "end_edit" and
	    "cancel_edit". In "end_edit", if all went ok, providers should
	    COMMIT the transaction started in "begin_edit". In "cancel_edit",
	    a ROLLBACK should be made.
	  </para>
	</listitem>
	<listitem>
	  <para>append_row</para>
	  <para>
	    Appends a row to the data model. Usually, this means, in the provider,
	    executing an INSERT SQL command on the table being read by the
	    data model.
	  </para>
	</listitem>
	<listitem>
	  <para>update_row</para>
	  <para>
	    Updates an existing row in the data model. The row should have been
	    uniquely identified in the provider code, as explained for the
	    get_row method.
	  </para>
	</listitem>
	<listitem>
	  <para>remove_row</para>
	  <para>
	    Removes a row from the data model. Usually, this means, in the provider,
	    executing a DELETE SQL command on the table being read by the data model.
	    The row should have been
	    uniquely identified in the provider code, as explained for the
	    get_row method.
	  </para>
	</listitem>
      </itemizedlist>
    </sect1>
    &libgda-server-provider;
  </chapter>

  <chapter id="libgda-xql">
    <title>XML Queries</title>
    <para>
    </para>
    &libgda-xql-atom;
    &libgda-xql-bin;
    &libgda-xql-column;
    &libgda-xql-const;
    &libgda-xql-delete;
    &libgda-xql-dml;
    &libgda-xql-dual;
    &libgda-xql-field;
    &libgda-xql-func;
    &libgda-xql-insert;
    &libgda-xql-item;
    &libgda-xql-join;
    &libgda-xql-list;
    &libgda-xql-query;
    &libgda-xql-select;
    &libgda-xql-stack;
    &libgda-xql-target;
    &libgda-xql-update;
    &libgda-xql-utils;
    &libgda-xql-value;
    &libgda-xql-valueref;
  </chapter>

  <chapter id="libgda-reports">
    <title>&GDA; Report Engine</title>
    <para>
    </para>
    &libgda-report-types;
    &libgda-report-document;
  </chapter>
  
  &fdl-appendix;
</book>

