<chapter id="libgda-provider-class">
  <title>Virtual methods for providers</title>
  <para>
    Database providers usually (that is except for <emphasis>virtual</emphasis> providers explained later) subclass
    the <link linkend="GdaServerProvider">GdaServerProvider</link> class and implement at least the mandatory
    virtual methods.
  </para>
  <para>
    Virtual providers are database providers when the database engine accessed does not support SQL (or
    supports it poorly), such as Berkeley databases or MDB (or even LDAP). These provider's implementation's
    design is to create <link linkend="GdaDataModel">GdaDataModel</link> data model objects and make
    each of them appear as a named table once the connection is opened. For example the MDB provider creates
    a read-only data model for each table in an MDB file and make it appear using the original table
    name used in MS Access (the tables cannot be modified but it is possible to use all SQLite's SQL
    to make SELECT queries).
  </para>
  <para>
    Virtual providers inherit the <link linkend="GdaVproviderDataModel">GdaVproviderDataModel</link> class
    and not the <link linkend="GdaServerProvider">GdaServerProvider</link> as "normal" providers do,
    and the number of virtual methods to implement is very limited: only the <link linkend="prov-get-name">get_name()</link>,
    <link linkend="prov-get-version">get_version()</link>, <link linkend="prov-get-server-version">get_server_version()</link>, 
    <link linkend="prov-open-connection">open_connection()</link> and <link linkend="prov-get-database">get_database()</link>
    should be implemented, optionnally the <link linkend="prov-close-connection">close_connection()</link> can
    also be implemented.
  </para>
  <para>
    To implement a virtual provider, one can copy the contents of the 
    <filename class="directory">providers/skel-implementation/models</filename> directory, change all references
    to "models" with the correct provider name, and implement the missing parts, using if necessary the
    BDB an MDB providers' implementations as examples.
  </para>

  <sect1>
    <title>Synchronous / asynchronous mode</title>
    <para>
      All the provider's commands are executed in a synchronous mode (the caller is blocked until the provider's
      method terminates). However some virtual methods have the <parameter>task_id</parameter>, 
      <parameter>async_cb</parameter> and <parameter>cb_data</parameter> which can be set when an asynchronous mode 
      is required; asynchronous mode is requested if and only if the <parameter>async_cb</parameter> is not NULL.
    </para>
    <para>
      When an asynchronous mode is requested, the method should return a temporary result and set a task identifier
      into the <parameter>task_id</parameter> parameter if not NULL.
    </para>
    <para>
      When the provider's method terminates, it then should call the function passed as <parameter>async_cb</parameter>
      with the <parameter>cb_data</parameter> as last parameters.
    </para>
  </sect1>

  <sect1>
    <title>Multi threaded environment</title>
    <para>
      Each database provider should be useable in a multi threaded environment, even if they impose some restrictions
      as to how they can be used in such an environment. The &LIBGDA;'s framework provides some locking mechanism which
      is:
      <itemizedlist>
	<listitem><para>if multi threading cannot be supported at all (for example if the client library internally
	    used by the provider does not support it), then the provider should make sure it refuses to work
	    if used from any thread different than the thread which created it, the provider's class implementation
	    should set the class's <structfield>limiting_thread</structfield> attribute to the thread which created it
	    using <link linkend="g-thread-self">g_thread_self()</link></para>
	</listitem>
	<listitem><para>if multi threading is supported but any connection (or related object) can only be 
	    used by the thread in which it was created, then for each opened connection, the 
	    &quot;<link linkend="GdaConnection--thread-owner">thread-owner</link>&quot; connection's property
	    must be set to the current thread (and other related objects must be locked in a similar way)</para>
	</listitem>
	<listitem><para>if no locking is done, then the provider is assumed to support full multi threading access,
	  in this case make sure to set class's <structfield>limiting_thread</structfield> attribute to NULL.</para>
	</listitem>
      </itemizedlist>
    </para>
  </sect1>

  <sect1>
    <title>Methods - provider's information</title>
    <sect2 id="prov-get-name">
      <title>get_name() - mandatory</title>
      <para>This method returns the name of the provider; it should only contain alphanumeric characters.</para>
    </sect2>
    <sect2 id="prov-get-version">
      <title>get_version() - mandatory</title>
      <para>This method returns the version of the provider (providers built as part of &LIBGDA; have the same
	version as &LIBGDA;).</para>
    </sect2>
    <sect2 id="prov-get-server-version">
      <title>get_server_version() - mandatory</title>
      <para>This method returns the version of the database server to which a connection is opened</para>
    </sect2>
    <sect2>
      <title>supports_feature()</title>
      <para>This method allows one to ask the provider if some specific features are available</para>
    </sect2>
  </sect1>

  <sect1>
    <title>Methods - connection management</title>
    <sect2 id="prov-open-connection">
      <title>open_connection() - mandatory</title>
      <para>
	This method actually opens a connection to the database.
      </para>
      <para>
	Any data specific to the connection (such as 
	a database handle created by the database API when opening the connection) must be stored in a private structure
	(which should be defined in the <filename>gda-&lt;providername&gt;.h</filename> file as a 
	<classname>&lt;Providername&gt;ConnectionData</classname>); this private structure's adress should be
	"attached" to the <link linkend="GdaConnection">GdaConnection</link> object using the
	<link linkend="gda-connection-internal-set-provider-data">gda_connection_internal_set_provider_data()</link>.
      </para>
    </sect2>
    <sect2 id="prov-close-connection">
      <title>close_connection() - mandatory</title>
      <para>
	This method actually closes a connection previously opened by the 
	<link linkend="prov-open-connection">open_connection()</link> virtual method. This method is not mandatory for
	virtual providers.
      </para>
      <para>
	The connection specific data for the database API can be retreived using the
	<link linkend="gda-connection-internal-get-provider-data">gda_connection_internal_get_provider_data()</link> method.
      </para>
    </sect2>
    <sect2>
      <title>get_database()</title>
      <para>This method returns the name of the database to which a connection is opened.</para>
    </sect2>
  </sect1>

  <sect1>
    <title>Methods - DDL queries</title>
    <para>
      This group of virtual methods is composed of virtual methods which make it possible to handle DDL (data definition) queries
      to be executed using descriptions of the data required for each kind of DDL query, rather than using SQL directly (because
      DDL SQL is usually very database specific and must thus be adapted when migrating to another database type). For more
      information, see the <link linkend="DDLIntro">global introduction to DDL queries</link>.
    </para>
    <para>
      Implementing these methods is not mandatory, and virtual provider's implementation should not implement them.
    </para>
    <sect2>
      <title>supports_operation()</title>
      <para>
	This virtual method tells if a particular DDL query type is supported (DDL query types are identified as 
      <link linkend="GdaServerOperationType">GdaServerOperationType</link> enums).
      </para>
    </sect2>
    <sect2>
      <title>create_operation()</title>
      <para>
	This virtual method is used to create and initialize a <link linkend="GdaServerOperation">GdaServerOperation</link>
	object.
      </para>
    </sect2>
    <sect2>
      <title>render_operation()</title>
      <para>
	This virtual method uses the information stored in a <link linkend="GdaServerOperation">GdaServerOperation</link> object
	to create the SQL statement(s) which would be executed if the operation was performed.
      </para>
      <para>
	Note: more than one SQL statement may be returned by this method
      </para>
      <para>
	Note: some operations don't return any SQL at all, if the operation can only be done using an API (and not through SQL)
      </para>
    </sect2>
    <sect2>
      <title>perform_operation()</title>
      <para>
	This virtual method "performs" (execute) a <link linkend="GdaServerOperation">GdaServerOperation</link> object.
      </para>
    </sect2>
  </sect1>

  <sect1>
    <title>Methods - transactions management</title>
    <para>
      When a connection has been opened and no transaction has been started, then the provider should execute queries in
      auto commit mode.
    </para>
    <sect2>
      <title>begin_transaction()</title>
      <para>
	This method starts a new transaction.
      </para>
    </sect2>
    <sect2>
      <title>commit_transaction()</title>
      <para>
	This method commits the current transaction.
      </para>
    </sect2>
    <sect2>
      <title>rollback_transaction()</title>
      <para>
	This method cancels the current transaction.
      </para>
    </sect2>
    <sect2>
      <title>add_savepoint()</title>
      <para>
	This method adds a save point to the current transaction, which allows for partial rollbacks within transactions.
      </para>
    </sect2>
    <sect2>
      <title>rollback_savepoint()</title>
      <para>
	This method rolls back to a previously defined save point within the current transaction.
      </para>
    </sect2>
    <sect2>
      <title>delete_savepoint()</title>
      <para>
	This method deletes a previously defined save point within the current transaction, it does not affect the
	transaction but it simply won't be possible to roll back to the savepoint afterwards.
      </para>
    </sect2>
  </sect1>

  <sect1>
    <title>Methods - DML queries</title>
    <para>
      This group of virtual methods is related to executing SQL queries of any kind. &LIBGDA; imposes that SQL
      statements be converted to one or more <link linkend="GdaStatement">GdaStatement</link> object(s), each
      GdaStatement object containing exactly one SQL statement (usually terminated
      by a semi colon). Each GdaStatement can then be prepared and/or executed individually.
    </para>
    <para>
      Creating a <link linkend="GdaStatement">GdaStatement</link> object from some SQL is the job of a
      <link linkend="GdaSqlParser">GdaSqlParser</link> object.
    </para>
    <sect2>
      <title>create_parser()</title>
      <para>
	This method instanciates a <link linkend="GdaSqlParser">GdaSqlParser</link> object which is
	adapted to the database's specific SQL dialect. If the provider does not implement its own parser,
	then this method should not be implemented.
      </para>
    </sect2>
    <sect2>
      <title>statement_to_sql()</title>
      <para>
	This method converts a <link linkend="GdaStatement">GdaStatement</link> object to its SQL representation. It should be
	implemented only if the default rendering is incorrect (to support some SQL specific dialect). The rendering process
	is decomposed into several rendering methods, and it is possible to override only some of the methods (see the
	PostgreSQL's implementation as an example).
      </para>
    </sect2>
    <sect2>
      <title>statement_prepare()</title>
      <para>
	This method requests that a <link linkend="GdaStatement">GdaStatement</link> object be prepared for a future execution.
	It is called when <link linkend="gda-connection-statement-prepare">gda_connection_statement_prepare()</link> is called.
      </para>
    </sect2>
    <sect2>
      <title>statement_execute() - mandatory</title>
      <para>
	This method actually executes a query represented by a <link linkend="GdaStatement">GdaStatement</link> object. See
	<link linkend="gda-connection-statement-execute">gda_connection_statement_execute()</link> for more information, note that
	this method is also always the one called when any of the gda_connection_statement_execute*() methods are called.
      </para>
    </sect2>
  </sect1>

  <sect1>
    <title>Methods - data representation</title>
    <para>
      This group of virtual methods is related to converting some data between the three representations which are the 
      SQL representation (to be directly included in a SQL statement), the human readable representation, and the 
      <link linkend="GValue">GValue</link> representation. For each type of data (identified as a 
      <link linkend="GType">GType</link> type) which the provider can handle, a <link linkend="GdaDataHandler">GdaDataHandler</link>
      object is responsible of the conversions.
    </para>
    <sect2>
      <title>get_data_handler()</title>
      <para>
	This method returns a <link linkend="GdaDataHandler">GdaDataHandler</link> for the requested data type. It should
	only instanciate each <link linkend="GdaDataHandler">GdaDataHandler</link> once and reuse it if the same request happens 
	(the returned object will not be modified).
      </para>
      <para>
	This method is called by both
	<link linkend="gda-server-provider-get-data-handler-g-type">gda_server_provider_get_data_handler_g_type()</link> and
	<link linkend="gda-server-provider-get-data-handler-dbms">gda_server_provider_get_data_handler_dbms()</link> methods.
      </para>
    </sect2>
    <sect2>
      <title>get_def_dbms_type()</title>
      <para>
	This method returns the name of the most common (database specific) data type which has the requested type.
      </para>
    </sect2>
    <sect2>
      <title>escape_string()</title>
      <para>
	This method adds escape characters to a string, to be able to safely add it into an SQL statement.
      </para>
    </sect2>
    <sect2>
      <title>unescape_string()</title>
      <para>
	This method does the reverse of the escape_string() method.
      </para>
    </sect2>
  </sect1>

  <sect1 id="prov-metadata">
    <title>Methods - metadata</title>
    <para>
      The <link linkend="GdaServerProviderMeta">GdaServerProviderMeta</link> structure defines all the methods
      which database providers must implement for the meta data extraction feature to work. Each method is
      used internally by the <link linkend="GdaConnection">GdaConnection</link> object when one calls the
      <link linkend="gda-connection-update-meta-store">gda_connection_update_meta_store()</link> method (where the
      connection object itself computes the list and order of methods to call).
      Each method must update the contents of one table in the connection's associated metadata
      (in its associated <link linkend="GdaMetaStore">GdaMetaStore</link> object), each has the same
      "base" arguments and some have extra arguments further specifying what needs to be updated. 
    </para>
    <para>
      For each table to update, there are two methods, which differ in their name only by the fact that one is starting 
      with an underscore '_'. The method starting with an underscore must update the whole contents of the meta data
      table, and the other one must accept some more parameters to refine what gets updated. There are exception 
      to this rule (such as the
      "tables_views()" method which must update both the <link linkend="is:_tables">"_tables"</link> and 
      <link linkend="is:_views">"_views"</link> tables, or the for the
      tables which have no foreign key (no dependency) to any other table).
    </para>
    <para> 
      Also, by convetion, the arguments can't be NULL unless the argument name has the "_n" suffix. For example
      the signature of the "tables_views()" method has the following signature (as defined in the 
      <filename>gda-server-provider.h</filename> file) 
      <programlisting>
gboolean (*tables_views) (GdaServerProvider *, GdaConnection *, GdaMetaStore *, 
                          GdaMetaContext *, GError **,
                          const GValue *table_catalog, const GValue *table_schema, 
                          const GValue *table_name_n);
      </programlisting>
      which means that the <parameter>table_catalog</parameter> and <parameter>table_schema</parameter>
      arguments can't be NULL, whereas the <parameter>table_name</parameter> can be NULL (and in this case the 
      "tables_views()" method must update the <link linkend="is:_tables">"_tables"</link> and 
      <link linkend="is:_views">"_views"</link> tables regarding all the tables which
      are in the specified catalog and schema.
    </para>
    <para>
      Make sure you read the information about the meta data's database structure in the
      <link linkend="information_schema">Database structure</link>, and specifically the
      <link linkend="information_schema:data_types">data types</link> section and the 
      <link linkend="information_schema:sql_identifiers">SQL identifiers</link> section.
    </para>
    <sect2>
      <title>_info()</title>
      <para>
	<programlisting>
gboolean (*_info) (GdaServerProvider *, GdaConnection *, GdaMetaStore *, 
                   GdaMetaContext *, GError **);
	</programlisting>
	This method must update the contents of the 
	<link linkend="is:_information_schema_catalog_name">"_information_schema_catalog_name"</link>
	table, which must contain exactly
	one row describing the catalog name for the connection.
      </para>
    </sect2>
    
    <sect2>
      <title>_btypes()</title>
      <para>
	<programlisting>
gboolean (*_btypes) (GdaServerProvider *, GdaConnection *, GdaMetaStore *, 
                     GdaMetaContext *, GError **);
	</programlisting>
	This method must update the contents of the <link linkend="is:_builtin_data_types">"_builtin_data_types"</link>
	table which lists all the
	database's built in data types. There is no specific parameter.
      </para>
    </sect2>
    
    <sect2>
      <title>schemata() and _schemata()</title>
      <para>
	<programlisting>
gboolean (*_schemata) (GdaServerProvider *, GdaConnection *, GdaMetaStore *, 
                       GdaMetaContext *, GError **);
gboolean (*schemata)  (GdaServerProvider *, GdaConnection *, GdaMetaStore *, 
                       GdaMetaContext *, GError **,
                       const GValue *catalog_name, const GValue *schema_name_n);
	</programlisting>
        This method must update the contents of the <link linkend="is:_schemata">"_schemata"</link> table, 
	which lists all the schemas (namespaces). 
      </para>
    </sect2>
    <sect2>
      <title>tables_views() and _tables_views()</title>
      <para>
	<programlisting>
gboolean (*_tables_views) (GdaServerProvider *, GdaConnection *, GdaMetaStore *, 
                           GdaMetaContext *, GError **);
gboolean (*tables_views)  (GdaServerProvider *, GdaConnection *, GdaMetaStore *, 
                           GdaMetaContext *, GError **,
                           const GValue *table_catalog, const GValue *table_schema, 
                           const GValue *table_name_n);
	</programlisting>
	This method must update the contents of the <link linkend="is:_tables">"_tables"</link> and 
	<link linkend="is:_views">"_views"</link> tables which list all the
	tables and views.
      </para>
    </sect2>

    <sect2>
      <title>columns() and _columns()</title>
      <para>
	<programlisting>
gboolean (*_columns) (GdaServerProvider *, GdaConnection *, GdaMetaStore *, 
                      GdaMetaContext *, GError **);
gboolean (*columns)  (GdaServerProvider *, GdaConnection *, GdaMetaStore *, 
                      GdaMetaContext *, GError **,
                      const GValue *table_catalog, const GValue *table_schema, 
                      const GValue *table_name);
	</programlisting>
	This method must update the contents of the <link linkend="is:_columns">"_columns"</link> table which lists all the
	columns of all the tables and views.
      </para>
    </sect2>

    <sect2>
      <title>constraints_tab() and _constraints_tab()</title>
      <para>
	<programlisting>
gboolean (*_constraints_tab) (GdaServerProvider *, GdaConnection *, GdaMetaStore *, 
                              GdaMetaContext *, GError **);
gboolean (*constraints_tab)  (GdaServerProvider *, GdaConnection *, GdaMetaStore *, 
                              GdaMetaContext *, GError **,
                              const GValue *table_catalog, const GValue *table_schema, 
                              const GValue *table_name, const GValue *constraint_name_n);
	</programlisting>
	This method must update the contents of the <link linkend="is:_table_constraints">"_table_constraints"</link>
	table which lists all the
	constraints (primary key, foreing key, unique or check cnstraints) for each table.
      </para>
    </sect2>

    <sect2>
      <title>constraints_ref() and _constraints_ref()</title>
      <para>
	<programlisting>
gboolean (*_constraints_ref) (GdaServerProvider *, GdaConnection *, GdaMetaStore *, 
                              GdaMetaContext *, GError **);
gboolean (*constraints_ref)  (GdaServerProvider *, GdaConnection *, GdaMetaStore *, 
                              GdaMetaContext *, GError **,
                              const GValue *table_catalog, const GValue *table_schema, 
                              const GValue *table_name, const GValue *constraint_name);
	</programlisting>
	This method must update the contents of the 
	<link linkend="is:_referential_constraints">"_referential_constraints"</link> table which lists all the
	refetential constraints (which are also listed in the 
	<link linkend="is:_table_constraints">"_table_constraints"</link> table).
      </para>
    </sect2>

    <sect2>
      <title>key_columns() and _key_columns()</title>
      <para>
	<programlisting>
gboolean (*_key_columns) (GdaServerProvider *, GdaConnection *, GdaMetaStore *, 
                          GdaMetaContext *, GError **);
gboolean (*key_columns)  (GdaServerProvider *, GdaConnection *, GdaMetaStore *, 
                          GdaMetaContext *, GError **,
                          const GValue *table_catalog, const GValue *table_schema,
                          const GValue *table_name, const GValue *constraint_name);
	</programlisting>
	This method must update the contents of the <link linkend="is:_key_column_usage">"_key_column_usage"</link>
	table which lists all the
	columns involved in each table constraint (as listed in the 
	<link linkend="is:_table_constraints">"_table_constraints"</link> table).
      </para>
    </sect2>
  </sect1>

  <sect1>
    <title>Methods - misc.</title>
    <sect2>
      <title>cancel()</title>
      <para>
	This method cancels an asynchronous task.
      </para>
    </sect2>
    <sect2>
      <title>create_connection()</title>
      <para>
	Reserved for internal implementation.
      </para>
    </sect2>
    <sect2>
      <title>is_busy()</title>
      <para>
	This method tests if a connection is already busy in a, asynchronous task.
      </para>
    </sect2>
  </sect1>
</chapter>

<chapter id="libgda-provider-recordset">
  <title>Virtual methods for recordsets</title>
  <para>
    This section explains how to write virtual methods for the <link linkend="GdaDataSelect">GdaDataSelect</link> subclasses
    implementations, which should be done when implementing a database provider.
  </para>
  <para>
    That data model implementation simplifies the implementation of provider's recordsets by having them implement only a
    few virtual methods, and offering some services.
  </para>
  <para>
    The data model represents each row in a separate <link linkend="GdaRow">GdaRow</link> object, and virtual
    methods to retreive rows have to return new (and correctly initialized) objects of that class. The referencing
    of these new objects is left up to the implementation which:
    <itemizedlist>
      <listitem>
	<para>can rely on the <link linkend="GdaRow">GdaRow</link> implementation to keep them, using
	  the <link linkend="gda-data-select-take-row">gda_data_select_take_row ()</link> method for each row object created which
	  is the easiest, the fastest as once created, the rows are available for further usage, 
	  but will consume more memory with each row read from the model.</para>
      </listitem>
      <listitem>
	<para>can keep the references to these objects to the subclass implementation which will consume less memory but
	  will make it necessary to create a new row object each time a row is read which is slower</para>
      </listitem>
      <listitem>
	<para>can do a mix of the two solutions above: monitor the memory usage for the data model to 
	  enable to "cache" some rows and discard some when memory is needed</para>
      </listitem>
    </itemizedlist>
    Note that the methods mentionned in the 1st and 3rd items should be reserved for random data access mode, 
    and that cursor based access mode should implement the method mentionned in th 2nd item.
  </para>
  <sect2>
    <title>fetch_nb_rows()</title>
    <para>
      This method is called when the user calls <link linkend="gda-data-model-get-n-rows">gda_data_model_get_n_rows ()</link>.
    </para>
    <para>
      Note that the number of rows of the data model may not be known until the cursor has reached the last row of
      the recordset.
      Once known, the number of rows can be stored in the <structfield>advertized_nrows</structfield>'s member of the
      <link linkend="GdaDataSelect">GdaDataSelect</link> object.
    </para>
  </sect2>

  <sect2>
    <title>fetch_random()</title>
    <para>
      This method is called when the user calls <link linkend="gda-data-model-get-value-at">gda_data_model_get_value_at ()</link>,
      and in available only when the data access mode for the data model is random (that is not cursor based). When data
      access is cursor based, this method will not be called.
    </para>
  </sect2>

  <sect2>
    <title>store_all()</title>
    <para>
      This method is called when the user sets the "store-all-rows" to TRUE. It has the effect of forcing the creation
      of a <link linkend="GdaRow">GdaRow</link> object for each row of the data model (thus increasing the memory consumption
      but reducing further access times). It is available only when the data access mode for the data model is random 
      (that is not cursor based). When data access is cursor based, this method will not be called.
    </para>
  </sect2>

  <sect2>
    <title>fetch_next()</title>
    <para>
      This method is called when data access is cursor based and a data model iterator is moved one position forward. The
      <parameter>rownum</parameter> is an indication of what the row number will be once the next row has been fetched (it can 
      safely be discarded if that information is not necessary).
    </para>
  </sect2>

  <sect2>
    <title>fetch_prev()</title>
    <para>
      This method is called when data access is cursor based and a data model iterator is moved one position backward. The
      <parameter>rownum</parameter> is an indication of what the row number will be once the previous row has been fetched (it can 
      safely be discarded if that information is not necessary).
    </para>
  </sect2>

  <sect2>
    <title>fetch_at()</title>
    <para>
      This method can be implemented when data access is cursor based and there is a shorter way of getting to a
      specific row than having to call the fetch_next() or fetch_prev() methods several times.
    </para>
  </sect2>
</chapter>

<chapter id="libgda-provider-blobop">
  <title>Virtual methods for Blob operations</title>
  <para>
    Blobs are a special feature of databases because they allow one to access the contents of a "cell" from the
    API without using SQL (usually no SQL can be used to manipulate a blob's contents: an SQL statement is used to
    create, delete or retreive a blob, but the contents is accessed through the API).
  </para>
  <para>
    &LIBGDA; encapsulates all blob operations in objects which must be implemented by each provider if they want to support
    blobs; otherwise binary data may still be used if supported by the database, but the whole binary data is transfered in
    the SQL statement which is not suitable for large data.
  </para>
  <para>
    &LIBGDA; defines <link linkend="GdaBlop">GdaBlob</link> structure which is an extension of the
    <link linkend="GdaBinary">GdaBinary</link> structure (which contains a pointer to some data and the size of the pointed
    data). The extension simply adds a pointer to a <link linkend="GdaBlopOp">GdaBlobOp</link> object which has
    to be implemented by each provider which supports blobs. The following documents the
    <link linkend="GdaBlopOp">GdaBlobOp</link>'s virtual methods which actually implement the reading from and
    writing to a blob contained in the database.
  </para>
  <para>
    When reading from a blob in the database or writing to a blob in the database, data read or written is the stored in
    the <link linkend="GdaBinary">GdaBinary</link> part of the <link linkend="GdaBlopOp">GdaBlobOp</link>.
  </para>
  <sect2>
    <title>get_length()</title>
    <para>
      This method returns the total length of a blob in bytes. In case of error, -1 is returned and the
      provider should have added an error (a <link linkend="GdaConnectionEvent">GdaConnectionEvent</link>) to the connection.
    </para>
  </sect2>

  <sect2>
    <title>read()</title>
    <para>
      This method requests that some data be read from the blob. The data read must be stored in the
      <link linkend="GdaBinary">GdaBinary</link> part of the <parameter>blob</parameter> parameter. The data to read is
      the data starting at the <parameter>offset</parameter> offset from the beginning of the blob, and
      of the <parameter>size</parameter> length.
    </para>
    <para>
      Note that in this method, the <structfield>op</structfield> attribute of the <parameter>blob</parameter>
      parameter is not used.
    </para>
    <para>
      The returned value is the number of bytes read, or -1 if an error
      occured (then the provider should have added an error to the connection).
    </para>
  </sect2>

  <sect2>
    <title>write()</title>
    <para>
      This method requests the some data be written to the blob. The data has to be written
      in the blob starting at the <parameter>offset</parameter> offset from the beginning of the blob.
    </para>
    <para>
      If the <structfield>op</structfield> attribute of the <parameter>blob</parameter> parameter is not NULL and is different
      than the <parameter>op</parameter>, then the data to be written is the complete contents of the data stored in the
      blob represented by the <structfield>op</structfield> attribute of the <parameter>blob</parameter> parameter. Otherwise
      The data to be written is stored in the
      <link linkend="GdaBinary">GdaBinary</link> part of the <parameter>blob</parameter>.
    </para>
    <para>
      The returned value is the number of bytes written, or -1 if an error
      occured (then the provider should have added an error to the connection).
    </para>
  </sect2>

  <sect2>
    <title>write_all()</title>
    <para>
      This method requests that all the contents of the blob be replaced by some data (if necessary the
      blob is truncated from its previous length). The data to be written is the same as for the write() method, and
      the returned value is also the same.
    </para>
    <para>
      If this virtual method is not implemented, then the write() virtual method is used with an <parameter>offset</parameter>
      parameter of 0.
    </para>
  </sect2>
</chapter>

<chapter id="libgda-provider-parser">
  <title>SQL parser</title>
  <para>
    &LIBGDA; implements a generic SQL parser which creates <link linkend="GdaStatement">GdaStatement</link> objects from
    an SQL string. If the database provider needs to implement its own parser because the generic one does not handle
    the database specific SQL syntax, it can be done using instructions in this chapter. Otherwise, the provider's sources
    can be cleared of any code related to the parser.
  </para>
  <sect1>
    <title>Implementation overview</title>
    <para>
      This section describes how the generic SQL parser and a provider specific parser are built regarding the files
      and programs which are involved.
    </para>
    <sect2>
      <title>Generic SQL parser</title>
      <para>
	The <link linkend="GdaSqlParser">GdaSqlParser</link> object can parse any SQL string of any SQL dialect,
	while always identifying the variables (which have a &LIBGDA;'s specific syntax) in the string. If the parser
	can identify a structure in the SQL string it understands, then it internally builds a
	<link linkend="GdaSqlStatement">GdaSqlStatement</link> structure of the correct type, and if it cannot then is simply
	delimits parts in the SQL string to identify variables and also builds a
	<link linkend="GdaSqlStatement">GdaSqlStatement</link> structure but of 
	<link linkend="GDA-SQL-STATEMENT-UNKNOWN:CAPS">GDA_SQL_STATEMENT_UNKNOWN</link>. If the string
	cannot be delimited and variables identified, then it returns an error (usually there is a quotes mismatch problem
	within the SQL string).
      </para>
      <para>
	Failing to identify a known structure in the SQL string can have several reasons:
	<itemizedlist>
	   <listitem><para>the SQL string is not one of the known types of statements (see 
	       <link linkend="GdaSqlStatementType">GdaSqlStatementType</link>)</para></listitem>
	   <listitem><para>the SQL uses some database specific extensions</para></listitem>
	</itemizedlist>
      </para>
      <para>
	The generic SQL parser implementation has its source files in the 
	<filename class="directory">libgda/sql-parser</filename> directory; the files which actually implement
	the parser itself are the <filename>parser.y</filename>, <filename>delimiter.y</filename> and
	 <filename>parser_tokens.h</filename> files:
	 <itemizedlist>
	   <listitem><para>The <filename>parser.y</filename> file contains the grammar used by the parser</para></listitem>
	   <listitem><para>The <filename>delimiter.y</filename> file contains the grammar used by the parser when it 
	       is operating as a delimiter</para></listitem>
	   <listitem><para>The <filename>parser_tokens.h</filename> defines some hard coded tokens</para></listitem>
	 </itemizedlist>
      </para>
      <para>
	The parser grammar files use the <ulink url="http://www.hwaci.com/sw/lemon/">Lemon parser generator</ulink> syntax
	which is a LALR parser similar to <application>YACC</application> or <application>bison</application>. The lexer part
	however is not <application>LEX</application> but is a custom one integrated in the
	<filename>gda-sql-parser.c</filename> file (this allows a better integration between the lexer and parser parts).
      </para>
      <para>
	The following figure illustrates the files involved and how they are produced and used to create
	the generic SQL parser.
	<mediaobject>
          <imageobject role="html">
            <imagedata fileref="parser_gen.png" format="PNG"/>
          </imageobject>
          <textobject> 
            <phrase>Generic SQL parser's implementation</phrase>
          </textobject>
	</mediaobject>
	<itemizedlist>
	   <listitem><para>The white background indicate files which are sources
	       (part of &LIBGDA;'s distribution)</para></listitem>
	   <listitem><para>The blue background indicate files that they are produced dynamically</para></listitem>
	   <listitem><para>The pink background indicate programs that are compiled and used themselves in
	       the compilation process to generate files. These programs are:
	       <itemizedlist>
		 <listitem><para><application>lemon</application>: the lemon parser itself</para></listitem>
		 <listitem><para><application>gen_def</application>: generated the "converters" arrays (see blow)</para>
		 </listitem>
	       </itemizedlist>
	       Note that none of these programs gets installed (and when cross compiling, they are compiled as programs
	       executing on the host actually making the compilation).
	   </para></listitem>
	   <listitem><para>The green background identifies components which are reused when implementing provider specific
	       parsers</para></listitem>
	 </itemizedlist>
      </para>
      <para>
	The tokenizer (AKA lexer) generates values identified by the "L_" prefix (for example "L_BEGIN"). Because
	the GdaSqlParser object uses the same lexer with at least two different parsers (namely the parser and delimiter
	mentionned earlier), and because the Lemon parser generator generates its own value identifiers for tokens, there
	is a conversion step (the "converter" block in the diagram) which converts the "L_" prefixed tokens with the ones
	useable by each parser (both converters are defined as arrays in the <filename>token_types.h</filename> file.
      </para>
    </sect2>
    <sect2>
      <title>Provider specific SQL parser</title>
      <para>
	One wants to write a database specific SQL parser when:
	<itemizedlist>
	  <listitem><para>the SQL understood by the database differs from the generic SQL. For example
	      PostgreSQL associates priorities to the compound statement in a different way as the generic SQL.
	      In this case it is strongly recommended to write a custom SQL parser</para></listitem>
	  <listitem><para>the SQL understood by the database has specific extensions</para></listitem>
	</itemizedlist>
      </para>
      <para>
	Using the same background color conventions as the previous diagram, the following diagram illustrates
	the files involved and how they are produced and used to create a provider specific SQL parser:
      </para>
      <para>
	<mediaobject>
          <imageobject role="html">
            <imagedata fileref="parser_prov.png" format="PNG"/>
          </imageobject>
          <textobject> 
            <phrase>Provider specific SQL parser's implementation</phrase>
          </textobject>
	</mediaobject>
      </para>
      <para>
	The key differences are:
	<itemizedlist>
	  <listitem><para>The delimiter part of the <link linkend="GdaSqlParser">GdaSqlParser</link> object
	      is the same as for the generic SQL parser implementation</para></listitem>
	  <listitem><para>While the <application>lemon</application> program is the same as for the generic SQL parser,
	      the <application>gen_def</application> is different, and takes as its input the ".h" file produced by
	      the <application>lemon</application> program and the <filename>libgda/sql-parser/token_types.h</filename>.
	  </para></listitem>
	</itemizedlist>
      </para>
    </sect2>
  </sect1>
  <sect1>
    <title>Tips to write a custom parser</title>
    <para>
      <itemizedlist>
	<listitem><para>Write a new <filename>parser.y</filename> file (better to copy and adapt 
	    it than starting from scratch)</para></listitem>
	<listitem><para>Sub class the <link linkend="GdaSqlParser">GdaSqlParser</link> class and "connect" the
	    class's virtual methods to the new generated parser</para></listitem>
	<listitem><para>Start from the skeleton implementation</para></listitem>
      </itemizedlist>
    </para>
  </sect1>
  &libgda-GdaSqlStatement;
</chapter>

<chapter id="libgda-provider-pack">
  <title>Assembling all the parts</title>
  <para>
    A database provider is in fact a shared library which is loaded when &LIBGDA; is initialized. The skeleton implementations
    in <filename class="directory">providers/skel-implementation</filename> propose the following files layout (some of the files
    are not required for virtual providers).
  </para>
  <para> Of course this files layout is not required, but make it easy for maintenance. In the folloing list,
    the filenames here are the one for the "Capi" provider, and each provider should rename them:
    <itemizedlist>
      <listitem><para><filename>gda-capi.h</filename>: contains the provider name, the include files necessary to use the API and the
	  declaration of the provider's specific connection data</para></listitem>
      <listitem><para><filename>gda-capi-provider.[ch]</filename>: are the header and implementation files for the object
	  inheriting the <link linkend="GdaServerProvider">GdaServerProvider</link> object. This object must implement its
	  <link linkend="libgda-provider-class">virtual methods</link>.</para></listitem>
      <listitem><para><filename>gda-capi-recordset.[ch]</filename>: are the header and implementation files for the object
	  inheriting the <link linkend="GdaDataSelect">GdaDataSelect</link> object. This object must implement its
	  <link linkend="libgda-provider-recordset">virtual methods</link>.</para></listitem>
      <listitem><para><filename>gda-capi-ddl.[ch]</filename>: are the files implementing the DDL queries</para></listitem>
      <listitem><para><filename>gda-capi-parser.[ch]</filename>: are the header and implementation files 
	  for the object implementing a specific parser,
	  inheriting <link linkend="GdaSqlParser">GdaSqlParser</link>, see the PostgreSQL provider's implementation for 
	  example.</para></listitem>
      <listitem><para><filename>gda-capi-pstmt.[ch]</filename>: are the header and implementation files for the object
      representing prepared statement and inheriting <link linkend="GdaPStmt">GdaPStmt</link></para></listitem>
      <listitem><para><filename>gda-capi-blob-op.[ch]</filename>: are the header and implementation files for the object
	  inheriting the <link linkend="GdaBlobOp">GdaBlopOp</link> object. This object must implement its
	  <link linkend="libgda-provider-blobop">virtual methods</link>.</para></listitem>
      <listitem><para><filename>gda-capi-meta.[ch]</filename>: are the files where the meta-data information extraction
      is implemented.</para></listitem>
      <listitem><para><filename>libmain.c</filename>: file to make it possible for &LIBGDA; to identify the provider.</para></listitem>
      <listitem><para><filename>capi_specs_dsn.xml.in</filename>: file where the connection parameters are described, 
	  before being translated</para></listitem>
      <listitem><para><filename>libgda-capi-4.0.pc.in</filename>: file to be used by <command>pkg-config</command> to identify
	  the provider, before being computed by the <command>configure</command> script.</para></listitem>
      <listitem><para>other .xml.in files: DDL queries' parameters, before translation</para></listitem>
    </itemizedlist>
  </para>

  <sect1>
    <title>libmain.c</title>
    <para>
      Once the shared library implementing the provider is loaded (and
      all the necessary dependencies are also loaded), &LIBGDA; tries to locate some functions to identify the provider (if any of
      these function is missing, then the DLL is unloaded and the provider is not availaibe).
    </para>
    <para>
      The skeleton implementations in <filename class="directory">providers/skel-implementation</filename> propose to implement those
      functions in a <filename>libmain.c</filename> file. The functions are the following ones:
    </para>
    <sect2>
      <title>plugin_init()</title>
      <para>This function initializes the plugin; it has a single argument which is the path where the provider is.
	As the module can be unloaded, any static data allocated here must be freed when the module is unloaded,
	in a <link linkend="GModuleUnload">g_module_unload()</link> function. If the module must not be
	unloaded, it must be made resident using <link linkend="g-module-make-resident">g_module_make_resident()</link>, 
	in a <link linkend="GModuleCheckInit">g_module_check_init()</link> function</para>
      <para>Note that after a <link linkend="GdaServerProvider">GdaServerProvider</link> object has been 
	created (ie after plugin_create_provider() has
	been called once), the module will not be unloaded anymore.</para>
    </sect2>
    <sect2>
      <title>plugin_get_name()</title>
      <para>This funtion returns the name of the provider, it <emphasis>must</emphasis> return the same string as what the
	<link linkend="prov-get-name">get_name()</link>'s provider's virtual method returns.</para>
    </sect2>
    <sect2>
      <title>plugin_get_description()</title>
      <para>This funtion returns a description of the provider.</para>
    </sect2>
    <sect2>
      <title>plugin_get_dsn_spec()</title>
      <para>This function returns a description of the parameters which have or can be set when opening a connection. This
	description uses an XML syntax and is usually stored in a separate XML file (for easier translation).</para>
      <para>Here is an example, when only one "DB_NAME" parameter is required:
	<programlisting>
&lt;?xml version="1.0"?&gt;
&lt;data-set-spec&gt;
  &lt;parameters&gt;
    &lt;parameter id="DB_NAME" _name="Database name" _descr="The name of a database to use" gdatype="gchararray" nullok="FALSE"/&gt;
  &lt;/parameters&gt;
&lt;/data-set-spec&gt;
	</programlisting>
	Note that the the attributes which have a name starting with an underscore should be translated (see the
	<filename>Makefile.am</filename> file for some example on ho this is done).
      </para>
    </sect2>
    <sect2>
      <title>plugin_get_auth_spec()</title>
      <para>
	This function returns a description of the authentication information required by the provider. If the
	only information is a username/password pair, then it is not necessary to implement that function.
      </para>
      <para>
	However, if a username is required, then it must be name "USERNAME", and if a password is required,
	it must be named "PASSWORD".
      </para>
    </sect2>
    <sect2>
      <title>plugin_create_provider()</title>
      <para>This function actually instanciates a provider object and returns it.</para>
    </sect2>
  </sect1>

</chapter>

