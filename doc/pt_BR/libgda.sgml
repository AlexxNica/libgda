<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook V4.1//EN"[

<!entity Libgda "<application>libgda</application>">
<!entity gda-gda-common SYSTEM "gda-common.sgml">
<!entity gda-gda-clnt SYSTEM "gda-clnt.sgml">
<!entity gda-gda-clnt-ui SYSTEM "gda-clnt-ui.sgml">
<!entity gda-gda-srv SYSTEM "gda-srv.sgml">
]>

<book id="libgda">
  <bookinfo>
    <title>GNU Data Access</title>
    <authorgroup>
      <author>
        <firstname>Michael</firstname>
        <surname>Lausch</surname>
        <affiliation>
          <address><email>michael.lausch@1012surf.net</email></address>
        </affiliation>
      </author>
      <author>
        <firstname>Rodrigo</firstname>
        <surname>Moya</surname>
        <affiliation>
          <address><email>rodrigo@gnome-db.org</email></address>
        </affiliation>
      </author>
      <author>
        <firstname>Vivien</firstname>
        <surname>Malerba</surname>
        <affiliation>
          <address><email>malerba@linuxave.net</email></address>
        </affiliation>
      </author>
      <author>
	<firstname>Cleber</firstname>
	<surname>Rodrigues</surname>
	<affiliation>
          <address><email>cleberrrjr@bol.com.br</email></address>
        </affiliation>
      </author>
    </authorgroup>
    <date>1999 February</date>
    <copyright>
      <year>1999-2000</year>
      <holder>The Free Software Foundation</holder>
    </copyright>
    <title>Manual Da &Libgda;</title>
    <abstract>
      <para>
        GNU Data Access (GDA) &eacute; um arquitetura cujo objetivo &eacute; prover acesso universal
	a diferentes tipos de fontes de dados. Desde os tradicionais bancos de dados
	relacionais, a qualquer fonte de dados imagin&aacute;vel, como por exemplo um servidor
	e-mail, um diret&oacute;rio LDAP...
      </para>
      <para>
        Esta universalidade &eacute; obtida atrav&eacute;s do uso de CORBA como mecanismo para
	comunica&ccedil;&atilde;o entre os diferentes componentes da arquitetura.
      </para>
    </abstract>
    <legalnotice>
      <para>
        Este documente pode ser distribuido sob os termos e
	condi&ccedil;&otilde;es estabelecidas na Open Publication License, v1.0 or
	superior (a vers&atilde;o mais atual est&aacute; sempre dispon&iacute;vel em <ulink
        url=" http://www.opencontent.org/openpub/"
        type="http">http://www.opencontent.org/openpub/</ulink> )
      </para>
    </legalnotice>
  </bookinfo>
  
  <chapter id="introduction">
    <title>Introdu&ccedil;&atilde;o</title>
    <para>
      ODBC e SQL s&atilde;o padr&otilde;es estabelecidos. O problema &eacute; que ODBC n&atilde;o especifica
      o protocolo de comunica&ccedil;&atilde;o e n&atilde;o existem drivers para alguns bancos de dados.
      Voc&ecirc; pode usar RPC, TCP/IP, ou mem&oacute;ria compartilhada e 'signals' para
      fazer os pedidos ao cliente ao servidor. Ent&atilde;o voc&ecirc; tem que usar uma biblioteca
      ODBC espec&iacute;fica a certo banco de cados. Esta biblioteca pode n&atilde;o estar dispon&iacute;vel
      para a CPU ou sistema operacional na qual o cliente est&aacute; rodando.
    </para>
    <para>
      SQL n&atilde;o &eacute; padronizado suficientemente, de maneira que compatibilidade de c&oacute;digo
      n&atilde;o pode ser garantida para todos os servidores de banco de dados. E para
      alguns tipos de servidores, SQL n&atilde;o &eacute; nem mesmo cogit&aacute;vel (pense em LDAP).
    </para>
    <para>
      GDA tenta atavar o problema do ODBC e ajud&aacute;-lo com o problema
      do SQL. &Eacute; um tipo de middleware (ou pode ser expadido para ser
      uma camada middleware) para acessar diferentes fontes de dados.
      GDA oferece uma vis&atilde;o bastante abstrata (high level) das fontes de dados 
      e possui locais onde voc&ecirc; pode encaixar componentes espec&iacute;ficos a certa
      tarefa (low level) para acessar estes dados.
    </para>
    <para>
      GNU Data Access (GDA) &eacute; definido em um conjunto de interfaces CORBA IDL. O n&iacute;vel
      de abstra&ccedil;&atilde;o provido pelo GDA torna poss&iacute;vel o acesso a qualquer tipo de fonte
      de dados, desde que um servidor CORBA que implemente estas interfaces IDL e acesse
      esta fonte de dados seja escrito.
    </para>
    <para>
      &Libgda; &eacute; uma implementa&ccedil;&atilde;o das interfaces CORBA GDA, usando <ulink
      url="http://www.labs.redhat.com/orbit/" type="http">ORBit</ulink> como implementa&ccedil;&atilde;o 
      CORBA. Isso significa que, em teoria, seria poss&iacute;vel implementar &Libgda; para um outro
      CORBA ORB ou sistema operacional, desde que suporte a COBRA esteja presente nesse
      sistema.
    </para>
    <para>
      Este tr&aacute;s uma camada acima das rotinas internas CORBA, trazendo todo o poder nativo da arquitetura 
      CORBA a programadores que n&atilde;o precisam ter conhecimento do mesmo. Este vem com diversas
      bibliotecas, para ambos clientes e servidores, implementadas em C. Este n&iacute;vel de abstra&ccedil;&atilde;o
      torna poss&iacute;vel a posterior mudan&ccedil;a do funcionamento interno sem a necessidade de altera&ccedil;&atilde;o
      nas aplica&ccedil;&otilde;es que utilizam estas bibliotecas, como tamb&eacute;m mas importantemente, manter
      desenvolvedores de aplica&ccedil;&otilde;es longe das cont&iacute;nuas mudan&ccedil;as nas APIs relacionadas a CORBA
      em uso, como por exemplo OAF, GConf...
    </para>
    <para>
      Junto com estas bibliotecas (e 'header files' e 'language bindings' para desenvolvimento),
      &Libgda; traz v&aacute;rias ferramentas e utilit&aacute;rios para ajud&aacute;-lo na tarefa de desenvolver
      aplica&ccedil;&otilde;es baseadas em &Libgda;, bem como automatizar algumas tarefas relacionadas ao
      banco de dados.
    </para>
    <para>
      &Libgda; &eacute; implementada para sistemas operacionais tipo Unix (incluindo Linux), e n&atilde;o
      depende de outras bibliotecas exceto por ORBit, GConf, OAF e Glib, o que o faz um
      sistema bastante leve, ideal para aplica&ccedil;&otilde;es que rodar&atilde;o em sistemas com recursos 
      de hardware limitados. &Libgda; j&aacute; foi parte do projeto GNOME-DB, na verdade ainda &eacute;, mas
      tem sido separado para que aplica&ccedil;&otilde;es "n&atilde;o GNOMificadas" sejam desenvolvidas baseadas 
      na mesma.
    </para>
  </chapter>
  
  <chapter id="architecture">
    <title>Arquitetura da &Libgda;</title>
    <para>
      &Libgda; &eacute; composta por tr&ecirc;s camadas independentes. A camada inferior &eacute;
      composta pelos provedores GDA, que s&atilde;o servidores CORBA cuja tarefa &eacute;
      mapear a API espec&iacute;fica a determinada fonte de dados ao modelo GDA.
      Ou seja, eles s&atilde;o objetos CORBA que implementam a interface CORBA GDA.
    </para>
    <para>
      A camada do meio &eacute; a utilizada diretamente por aplica&ccedil;&otilde;es desenvolvidas com &Libgda:
      um biblioteca que encapsula o c&oacute;digo CORBA, escondendo toda a complexidade inerente
      ao CORBA da sua aplica&ccedil;&atilde;o. Esta camada tamb&eacute;m inclui v&aacute;rias fun&ccedil;&otilde;es utilit&aacute;rias para
      ajud&aacute;-lo no desenvolvimento de aplica&ccedil;&otilde;es baseadas em GDA.
    </para>
    <para>
      Finalmente, em cima de tudo isso est&atilde;o os programas distribu&iacute;dos com o restante
      do pacote GDA, bem como qualquer aplica&ccedil;&atilde;o que faz uso das bibliotecas GDA.
    </para>
    <para>
      &Libgda; &eacute; baseado em CORBA e utiliza <ulink
      url="http://www.labs.redhat.com/ORBit" type="http">ORBit</ulink> como 
      implementa&ccedil;&atilde;o CORBA. Basicamente o sistema fornece um arquivo IDL como
      a interface para o cliente. Para cada diferente fonte de dados (ODBC,
      Sybase, Informix, MySQL, LDAP, ...) um servidor deve ser escrito. Este
      servidor &eacute; preferencialmente um biblioteca compartilhada linkada a um pequeno
      programa (driver) para formar um servidor CORBA independente. Desta maneira
      &eacute; possivel usar o servidor como uma biblioteca para o cliente, aumentando
      a efici&ecirc;ncia (nem sockets nem 'context switches' s&atilde;o neces&aacute;rios, uma vez
      o c&oacute;digo est&aacute; rodando na mesma m&aacute;quina e no mesmo espa&ccedil;o de mem&oacute;ria).
    </para>
    <para>
      A vantagem de se usar um servidor CORBA &eacute; que o servidor pode rodar
      em um outra m&aacute;quina, balanceando a carga. Isto &eacute; poss&iacute;vel porque ORBit &eacute;
      pequeno e r&aacute;pido. Voc&ecirc; pode usar o mesmo servidor de um linguagem de script
      que entenda CORBA e voc&ecirc; pode fazer 'tracing' e controle de transa&ccedil;&otilde;es
      no servidor, sem necessidades de altera&ccedil;&otilde;es no cliente.
      A desvantagem &eacute; que se tal provedor "der pau"
      todos os clientes s&atilde;o desconectados do banco de dados. Para
      superar este problema &eacute; poss&iacute;vel que cada cliente requeira
      um nova c&oacute;pia do provedor (entretanto, a API para o cliente ainda
      n&atilde;o tem esta op&ccedil;&atilde;o).
    </para>
    <para>
          Os outros tipos de provedores s&atilde;o <emphasis>bibliotecas
	  compartilhadas</emphasis>. Estes provedores s&atilde;o linkados
	  ao cliente quando o cliente requer algo do provedor.
	  A desvantagem &eacute; que o servidor e o cliente t&ecirc;em que estar 
	  na mesma m&aacute;quina. Mas qualquer problema com o servidor
	  afetara somente um cliente. O custo de inicializa&ccedil;&atilde;o &eacute;
	  compar&aacute;vel ao do provedor execut&aacute;vel. A grande vantagem deste
	  tipo de provedor &eacute; que a depura&ccedil;&atilde;o do c&oacute;digo do provedor &eacute;
	  mais simples, uma vez que voc&ecirc; n&atilde;o pode anexar GDA a um
	  provedor j&aacute; rodando e voc&ecirc; pode tamb&eacute;m apanhar error durante
	  a inicializa&ccedil;&atilde;o do servidor.
	</para>
	<para>
	  Por padr&atilde;o cada provedor GDA &eacute; dispon&iacute;vel como execut&aacute;vel
	  e como biblioteca compartilhada. O processo de compila&ccedil;&atilde;o e as
	  conven&ccedil;&otilde;es usadas para implementar o provedor se asseguram que
	  os execut&aacute;veis e bibliotecas compartilhadas sejam compiladas
	  e instaladas. Ou seja, provedores GDA s&atilde;o implementados em bibliotecas
	  compartilhadas que s&atilde;o ent&atilde;o linkadas a um pequeno programa que age
	  exatamente como um driver para a biblioteca compartilhada.
	</para>
  </chapter>
  
  <chapter id="installation">
    <title>Instala&ccedil;&atilde;o</title>
    <sect1 id="installation-introduction">
      <title>Introdu&ccedil;&atilde;o</title>
      <para>
        Voc&ecirc; pode sempre encontrar em nosso web site, pacotes para RedHat e Debian,
	por isso voc&ecirc; n&atilde;o deve ter nenhum problema instalando-os. Para uma instala&ccedil;&atilde;o
	padr&atilde;o, n&atilde;o h&aacute; nada mais a ser feito; por&eacute;m seria bom que voc&ecirc; conhecesse sobre
	a parte de configura&ccedil;&atilde;o CORBA e GDA, em caso que voc&ecirc; venha a fazer um instala&ccedil;&atilde;o
	fora do padr&atilde;o, ou em casos de problemas durante a instala&ccedil;&atilde;o.
      </para>
    </sect1>
    <sect1 id="installation-installing">
      <title>Instalando</title>
      <para>
        A instala&ccedil;&atilde;o depende do formato que voc&ecirc; resolveu fazer download.
	Se voc&ecirc; tem um pacote como RPM ou DEB, procure na documenta&ccedil;&atilde;o
	do seu gerenciador de pacotes por como fazer para instalar novos pacotes.
      </para>
      <para>
        Se voc&ecirc; optou pelo c&oacute;digo fonte (em um tarball), voc&ecirc; precisa
	compilar o software. Para faz&ecirc;-lo, um vez que voc&ecirc; tenha descompactado
	o tarball e re-criado toda a estrutra (diret&oacute;rios, arquivos) 
	do c&oacute;digo fonte, entre com:
        <programlisting>
          ./configure
          make
          make install
        </programlisting>
      </para>
      <para>
        Este processo gerar&aacute; os makefiles espec&iacute;ficos para sua plataforma,
	compilar&aacute; todo o c&oacute;digo, e instalar&aacute; os bin&aacute;rios e
	a documenta&ccedil;&atilde;o no seu sistema.
      </para>
      <para>
        Se voc&ecirc; n&atilde;o encontrar o arquivo <filename>configure</filename>, deve
	haver um outro chamado <filename>autogen.sh</filename>. Nessse caso,
	execute <filename>autogen.sh</filename>, que criar&aacute; o arquivo
	<filename>configure</filename> e consequentemente o executar&aacute;.
      </para>
      <para>
        Voc&ecirc; pode especificar v&aacute;rios argumentos ao comando <filename>configure</filename>
	(ou ao comando <filename>autogen.sh</filename>). Os mais importantes seguem (voc&ecirc; 
	pode ver todos as op&ccedil;&otilde;es de argumentos executando <filename>configure --help</filename>:
      </para>
      <itemizedlist mark="bullet">
        <listitem>
          <para>
            --prefix=&lt;diret&oacute;rio&gt;: Prefixo onde programa ser&aacute; instalado
          </para>
        </listitem>
        <listitem>
          <para>
            --with-mysql=&lt;diret&oacute;rio&gt;: Diret&oacute;rio onde as bibliotecas MySQL 
	    est&atilde;o instaladas
          </para>
        </listitem>
        <listitem>
          <para>
            --with-postgres=&lt;diret&oacute;rio&gt;: Diret&oacute;rio onde as bibliotecas PostgreSQL
            est&atilde;o intaladas
          </para>
        </listitem>
        <listitem>
          <para>
            --with-sybase=&lt;diret&oacute;rio&gt;: Diret&oacute;rio onde as bibliotecas Sybase
            est&atilde;o intaladas
          </para>
        </listitem>
        <listitem>
          <para>
            --with-ldap=&lt;diret&oacute;rio&gt;: Diret&oacute;rio onde as bibliotecas LDAP
            est&atilde;o intaladas
          </para>
        </listitem>
        <listitem>
          <para>
            --with-oracle=&lt;diret&oacute;rio&gt;: Diret&oacute;rio onde as bibliotecas ORACLE
            est&atilde;o intaladas
          </para>
        </listitem>
        <listitem>
          <para>
            --with-interbase=&lt;diret&oacute;rio&gt;: Diret&oacute;rio onde as bibliotecas Interbase
            est&atilde;o intaladas
          </para>
        </listitem>
        <listitem>
          <para>
            --with-mdb=&lt;diret&oacute;rio&gt;: Diret&oacute;rio onde as bibliotecas MDB
	    est&atilde;o instaladas
          </para>
        </listitem>
      </itemizedlist>
      <para>
        Normalmente provedores n&atilde;o s&atilde;o instalados, voc&ecirc; dese adicionar estes
	argumentos quando executar <filename>configure</filename>.
      </para>
      <para>
        Se voc&ecirc; encontrar algum problema durante a configura&ccedil;&atilde;o, compila&ccedil;&atilde;o ou
	instala&ccedil;&atilde;o, n&atilde;o hesite em contactar a lista-de-discuss&atilde;o GNOME-DB
	(gnome-db-list@gnome.org, mas primeiro voc&ecirc; precisa se inscrever na
	lista. Envie um e-mail para gnome-db-list-request@gnome.org com a 
	palavra 'SUBSCRIBE' no campo 'Assunto', caso voc&ecirc; ainda n&atilde;o tenha o feito).
      </para>
    </sect1>
    <sect1 id="installation-configuring">
      <title>Configurando</title>
      <para>
        Dependendo do que voc&ecirc; vai fazer com o &Libgda;, pode ser que voc&ecirc; tenha
	que mergulhar no c&oacute;digo, mas n&atilde;o tenha medo, ele foi teito com facilidade
	de uso em mente.
      </para>
      <sect2>
        <title>Configurando para desenvolvimento</title>
        <para>
	  Se voc&ecirc; quer desenvolver aplica&ccedil;&atilde;o usando &Libgda;, voc&ecirc; deve instalar o
	  pacote libgda-dev[el] se voc&ecirc; est&aacute; usando um sistema baseado em Debian
	  ou RedHat. Se voc&ecirc; mesmo compilou o programa, arquivos necess&aacute;rios para
	  desenvolvimento j&aacute; est&atilde;o instalados no seu sistema.
        </para>
        <para>
	  O &uacute;nico coisa voc&ecirc; que voc&ecirc; precisa fazer para ver se tudo est&aacute; instalado, &eacute;
	  verificar se as bibliotecas e programas do &Libgda; s&atilde;o vistas pelo sistema.
	  Isto &eacute;, fazer com que o diret&oacute;rio <filename>bin/</filename> do &Libgda; esteja
	  na vari&aacute;vel de ambiente <filename>PATH</filename>, t&atilde;o bem como o diret&oacute;rio
	  <filename>lib/</filename> esteja em <filename>LD_LIBRARY_PATH</filename> (ou
	  no arquivo <filename>/etc/ld.so.conf</filename>).
        </para>
      </sect2>
      <sect2>
        <title>Configura&ccedil;&atilde;o para acessar um banco de dados</title>
        <para>
	  Se voc&ecirc; quer acessar uma fonte de dados atrav&eacute;s de um provedor GDA, voc&ecirc; precisa
	  primeniramente ter acesso a este provedor e, mais importante, este provedor deve
	  ter acesso a fonte de dados espec&iacute;fica. Tenha ent&atilde;o, antes de tudo, seu banco de
	  dados rodando. Para isso, voc&ecirc; deve pesquisar como faz&ecirc;-lo na documenta&ccedil;&atilde;o
	  do seu banco de dados ou na se&ccedil;&atilde;o espec&iacute;fica a este provedor na documenta&ccedil;&atilde;o do
	  &Libgda;.
        </para>
        <para>
	  Uma vez que tenha seu provedor GDA instalado, seja ele localmente ou em outra
	  m&aacute;quina via rede, voc&ecirc; precisa configurar seu sistema para ter acesso ao provedor.
	  Se voc&ecirc; est&aacute; fazendo um instala&ccedil;&atilde;o local, uma vez que voc&ecirc;tenha instalado o provedor
	  GDA (compilando ou instalando atrav&eacute;s de um pacote RPM ou Debia, por exemplo), o
	  provedor j&aacute; est&aacute; viz&iacute;vel na sua m&aacute;quina. Isto &eacute; porque o pacote com o provedor
	  fornece um arquivo <filename>.oafinfo</filename> na qual ele especif&iacute;ca o lugar
	  onde este est&aacute; instalado e outras informa&ccedil;&otilde;es sobre si mesmo.
        </para>
        <para>
	  Se, pelo contr&aacute;rio, seu provedor est&aacute; em uma outra m&aacute;quina, voc&ecirc; ter&aacute; que criar
	  um arquivo <filename>.oafinfo</filename>. Para isso, verifique a documenta&ccedil;&atilde;o de
	  instala&ccedil;&atilde;o do OAF.
        </para> 
       <para>
          Ent&atilde;o, o pr&oacute;ximo passo &eacute; configurar as fontes de dados que voc&ecirc; quer dispon&iacute;veis
	  no seu sistema. Para fazer isso, voc&ecirc; deve, por enquanto, usar o <application>GNOME-DB</application>,
	  que &eacute; um 'frontend' do &Libgda; do projeto <ulink url="http://www.gnome.org" type="http">GNOME</ulink>.
          <footnote>
	       <para>
	         Seria um boa id&eacute;ia acrescentar uma ferramento tipo linha-de-comando para
		 controlar a configura&ccedil;&atilde;o, como atualmente, usando GConf, n&atilde;o &eacute; uma quest&atilde;o
		 simples como editar um arquivo de texto, como era antes, com a fun&ccedil;&atilde;o
		 <function>gnome_config</function>. A API para fazer isso j&aacute; est&aacute; dispon&iacute;vel
		 na biblioteca <filename>libgda-common</filename>, ent&atilde;o isso seria muito
		 f&aacute;cil de ser feito.
		 Volunt&aacute;rios?
	       </para>
	     </footnote>
	   </para>
	   <para>
	     Ferramentas tipo linha-de-comando ser&atilde;o fornecidas com o &Libgda; para fazer uso
	     do Libgda atualmente, voc&ecirc; precisa saber quais informa&ccedil;&otilde;es s&atilde;o necess&aacute;rias para
	     se configurar um fonte de dados.
	   </para>
	   <para>
	     Um dos problemas que GDA resolve &eacute; o processo de dar
	     nomes as fontes de dados. Cada sistema de banco de dados
	     tem a sua pr&oacute;pria maneira de definir nomes para as fontes
	     de dados. Por exemplo, MySQL usa o hostname, n&uacute;mero da porta,
	     e nome do banco de dados. Outros bancos de dados, como Solid,
	     usam apenas o hostname e n&uacute;mero da porta. N&atilde;o h&aacute; suporte h&aacute;
	     m&uacute;ltiplos bancos de dados por servidor. J&aacute; que o cliente
	     n&atilde;o precisa de todos estes detalhes, a configura&ccedil;&atilde;o do &Libgda;
	     define todas as informa&ccedil;&otilde;es de tal fonte de dados, de maneira que
	     o servidor (de banco de dados) correto possa ser contactado.
	     Esta informa&ccedil;&atilde;o &eacute; obtida pela biblioteca cliente e enviada ao
	     provedor, que ent&atilde;o, examina a informa&ccedil;&atilde;o e decide qual banco de
	     dados o cliente deve se conectar. A informa&ccedil;&atilde;o armazenada para
	     cada fonte de dados &eacute; a seguinte:
	     <programlisting>
	       [vendas]
		  Provider=gda-mysql
		  DSN=DATABASE=teste;HOST=localhost;PORT=1111
		  Description=Banco de dados MySQL para testes em modo nativo
		  Configurator=None
	     </programlisting>
	     <programlistingco>
	       <calloutlist>
	         <callout arearefs='Providers'>
		      <para>
		        O provedor para este banco de dados &eacute; o gda-mysql.
			O valor deste campo &eacute; usado como ID do objeto
			para ativa&ccedil;&atilde;o por parte do OAF.
		     </para>
		   </callout>
		   <callout arearefs='DSN'>
		     <para>
		       Este campo &eacute; o mais importante. O valor deste
		       campor &eacute; a string enviada ao provedor para
		       que ela saiba que fonte de dados acessar. Como
		       este valor &eacute; interpretado por um determinado 
		       provedor &eacute; descrito na se&ccedil;&atilde;o relacionada ao mesmo.
		     </para>
		   </callout>
		   <callout arearefs='Description'>
		     <para>
		       Este campo &eacute; uma breve descri&ccedil;&atilde;o da fonte de dados.
		       Ele existe por pura conveni&ecirc;ncia e n&atilde;o tem nenhuma
		       outra fun&ccedil;&atilde;o.
		     </para>
		   </callout>
	      </calloutlist>
	    </programlistingco>
	   </para>
      </sect2>
      <sect2>
        <title>Informa&ccedil;&atilde;o espec&iacute;fica a um Provedor</title>
        <para>
	  Esta se&ccedil;&atilde;o traz informa&ccedil;&atilde;o espec&iacute;fica a cada tipo de 
	  provedor dispon&iacute;vel para &Libgda;.
        </para>
      </sect2>
    </sect1>
  </chapter>
  
  <chapter>
    <title>Biblioteca Comum GDA (GDA Common Library)</title>
    <para>
      A biblioteca comum cont&ecirc;m um rico conjunto de fun&ccedil;&otilde;es de utilidade
      a ambos servidores e clientes GDA, e que pode facilmente ser utilizado
      em outras aplica&ccedil;&otilde;es.
    </para>
    <sect1 id="gda-common-corba">
      <title>Fun&ccedil;&otilde;es CORBA</title>
      <para>
        Com objetivo de esconder todo c&oacute;digo CORBA, o arquivo 
	<filename>libgda-common</filename> inclui um conjunto de fun&ccedil;&otilde;es
	que oferecem acesso de baixo n&iacute;vel (low-level) a parte CORBA,
	em caso de voc&ecirc; precisar fazer algo especial.
      </para>
    </sect1>
    <sect1 id="gda-common-logs">
      <title>Logs</title>
      <para>
        A facilidade de logging provida pela pela biblioteca comum GDA
	usa um formato de arquivo especial que permite um f&aacute;cil obten&ccedil;&atilde;o
	de todas as mensagens registradas. Desta maneira, voc&ecirc; pode ver seus
	logs por data, hora, remover entradas, etc.
      </para>
    </sect1>
    <sect1 id="gda-common-xml-queries">
      <title>Consultas XML</title>
      <para>
      </para>
    </sect1>
    <sect1 id="gda-common-xml-databases">
      <title>Banco De Dados XML</title>
      <para>
        &Libgda; oferece um formato de arquivo XML especial concebido para
	representar a estrutura completa de um banco de dados. Este formato
	de arquivo &eacute; usado para importar/exportar dados de/para um banco
	de dados. Este formato &eacute; usado tamb&eacute;m pelo (ainda n&atilde;o existente)
	provedor XML, que simula um sistema de banco de dados usando
	os dados armazenados nesses arquivos.
      </para>
      <para>
        A biblioteca <filename>gda-common</filename> inclui um classe, chamada
	<classname>GdaXmlDataabse</classname>, que oferece uma maneira de
	ler e modificar estes arquivos.
      </para>
    </sect1>
  </chapter>

  <chapter>
    <title>Biblioteca Cliente GDA</title>
    <sect1 id="gda-client-introduction">
      <title>Introdu&ccedil;&atilde;o</title>
      <para>
        A biblioteca cliente "embrulha" a interface CORBA. A biblioteca
	cuida de aloca&ccedil;&atilde;o e libera&ccedil;&atilde;o de mem&oacute;ria quando voc&ecirc; n&atilde;o precisa
	mais dos resultados de uma consulta, ou quando voc&ecirc; fecha a conex&atilde;o
	com o banco de dados. Sua segunda fun&ccedil;&atilde;o &eacute; fazer caching, de maneira
	que &eacute; poss&iacute;vel navegar para frente e para tr&aacute;s dentro do resultado
	obtido com uma consulta, mesmo que o banco de dados n&atilde;o suporte
	um "cursor m&oacute;vel" (scrolling cursos). &Eacute; claro que as verifica&ccedil;&otilde;es 
	de consist&ecirc;ncia e estrat&eacute;gias de locking n&atilde;o s&atilde;o mais suportadas,
	acreditamos, por&eacute;m, que acharemos uma outra solu&ccedil;&atilde;o para isso.
      </para>
      <para>
        H&aacute; tamb&eacute;m suporte para controlar diferentes fontes de dados com
	diferentes servidores e caracter&iacute;sticas de conex&otilde;es. Para atingir
	este ponto o sistema de configura&ccedil;&atilde;o GConf &eacute; usado.
      </para>
      <para>
        Existe tamb&eacute;m fun&ccedil;&otilde;es utilit&aacute;rias para ajud&aacute;-lo com as v&aacute;rias
	tarefas relacionadas com bancos de dados. Essas incluem
	execu&ccedil;&atilde;o de comandos em s&eacute;rie (transa&ccedil;&otilde;es), acesso a provedores
	GDA, ...
      </para>
      <para>
        O conceito fundamental da biblioteca cliente &eacute; que o provedor
	deve permitir que voc&ecirc; conecte-se a v&aacute;rias fontes de dados.
	Tal provedor &eacute; um servidor corba implementado com ORBit. Um
	provedor deve prover uma interface para constru&ccedil;&atilde;o de conex&otilde;es
	(factory interface), que permite ao cliente solicitar ao
	servidor conex&otilde;es n&atilde;o inicializadas. A ativa&ccedil;&atilde;o do provedor &eacute;
	feita atrav&eacute;s do sistema de ativa&ccedil;&atilde;o OAF. OAF cuida da identifica&ccedil;&atilde;o
	do 'name server' e da registra&ccedil;&atilde;o do servidor CORBA (o provedor
	GDA), uma vez que este est&aacute; ativo. OAF tamb&eacute;m permite ao
	cliente escolher, se para cada nova conex&atilde;o constru&iacute;da
	um novo servidor deve ser inicializado ou se um j&aacute; em execu&ccedil;&atilde;o
	deve ser utilizado. Isto tr&aacute;z implica&ccedil;&otilde;es ao tempo necess&aacute;rio
	usado para iniciar a conex&atilde;o e ao n&uacute;mero de processos conectados
	ao servidor de bancos de dados (e por sua vez, o n&uacute;mero de
	licen&ccedil;as em uso, no caso de um banco de dados n&atilde;o livre).
      </para>
      <para>
           Para se conectar a uma fonte de dados, o cliente geralmente
	   deve passar alguma informa&ccedil;&atilde;o ao provedor. Primeiro o cliente
	   deve passar uma string descrevendo a conex&atilde;o para o provedor.
	   O provedor usa esta informa&ccedil;&atilde;o de maneira espec&iacute;fica para
	   para completar as informa&ccedil;&otilde;es necess&aacute;rias para estabelecer
	   uma conex&atilde;o com a fonte de dados. Essa informa&ccedil;&atilde;o pode ser
	   o nome do computador (hostname) e n&uacute;mero da porta, o nome
	   da biblioteca a ser carregada, enfim, o que for necess&aacute;rio
	   para a fonte de dados ser acessada. Adicionalmente o cliente
	   deve passar o nome do usu&aacute;rio e um senha para ser autorizado
	   a acessar o servidor da fonte de dados. O provedor n&atilde;o faz
	   nenhuma verifica&ccedil;&atilde;o quanto a autentica&ccedil;&atilde;o. Note tamb&eacute;m, que
	   que a conex&atilde;o entre o o cliente e o servidor n&atilde;o &eacute; encriptada,
	   ou seja, esse dados s&atilde;o enviados como texto puro e simples.
	   Isso n&atilde;o ser&aacute; mais verdade uma vez que ORBit suporte conex&otilde;es
	   encriptadas entre um servidor CORBA e seus clientes. Se esse
	   procedimento n&atilde;o &eacute; aceit&aacute;vel, use o provedor em forma de
	   biblioteca compartilhada.
      </para>
      <para>
        Depois que a conex&atilde;o &eacute; aberta, o cliente pode solicitar a fonte
	de dados informa&ccedil;&atilde;o sobre o dicion&aacute;rio de dados.  As sem&acirc;nticas
	dos dados retornados de tais consultas &eacute; altamente dependente
	do provedor e geralmente n&atilde;o &eacute; port&aacute;vel entre diferentes tipos
	de fontes de dados. Se os provedores pertecem a mesma classe
	(bancos de dados, por exemplo), essa informa&ccedil;&atilde;o ser&aacute; trocada
	entre ambos, mas n&atilde;o espere que o mesmo programa consultando
	um provedor LDAP e um provedor ODBC sem mudan&ccedil;as no c&oacute;digo fonte.
      </para>
      <para>
        O cliente pode entrar criar objetos <classname>GdaCommanda</classname>
	que s&atilde;o usados para fazer as consultas aos provedores. Para provedores
	tipo SQL, a consulta &eacute; o comando SQL. &Eacute; claro que o provedor &eacute; livre
	para alterar os estes comandos (convers&atilde;o entre dialetos SQL) e alguns
	provedores tem sua pr&oacute;pria linguagem de consulta (o provedor LDAP &eacute; um
	desses). &Eacute; tamb&eacute;m poss&iacute;vel chamar fun&ccedil;&otilde;es armazenadas no banco de 
	dados (stored procedures). Essas fun&ccedil;&otilde;es devem ser implementadas
	no sistema de banco de dados ou implementadas pelo provedor.
      </para>
      <para>
           O resultado de uma consulta &eacute; acessado atrav&eacute;s de 
	   objetos de tipo <classname>GdaRecordset</classname>. Os dados 
	   resultados da consultados podem estar armazenados no cliente, 
	   no  provedor ou no servidor de banco de dados. Isso depende
	   de v&aacute;rias op&ccedil;&otilde;es (flags) usadas quando o conjunto de registros
	   (recordsets) &eacute; criado. Posi&ccedil;&otilde;es em um conjunto de registros s&atilde;o
	   definidos atrav&eacute;s de marcadores (bookmark), que &eacute; um tipo de dado
	   opaco. Um marcador pode ser usado para posicionar o ponteiro de
	   acesso atual em um conjunto de registros. Uma vez que alguns
	   sistemas de bancos de dados n&atilde;o permitem posicionamento arbitr&aacute;rio
	   do ponteiro de acesso no resultado de uma consulta, o provedor 
	   armazena e guarda todas linhas obtidas. Se um conjunto de registros
	   &eacute; configurado para armazenar os dados no cliente, ent&atilde;o o marcador
	   &eacute; um simples ponteiro para essas linhas. Voc&ecirc; pode ler mais sobre
	   armazenamento de linhas de dados, caching e transa&ccedil;&otilde;es na se&ccedil;&atilde;o
	   sobre conjunto de registros.
      </para>
    </sect1>
    <sect1 id="gda-client-objects">
      <title>Vis&atilde;o geral dos objetos GDA</title>
      <para>
        A classe principal em GDA &eacute; a <classname>GdaConnection</classname>. Objetos
	desta classe estabelecem conex&otilde;es com o servidor CORBA
	e s&atilde;o necess&aacute;rios para quase tudo que o cliente vai fazer.
	Cada objeto tem um pointeiro direto ou indireto a um desses objetos.
      </para>
      <para>
           Outra classe muito importante &eacute; a <classname>GdaCommand</classname>.
	   Ela &eacute; usada para armazenar uma string com um comando e tamb&eacute;m
	   para executar este comando no servidor CORBA. Esta classe mant&eacute;m
	   uma refer&ecirc;ncia ao objeto de conex&atilde;o. A <function>execute</function> retorna
	   um objeto de classe <classname>GdaRecordset</classname>. Esta classe &eacute;
	   respons&aacute;vel por buffering e caching e gerencimento de mem&oacute;ria dos
	   dados retornados pelo servidor.
      </para>
    </sect1>
    <sect1 id="gda-client-types">
      <title>Data Types</title>
      <para>
           Um problema que GDA tenta esconder do usu&aacute;ria &eacute; a diren&ccedil;a nos
	   tipos de dados que s&atilde;o armazenados nos bancos de dados e como
	   eles s&atilde;o usados pela aplica&ccedil;&atilde;o. Um exemplo bem caracter&iacute;stico
	   &eacute; a representa&ccedil;&atilde;o de pre&ccedil;os. Estes s&atilde;o n&uacute;meros de ponto flutuante
	   com dois d&iacute;gitos depois do ponto decimal. A maioria dos bancos de
	   dados lhe permite especificar um tipo de dado DECIMAL com um
	   tamanho e precis&atilde;o definidas. Em C n&atilde;o existe um tipo de dado
	   equivalente. Voc&ecirc; pode querer guardar esse valor em uma string,
	   que &eacute; tamb&eacute;m conveniente para ser exibido, mas n&atilde;o &eacute; nada conveniente
	   para calcular juros, por exemplo. Por isso GDA transforma o tipo
	   de armazenamento do tipo da coluna para o tipo que o usu&aacute;rio quer.
	   Isto &eacute; feito atrav&eacute;s do tipo (<classname>GDA_Type</classname>) de um
	   valor. Se o banco de dados tiver a capacidade de converter diferentes
	   tipos de dados ela &eacute; usada. Se n&atilde;o, a convers&atilde;o &eacute; feita no cliente.
	   Converter os dados no servidor pode levar a resultados imprevis&iacute;veis
	   quando o servidor &eacute; uma m&aacute;quina de 64bits e o cliente &eacute; uma m&aacute;quina de 
	   32 bits.
      </para>
      <sect2>
        <title>Tipos de dados discpon&iacute;veis</title>
        <para>
	  Aqui est&aacute; um lista dos tipo de dados GDA, e seus equivalentes em C
	  e SQL, e as convers&otilde;es permitidas.
        </para>
      </sect2>
    </sect1> 
    <sect1 id="gda-client-meta">
      <title>Meta-Informa&ccedil;&atilde;o Da Fonte de Dados</title>
      <para>
           Todas fontes de dados devem prover fun&ccedil;&otilde;es que d&ecirc;em acesso a
	   suas meta-informa&ccedil;&otilde;es. Se a fonte de dados &eacute; um banco de dados,
	   tal meta-informa&ccedil;&atilde;o &eacute; o nome das tableas, colunas, permiss&otilde;es dos
	   usu&aacute;rios, etc. O resultado de uma consulta a meta-informa&ccedil;&atilde;o de
	   uma fonte de dados &eacute; representada atrav&eacute;s do <classname>GdaRecordset</classname>.
	   O problema &eacute; que na maioria das vezes o cliente est&aacute; interessado em
	   apenas parte dessa informa&ccedil;&atilde;o. O cliente quer consultar a fonte de
	   dados sobre os &iacute;ndices de uma tabela, e n&atilde;o de todas as tabelas.
	   Por isso &eacute; poss&iacute;vel passar limitantes na consulta a meta-informa&ccedil;&otilde;es.
	   Isso se complica mais ainda pelo fato de que cada consulta pode
	   querer impor diferentes limitantes. A listagem a seguir mostra que
	   tipos de consultas s&atilde;o implementadas e quais limitantes s&atilde;o v&aacute;lidos
	   para cada consulta. Os limitantes s&atilde;o passados em pares de nome-valores.
	   O nome &eacute; um enum e o valor &eacute; uma string. A fun&ccedil;&atilde;o que implementa a 
	   consulta &eacute; uma fun&ccedil;&atilde;o com n&uacute;meros de argumentos vari&aacute;veis e a lista
	   de argumentos deve ser fechada com um enum de valor 0.
      </para>
      <para>
        A tabela a seguir mosta os limitantes mais usados e quando us&aacute;-los.
	Alguns esquemas podem requerer que voc&ecirc; aplique um limitante.
      </para>
      <table frame=all><title>Significado dos principais limitantes padr&otilde;es</title>
        <tgroup cols=2 align=left colsep=1 rowsep=1>
          <colspec colname=c1>
          <colspec colname=c2>
          <colspec colname=c3>
          <thead>
            <row>
              <entry>Limitantes</entry>
              <entry>Uso</entry>
              <entry>Observa&ccedil;&otilde;es</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>GDA_Connection_OBJECT_CATALOG</entry>
              <entry>Usado para especificar-se o banco de dados</entry>
              <entry></entry>
            </row>
            <row>
              <entry>GDA_Connection_OBJECT_SCHEMA</entry>
              <entry>Usado para especificar-se o dono</entry>
              <entry></entry>
            </row>
            <row>
              <entry>GDA_Connection_OBJECT_NAME</entry>
              <entry>Usado para especificar-se o nome do objeto a consultar 
                     (tabela, ...)</entry>
              <entry></entry>
            </row>
            <row>
              <entry>GDA_Connection_EXTRA_INFO</entry>
              <entry>Ative-o para obter informa&ccedil;&atilde;o detalhada do
                     provedor</entry>
              <entry>Use uma string n&atilde;o nula (exemplo: "")</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>
        A tabela que segue mostra os esquemas "padr&otilde;es" que devem ser
	suportados por cada provedor GDA, entretanto um provedor espec&iacute;fico
	pode n&atilde;o suportar alguns desses. Para testar se um esquema &eacute; suportado,
	veja a fun&ccedil;&atilde;o <function>gda_connection_supports()</function>.
      </para>
      <table frame=all><title>Esquemas padr&otilde;es e limitantes suportados</title>
        <tgroup cols=2 align=left colsep=1 rowsep=1>
          <colspec colname=c1>
          <colspec colname=c2>
          <colspec colname=c3>
          <colspec colname=c4>
          <colspec colname=c5>
          <thead>
            <row>
              <entry>Tipo de Objeto</entry>
              <entry>Identificador GDA</entry>
              <entry>Limitantes Suportados</entry>
              <entry>Campos Retornados</entry>
              <entry>Informa&ccedil;&atilde;o Extra</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>Tabelas</entry>
              <entry>GDA_Connection_GDCN_SCHEMA_TABLES</entry>
              <entry>GDA_Connection_OBJECT_NAME,
                     GDA_Connection_OBJECT_CATALOG,
                     GDA_Connection_OBJECT_SCHEMA,
                     GDA_Connection_EXTRA_INFO</entry>
              <entry>nome, coment&aacute;rios</entry>
              <entry>nome, dono, coment&aacute;rios, defini&ccedil;&atilde;o SQL</entry>
            </row>
            <row>
              <entry>Tabelas pais (para provedores que suportam parentesco)</entry>
              <entry>GDA_Connection_GDCN_SCHEMA_TAB_PARENTS</entry>
              <entry>GDA_Connection_OBJECT_NAME (required),
                     GDA_Connection_OBJECT_CATALOG</entry>
              <entry>nome, ordem de parentesco</entry>
              <entry>N&atilde;o Suportado</entry>
            </row>
            <row>
              <entry>Views</entry>
              <entry>GDA_Connection_GDCN_SCHEMA_VIEWS</entry>
              <entry>GDA_Connection_OBJECT_NAME,
                     GDA_Connection_OBJECT_CATALOG,
                     GDA_Connection_OBJECT_SCHEMA,
                     GDA_Connection_EXTRA_INFO</entry>
              <entry>nome, coment&aacute;rios</entry>
              <entry>nome, dono, coment&aacute;rios, defini&ccedil;&atilde;o SQL</entry>
            </row>
            <row>
              <entry>Colunas de uma tabela (ou view)</entry>
              <entry>GDA_Connection_GDCN_SCHEMA_COLUMNS</entry>
              <entry>GDA_Connection_OBJECT_NAME (required),
                     GDA_Connection_OBJECT_CATALOG,
                     GDA_Connection_OBJECT_SCHEMA,
                     GDA_Connection_COLUMN_NAME</entry>
              <entry>nome, tipo, tamanho, precis&atilde;o, 
                     anul&aacute;vel (poder ser nulo), &eacute; chave, valor padr&atilde;o, coment&aacute;rios</entry>
              <entry>N&atilde;o suportado</entry>
            </row>
            <row>
              <entry>Sequ&ecirc;ncias</entry>
              <entry>GDA_Connection_GDCN_SCHEMA_SEQUENCES</entry>
              <entry>GDA_Connection_OBJECT_NAME,
                     GDA_Connection_OBJECT_CATALOG,
                     GDA_Connection_OBJECT_SCHEMA,
                     GDA_Connection_EXTRA_INFO</entry>
              <entry>nome, coment&aacute;rios</entry>
              <entry>nome, dono, coment&aacute;rios, defini&ccedil;&atilde;o SQL</entry>
            </row>
            <row>
              <entry>Procedimentos</entry>
              <entry>GDA_Connection_GDCN_SCHEMA_PROCS</entry>
              <entry>GDA_Connection_OBJECT_NAME,
                     GDA_Connection_OBJECT_CATALOG,
                     GDA_Connection_OBJECT_SCHEMA,
                     GDA_Connection_EXTRA_INFO</entry>
              <entry>nome, Id do objeto, coment&aacute;rios</entry>
              <entry>nome, Id do objeto, dono, coment&aacute;rios, n&uacute;mero de argumentos, 
                     defini&ccedil;&atilde;o SQL</entry>
            </row>
            <row>
              <entry>Par&acirc;metros para procedimentos</entry>
              <entry>GDA_Connection_GDCN_SCHEMA_PROC_PARAMS</entry>
              <entry>GDA_Connection_OBJECT_NAME (necess&aacute;rio)</entry>
              <entry>Uso(entrada, sa&iacute;da or entrada/sa&iacute;da), tipo</entry>
              <entry>N&atilde;o Suportado</entry>
            </row>
            <row>
              <entry>Agregados</entry>
              <entry>GDA_Connection_GDCN_SCHEMA_AGGREGATES</entry>
              <entry>GDA_Connection_OBJECT_NAME,
                     GDA_Connection_OBJECT_CATALOG,
                     GDA_Connection_OBJECT_SCHEMA,
                     GDA_Connection_EXTRA_INFO</entry>
              <entry>nome, Id do objeto, tipo entrada, coment&aacute;rios</entry>
              <entry>nome, Id do objeto, tipo entrada, dono, coment&aacute;rios, 
                     defini&ccedil;&atilde;o SQL</entry>
            </row>
            <row>
              <entry>Tipos</entry>
              <entry>GDA_Connection_GDCN_SCHEMA_PROV_TYPES</entry>
              <entry>GDA_Connection_OBJECT_NAME,
                     GDA_Connection_OBJECT_CATALOG,
                     GDA_Connection_OBJECT_SCHEMA,
                     GDA_Connection_EXTRA_INFO</entry>
              <entry>nome, dono, coment&aacute;rios, tipo Gda, tipo provedor</entry>
              <entry>nome, coment&aacute;rios</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>
        Voc&ecirc; deve prestar aten&ccedil;&atilde;o especial para os limitantes usados (em aplica&ccedil;&otilde;es clientes
	e em provedores GDA), porque &eacute; necess&aacute;rios que os limitantes retornem um erro se
	um limitante inv&aacute;lido for passado ao servidor. Isto &eacute; especialmente importante,
	uma vez que h&aacute; esquemas que podem ter significados diferentes dependendo no conjunto
	de limitantes usado. Como voc&ecirc; pode imaginar, isso pode levar a uma situa&ccedil;&atilde;o onde o
	cliente acaba recendo dados que ele n&atilde;o solicitou.
      </para>
    </sect1>
    <sect1 id="gda-client-batch">
      <title>Comandos Em S&eacute;rie</title>
      <para>
        A biblioteca cliente oferece um objeto muito interessante: <classname>GdaBatch</classname>,
	que &eacute; uma classe que permite que voc&ecirc; trate uma s&eacute;rie de objetos como um
	&uacute;nica entidade. Ela oferece este recurso com suporte real a transa&ccedil;&otilde;es
	(se o banco de dados sendo usado suportar). As altera&ccedil;&otilde;es no banco de dados s&oacute; 
	s&atilde;o efetivadas se nenhum erro ocorrer, e consequentemente, caso um erro seja
	retornado pelo banco de dados, a execu&ccedil;&atilde;o do mesmo &eacute; cancelada. Este modelo
	lhe oferece suporte similar a transa&ccedil;&otilde;es em suas aplica&ccedil;&otilde;es com apenas algumas
	linhas de c&oacute;digo.
      </para>
      <para>
        Por&eacute;m, o objeto <classname>GdaBatch</classname> &eacute; flex&iacute;vel bastante para ser usado como
	um simples conjunto de comandos, ignorando erros se &eacute; o que o voc&ecirc; quer, e
	desabilitando o suporte a transa&ccedil;&otilde;es do seu banco de dados. Nesse caso, a
	melhor maneira de usar o objeto &eacute; conect&aacute;-lo &aacute; seus diferentes sinais, o que
	lhe permite saber a qualquer momento o status da execu&ccedil;&atilde;o de cada comando.
      </para>
    </sect1>
  </chapter>
  
  <chapter>
    <title>Clientes GDA</title>
    <sect1 id="clients-introduction">
      <title>Introdu&ccedil;&atilde;o</title>
      <para>
        Aplica&ccedil;&otilde;es clientes GDA podem ser de dois tipos:
        <itemizedlist>
          <listitem>
            <para>
	      Aplica&ccedil;&otilde;es que fazem uso das biblioteca cliente &Libgda. Estes
	      s&atilde;o os mais comuns, sendo de uso claro e f&aacute;cil, uma vez que
	      eles escondem todo a complexidade do CORBA com uma API
	      f&aacute;cil de usar.
            </para>
          </listitem>
          <listitem>
            <para>
	      Clientes CORBA. Voce pode querer desenvolver um aplica&ccedil;&atilde;o cliente
	      CORBA em uma outra linguagem ou em uma outra plataforma com
	      uma implementa&ccedil;&atilde;o CORBA ORB diferente. Nesse caso, voc&ecirc; teria
	      que gerar os stubs do cliente usando seu compilador de IDL para
	      compilar os arquivos IDL que acompanham &Libgda;. Se voc&ecirc; for
	      fazer algo desse tipo, entre em contato com os desenvolvedores
	      da &Libgda; para que possamos saber como o programa se portaria
	      sob essas circunst&acirc;ncias.
            </para>
          </listitem>
        </itemizedlist>
      </para>
    </sect1>
    <sect1 id="clients-building">
      <title>Compilando Clientes GDA</title>
      <para>
        H&aacute; um scipt chamado <filename>gda-buildclient</filename> que cuida
	de todas as bibliotecas necess&aacute;rias para criar-se uma aplica&ccedil;&atilde;o cliente
	GDA. Isso &eacute; que tudo que ele faz, ent&atilde;o voc&ecirc; achar que n&atilde;o vale apena
	us&aacute;-lo, mas ele &eacute; inclu&iacute;do por sua simplicidade.
      </para>
      <para>
        Uma invoca&ccedil;&atilde;o t&iacute;pica do script seria mais ou menos assim:
        <programlisting>
          gda-buildclient --o cliente
                          --f &lt;lista de arquivos .o &gt;
                          [--l &lt;lista de bibliotecas adicionais&gt;]
                          [--L &lt;lista de diret&oacute;rios para procurar por bibliotecas&gt;]
        </programlisting>
      </para>
    </sect1>
    <sect1 id="clients-building-corba">
      <title>Compilando Clientes CORBA GDA</title>
      <para>
	Para mostrar como fazer isso, o compilador IDL JAVA ser&aacute; usado como
	exemplo. Como voc&ecirc; j&aacute; deve saber se voc&ecirc; quer escrever um cliente
	CORBA, um arquivo IDL &eacute; usado para definir as interfaces oferecidas
	pelo servidor CORBA. Este arquivo IDL &eacute; usado por um programa chamado
	de "compilador IDL" para criar stubs para os clientes e skeletons
	para os servidores implementado a interface ORB particular. &Libgda;
	oferece um arquivo IDL que define todas as interfaces exportadas. Este
	arquivo &eacute; chamado <filename>gda.idl</filename> e pode ser encontrado
	junto na distribui&ccedil;&atilde;o padr&atilde;o do &Libgda;.
      </para>
      <para>
	O compilador IDL &eacute; o que voc&ecirc; vai precisar para gerar, neste caso,
	os stubs para o cliente. Ent&atilde;o, por exemplo, usando o compilador de
	IDL JAVA, voc&ecirc; executaria o comando:
        <programlisting>
          java-idl gda.idl
        </programlisting>
      </para>
      <para>
	Isso resultaria em uma s&eacute;ria de arquivos .java.
      </para>
    </sect1>
  </chapter>

  <chapter>
    <title>Provedores GDA</title>
    <sect1 id="providers-introduction">
      <title>Introdu&ccedil;&atilde;o</title>
      <para>
	Estes s&atilde;o execut&aacute;veis ou bibliotecas compartilhadas fazendo
	todo o trabalho de convers&atilde;o. Eles mapeam as chamadas feitas
	as fun&ccedil;&otilde;es CORBA para a as fun&ccedil;&otilde;es espec&iacute;ficas de uma fonte de dados.
	Estes podem usar ODCD, uma biblioteca nativa para o banco de dados,
	geradores e leitores de XML, LDAP, POP3, o que voc&ecirc; possa imaginar.
      </para>
      <para>
	H&aacute; muito trabalho envolvido em provedores GDA, especialmente se a
	fonte de dados n&atilde;o &eacute; um banco de dados. Nesse caso, al&eacute;m de mapear
	a API para o modelo GDA, aten&ccedil;&atilde;o especial tem que ser tomada para
	mapear a estrutura tipo banco de dados para uma estrutura diferente.
	Em ambos os casos, essa &eacute; a parte mais complexa da arquitetura GDA.
      </para>
      <para>
	Existe um conjunto de ferramentas oferecidos com &Libgda; para facilitar
	o processo de adicionar um novo servidor. Isso &eacute; feito principalmente
	atrav&eacute;s de um script chamado <filename>gda-buildserver</filename>, que
	pode ser usado para criar um estrutura b&aacute;sica para se criar um novo
	provedor, e tamb&eacute;m para compil&aacute;-lo. Se voc&ecirc; escrever um novo provedor
	entre em contato com os desenvolvedores da &Libgda; para conversar
	sobre a sua inclus&atilde;o no c&oacute;digo oficial do &Libgda;.
      </para>
      <para>
	Outra maneira de criar-se um provedor GDA, seria usar os arquivos IDL
	para gerar a implementa&ccedil;&atilde;o de um servidor. Desta maneira voc&ecirc; pode
	escrever o provedor na sua linguagem e implementa&ccedil;&atilde;o CORBA ORB preferida.
	Se voc&ecirc; quer fazer algo desse tipo, por favor entre em contato com os
	desenvolvedores da &Libgda;.
      </para>
    </sect1>
    <sect1 id="providers-implementation">
      <title>Implementa&ccedil;&atilde;o dos Provedores GDA</title>
      <para>
	O objetivo da biblioteca <filename>gda-server</filename> &eacute; esconder do programador
	toda a complexidade CORBA para o desenvolvimento de provedores e elimina
	a duplica&ccedil;&atilde;o de trabalho e leva a c&oacute;digo muito mais f&aacute;cil de ser depurado.
	A biblioteca fica no mesmo n&iacute;vel da biblioteca <filename>gda-server</filename>
	do ponto de vista CORBA.
      </para>
      <para>
	A biblioteca <filename>gda-server</filename> imp&otilde;e uma certa estrutura
	na maneira que provedores devem ser implementados, mas tamb&eacute;m permitem
	customiza&ccedil;&atilde;o.
      </para>
      <sect2>
        <title>Objetos na biblioteca</title>
        <para>
	  Todos objetos aqui s&atilde;o esp&eacute;cies de espelhos dos objetos da biblioteca
	  gda-cliente, formando a parte servidor da estrutura CORBA da &Libgda;.
        </para>
        <itemizedlist>
          <listitem>
            <para>
	      o objeto <classname>GdaServerConnection</classname>: este &eacute; o objeto mais
	      importante e cuida de toda a parte da conex&atilde;o a fonte de dados (no caso de
	      um banco de dados, o nome do banco de dados, usu&aacute;rio, senha, etc).
	      Geralmente o cliente apenas usa um desse tipo de objeto.
            </para>
          </listitem>
          <listitem>
            <para>
	      o objeto <classname>GdaServerCommand</classname>: este objeto &eacute;
	      usado para preparar uma consulta para ser executada.
            </para>
          </listitem>
          <listitem>
            <para>
	      o objeto <classname>GdaServerRecordset</classname>: cada vez que um
	      comando &eacute; executado, um desses objetos &eacute; retornado, e podem ser examinados
	      para ver-se os resultados do comando. Sob a &Libgda;, um conjunto de registros
	      &eacute; examinado de maneira sequ&ecirc;ncial, linha ap&oacute;s linha (para alguns sistemas de
	      banco de dados essa &eacute; a maneira que os resultados de uma consulta s&atilde;o manuseados,
	      enquanto em outras, existe a possibilidade de acessar os resultados de maneira
	      rand&ocirc;mica).
            </para>
          </listitem>
          <listitem>
            <para>
              o objeto <classname>GdaServerField</classname>: para cada coluna, um desses
	      objetos &eacute; usado. Ele descreve o nome da coluna, o tipo de dado, e seu conte&uacute;do.
	      Cada objeto <classname>GdaServerField</classname> &eacute; inicializado quando o
	      conjunto de registros &eacute; criado, e seu valor ser&aacute; atualizado cada vez que uma nova
	      linha &eacute; examinada. O <filename>gda-server</filename> usar&aacute; estes objetos para
	      enviar o conte&uacute;do para o cliente CORBA.
            </para>
          </listitem>
        </itemizedlist>
      </sect2>
      <sect2>
        <title>Como uma consulto &eacute; processada</title>
        <para>
	  Isso &eacute; o que acontece do lado do servidor quando um cliente faz uma consulta:
        </para>
        <itemizedlist>
          <listitem>
            <para>
              1- um <classname>GdaServerConnection</classname> &eacute; criado
            </para>
          </listitem>
          <listitem>
            <para>
              2- a conex&atilde;o &eacute; aberta
            </para>
          </listitem>
          <listitem>
            <para>
              3 - um <classname>GdaServerCommand</classname> &eacute; criado
            </para>
          </listitem>
          <listitem>
            <para>
              4 - o comando &eacute; colocado no objeto <classname>GdaServerCommand</classname>
            </para>
          </listitem>
          <listitem>
            <para>
              5- o comando &eacute; executado, e se nenhum erro ocorrer, um objeto
              <classname>GdaServerRecordset</classname> &eacute; criado e retornado
            </para>
          </listitem>
          <listitem>
            <para>
              6 - o <classname>GdaServerCommand</classname> pode ser destru&iacute;do sem problemas
            </para>
          </listitem>
          <listitem>
            <para>
              7- a primeira linha do conjunto de registror pode ser examinada, ent&atilde;o a 
	      segunda, terceira, etc
            </para>
          </listitem>
          <listitem>
            <para>
              8- o <classname>GdaServerRecordset</classname> &eacute; destru&iacute;do
            </para>
          </listitem>
          <listitem>
            <para>
              9- a conex&atilde;o &eacute; fechada, e o <classname>GdaServerConnection</classname> pode
	      ser destru&iacute;do.
            </para>
          </listitem>
        </itemizedlist>
      </sect2>
      <sect2>
        <title>Customiza&ccedil;&atilde;o de um sistema de banco de dados</title>
        <para>
	  Todos os passos descritos acima s&atilde;o impostos pela estrutra &Libgda;. A implementa&ccedil;&atilde;o
	  de um provedor para um tipo espec&iacute;fico de banco de dados &eacute;, na verdade, a implementa&ccedil;&atilde;o
	  de cada um dos passos descritos acima.
        </para>
        <para>
	    Como a biblioteca C para um certo sistema de banco de dados usa estruturas espec&iacute;ficas (para
	  lidar com refer&ecirc;ncias de conex&otilde;es, etc) &eacute; poss&iacute;vel anexar alguma informa&ccedil;&atilde;o aos objetos da 
	  biblioteca <filename>gda-server</filename>. Ent&atilde;o geralmente o implementador do provedor
	  define as seguintes estruturas (substitua DBMS, DataBase Management System, pelo nome do
	  seu banco de dados, como por exemplo MYSQL ou POSTGRES):
        </para>
        <itemizedlist>
          <listitem>
            <para>
	      a estrutura de conex&atilde;o &eacute; geralmente chamada de DBMS_Connection
            </para>
          </listitem>
          <listitem>
            <para>
	      a estrutora de comando &eacute; geralmente chamada de DBMS_Command
            </para>
          </listitem>
          <listitem>
            <para>
	      a estrutora de conjunto de registros &eacute; geralmente chamada de DBMS_Recordset
            </para>
          </listitem>
        </itemizedlist>
      </sect2>
    </sect1>
    <sect1 id="providers-actual-implementation">
      <title>Implementa&ccedil;&atilde;o do sistema de banco de dados</title>
      <para>
	Nessa se&ccedil;&atilde;o est&atilde;o algumas recomenda&ccedil;&otilde;es de como lidar com problemas espec&iacute;ficos de cada
	sistema de banco de dados.
      </para>
      <sect2>
        <title>Manuseamento de tipos de dados</title>
        <para>
	  &Libgda; tem alguns tipos de dados definidos, cobrindo todos os tipos de dados comuns
	  (strings, n&uacute;meros, datas, bin&aacute;rios, etc). Entretando, porque cada sistema de banco de dados
	  tem tipos espec&iacute;ficos de dados (como, por exemplo, array, endere&ccedil;os IP), e as vezes &eacute; possivel
	  criar tipos de dados personalizados, &Libgda; n&atilde;o pode ter conhecimento de todos tipos de dados.
        </para>
        <para>
	  Ent&atilde;o, para os tipos mais comuns onde um tipo de dado &Libgda; existe, este ser&aacute; usado,
	  e de maneira contr&aacute;ria, o tipo <classname>GdaTypeUnknown</classname> ser&aacute; usado (o uso
	    correto destes dados fica por conta do programador da aplica&ccedil;&atilde;o).
        </para>
      </sect2>
      <sect2>
        <title>Solicita&ccedil;&otilde;es de Esquemas</title>
        <para>
	  Sob a &Libgda;, a aplica&ccedil;&atilde;o cliente n&atilde;o tem como saber a qual sistema de banco de dados ela
	  est&aacute; conectada, mas ela pode saber se tal sistema suporta certos recursos e quais s&atilde;o as
	  tabelas, &iacute;ndices, etc, contidas no banco de dados.
        </para>
        <para>
	       Uma das tarefas que mais consomem tempo &eacute; escrever fun&ccedil;&otilde;es que retornem respostas a
	       todos essas solicita&ccedil;&otilde;es do cliente.
        </para>
      </sect2>
      <sect2>
        <title>Fun&ccedil;&otilde;es a implementar</title>
        <para>
	  O trabalho b&aacute;sico a ser feito &eacute; implementar um conjunto de fun&ccedil;&otilde;es necess&aacute;rios
	  para que a biblioteca <filename>gda-server</filename> manipule o provedor.
	  Quanto um provedor quer iniciar, ele tem que dar ponteiros a estas fun&ccedil;&otilde;es
	  em uma estrutura (veja o arquivo <filename>main-DBMS.c</filename> para isso).
        </para>
        <para>
	  O outro conjunto de fun&ccedil;&otilde;es a implementar s&atilde;o relacionados com solicita&ccedil;&otilde;es de esquemas.
	  Entre as fun&ccedil;&otilde;es que voc&ecirc; DEVE implementar est&aacute; um fun&ccedil;&atilde;o para solicitar esquemas. Esta
	  fun&ccedil;&atilde;o pode ser implementada da maneira que voc&ecirc; quiser, mas uma pr&aacute;tica comum (usado em
	  todos provedores 'padr&otilde;es' da &Libgda;) &eacute; fazer com que esta fun&ccedil;&atilde;o, chame outras fun&ccedil;&otilde;es
	  dependendo do tipo de esquema solicitado pela aplica&ccedil;&atilde;o cliente.
        </para>
      </sect2>
    </sect1>
    <sect1 id="providers-examples">
      <title>Arquivos e exemplos</title>
      <sect2>
        <title>Headers</title>
        <para>
	  Geralmente um provedor tem apenas um header (gda-DBMS.h) que cont&eacute;m todas as defini&ccedil;&otilde;es
	  de estruturas e declara&ccedil;&otilde;es de fun&ccedil;&otilde;es. Este header precisa incluir o arquivo 
	  <filename>gda-server.h</filename>.
        </para>
        <para>
	    O provedor tamb&eacute;m precisa os elementos comuns da biblioteca <filename>gda-common</filename>
	    (para parte de XML, etc... quando estiver pronta).
        </para>
      </sect2>
      <sect2>
        <title>Arquivos .c</title>
        <para>
	  Geralmente h&aacute; apenas um arquivo .c para a implementa&ccedil;&atilde;o das diferentes estruturas de um
	  sistema de banco de dados, como  mencionado acima, exceto pelo objeto <classname>GdaServerField</classname>
	  que &eacute; totalmente controlado pela biblioteca <filename>gda-server</filename>, e um para
	  o programa.
        </para>
      </sect2>
      <sect2>
        <title>Exemplo de implementa&ccedil;&otilde;es</title>
        <para>
	  Voc&ecirc; pode dar uma olhada nos provedores distribu&iacute;dos com &Libgda;, que fazem uso desta biblioteca.
	  O provedor PostgreSQL &eacute; especialmente interessante, pois &eacute; um bom exemplo de customiza&ccedil;&atilde;o de provedor.
	  Este inclui funcionalidade extra n&atilde;o presente em outros provedores como os "buil-in recordsets",
	  que s&atilde;o usados para obter-se dados diretamente, n&atilde;o sendo este um valor retornado pelo PostgreSQL.
        </para>
      </sect2>
    </sect1>
  </chapter>
  
</book>
